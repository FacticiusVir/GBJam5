<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SharpVk</name>
    </assembly>
    <members>
        <member name="T:SharpVk.CommandCache">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.CommandCache.GetCommandDelegate``1(System.String,System.String)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:SharpVk.IProcLookup">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.IProcLookup.GetProcedureAddress(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:SharpVk.Interop.AllocationFunctionDelegate">
            <summary>
            <para>
            Application-defined memory allocation function.
            </para>
            <para>
            [[vkAllocationFunction_return_rules]] If pname:pfnAllocation is unable to allocate the requested memory, it must: return `NULL`. If the allocation was successful, it must: return a valid pointer to memory allocation containing at least pname:size bytes, and with the pointer value being a multiple of pname:alignment.
            </para>
            <para>
            [NOTE] .Note ==== Correct Vulkan operation cannot: be assumed if the application does not follow these rules.
            </para>
            <para>
            For example, pname:pfnAllocation (or pname:pfnReallocation) could cause termination of running Vulkan instance(s) on a failed allocation for debugging purposes, either directly or indirectly. In these circumstances, it cannot: be assumed that any part of any affected VkInstance objects are going to operate correctly (even flink:vkDestroyInstance), and the application must: ensure it cleans up properly via other means (e.g. process termination). ====
            </para>
            <para>
            If pname:pfnAllocation returns `NULL`, and if the implementation is unable to continue correct processing of the current command without the requested allocation, it must: treat this as a run-time error, and generate ename:VK_ERROR_OUT_OF_HOST_MEMORY at the appropriate time for the command in which the condition was detected, as described in &lt;&lt;fundamentals-errorcodes, Return Codes&gt;&gt;.
            </para>
            <para>
            If the implementation is able to continue correct processing of the current command without the requested allocation, then it may: do so, and must: not generate ename:VK_ERROR_OUT_OF_HOST_MEMORY as a result of this failed allocation.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DebugReportCallbackDelegate">
            <summary>
            <para>
            Application-defined debug report callback function.
            </para>
            <para>
            The callback returns a basetype:VkBool32 that indicates to the calling layer if the Vulkan call should: be aborted or not. Applications should: always return ename:VK_FALSE so that they see the same behavior with and without validation layers enabled.
            </para>
            <para>
            If the application returns ename:VK_TRUE from its callback and the Vulkan call being aborted returns a elink:VkResult, the layer will return ename:VK_ERROR_VALIDATION_FAILED_EXT.
            </para>
            <para>
            [NOTE] .Note ==== The primary expected use of ename:VK_ERROR_VALIDATION_FAILED_EXT is for validation layer testing. It is not expected that an application would see this error code during normal use of the validation layers. ====
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.FreeFunctionDelegate">
            <summary>
            <para>
            Application-defined memory free function.
            </para>
            <para>
            pname:pMemory may: be `NULL`, which the callback must: handle safely. If pname:pMemory is non-`NULL`, it must: be a pointer previously allocated by pname:pfnAllocation or pname:pfnReallocation. The application should: free this memory.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.InternalAllocationNotificationDelegate">
            <summary>
            <para>
            Application-defined memory allocation notification function.
            </para>
            <para>
            This is a purely informational callback.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.InternalFreeNotificationDelegate">
            <summary>
            <para>
            Application-defined memory free notification function.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ReallocationFunctionDelegate">
            <summary>
            <para>
            Application-defined memory reallocation function.
            </para>
            <para>
            pname:pfnReallocation must: return an allocation with enough space for pname:size bytes, and the contents of the original allocation from bytes zero to latexmath:[$\min(\textrm{original size, new size})-1$] must: be preserved in the returned allocation. If pname:size is larger than the old size, the contents of the additional space are undefined. If satisfying these requirements involves creating a new allocation, then the old allocation should: be freed.
            </para>
            <para>
            If pname:pOriginal is `NULL`, then pname:pfnReallocation must: behave equivalently to a call to tlink:PFN_vkAllocationFunction with the same parameter values (without pname:pOriginal).
            </para>
            <para>
            If pname:size is zero, then pname:pfnReallocation must: behave equivalently to a call to tlink:PFN_vkFreeFunction with the same pname:pUserData parameter value, and pname:pMemory equal to pname:pOriginal.
            </para>
            <para>
            If pname:pOriginal is non-`NULL`, the implementation must: ensure that pname:alignment is equal to the pname:alignment used to originally allocate pname:pOriginal.
            </para>
            <para>
            If this function fails and pname:pOriginal is non-`NULL` the application must: not free the old allocation.
            </para>
            <para>
            pname:pfnReallocation must: follow the same &lt;&lt;vkAllocationFunction_return_rules, rules for return values as tname:PFN_vkAllocationFunction&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.VoidFunctionDelegate">
            <summary>
            <para>
            Dummy function pointer type returned by queries.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateInstance">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyInstance">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkEnumeratePhysicalDevices">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceFeatures">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceFormatProperties">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceImageFormatProperties">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceProperties">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceQueueFamilyProperties">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceMemoryProperties">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetInstanceProcAddr">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetDeviceProcAddr">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateDevice">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyDevice">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkEnumerateInstanceExtensionProperties">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkEnumerateDeviceExtensionProperties">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkEnumerateInstanceLayerProperties">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkEnumerateDeviceLayerProperties">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetDeviceQueue">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkQueueSubmit">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkQueueWaitIdle">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDeviceWaitIdle">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkAllocateMemory">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkFreeMemory">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkMapMemory">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkUnmapMemory">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkFlushMappedMemoryRanges">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkInvalidateMappedMemoryRanges">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetDeviceMemoryCommitment">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkBindBufferMemory">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkBindImageMemory">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetBufferMemoryRequirements">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetImageMemoryRequirements">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetImageSparseMemoryRequirements">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceSparseImageFormatProperties">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkQueueBindSparse">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateFence">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyFence">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkResetFences">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetFenceStatus">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkWaitForFences">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateSemaphore">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroySemaphore">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateEvent">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyEvent">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetEventStatus">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkSetEvent">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkResetEvent">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateQueryPool">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyQueryPool">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetQueryPoolResults">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateBuffer">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyBuffer">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateBufferView">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyBufferView">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateImage">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyImage">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetImageSubresourceLayout">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateImageView">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyImageView">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateShaderModule">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyShaderModule">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreatePipelineCache">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyPipelineCache">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPipelineCacheData">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkMergePipelineCaches">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateGraphicsPipelines">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateComputePipelines">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyPipeline">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreatePipelineLayout">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyPipelineLayout">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateSampler">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroySampler">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateDescriptorSetLayout">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyDescriptorSetLayout">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateDescriptorPool">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyDescriptorPool">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkResetDescriptorPool">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkAllocateDescriptorSets">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkFreeDescriptorSets">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkUpdateDescriptorSets">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateFramebuffer">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyFramebuffer">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateRenderPass">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyRenderPass">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetRenderAreaGranularity">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateCommandPool">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyCommandPool">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkResetCommandPool">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkAllocateCommandBuffers">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkFreeCommandBuffers">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkBeginCommandBuffer">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkEndCommandBuffer">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkResetCommandBuffer">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdBindPipeline">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdSetViewport">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdSetScissor">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdSetLineWidth">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdSetDepthBias">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdSetBlendConstants">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdSetDepthBounds">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdSetStencilCompareMask">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdSetStencilWriteMask">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdSetStencilReference">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdBindDescriptorSets">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdBindIndexBuffer">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdBindVertexBuffers">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdDraw">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdDrawIndexed">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdDrawIndirect">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdDrawIndexedIndirect">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdDispatch">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdDispatchIndirect">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdCopyBuffer">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdCopyImage">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdBlitImage">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdCopyBufferToImage">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdCopyImageToBuffer">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdUpdateBuffer">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdFillBuffer">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdClearColorImage">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdClearDepthStencilImage">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdClearAttachments">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdResolveImage">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdSetEvent">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdResetEvent">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdWaitEvents">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdPipelineBarrier">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdBeginQuery">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdEndQuery">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdResetQueryPool">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdWriteTimestamp">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdCopyQueryPoolResults">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdPushConstants">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdBeginRenderPass">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdNextSubpass">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdEndRenderPass">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdExecuteCommands">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroySurfaceKHR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceSurfaceSupportKHR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceSurfaceCapabilitiesKHR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceSurfaceFormatsKHR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceSurfacePresentModesKHR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateSwapchainKHR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroySwapchainKHR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetSwapchainImagesKHR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkAcquireNextImageKHR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkQueuePresentKHR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceDisplayPropertiesKHR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceDisplayPlanePropertiesKHR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetDisplayPlaneSupportedDisplaysKHR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetDisplayModePropertiesKHR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateDisplayModeKHR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetDisplayPlaneCapabilitiesKHR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateDisplayPlaneSurfaceKHR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateSharedSwapchainsKHR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateXlibSurfaceKHR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceXlibPresentationSupportKHR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateXcbSurfaceKHR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceXcbPresentationSupportKHR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateWaylandSurfaceKHR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceWaylandPresentationSupportKHR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateMirSurfaceKHR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceMirPresentationSupportKHR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateAndroidSurfaceKHR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateWin32SurfaceKHR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceWin32PresentationSupportKHR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateDebugReportCallbackEXT">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyDebugReportCallbackEXT">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDebugReportMessageEXT">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDebugMarkerSetObjectTagEXT">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDebugMarkerSetObjectNameEXT">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdDebugMarkerBeginEXT">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdDebugMarkerEndEXT">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdDebugMarkerInsertEXT">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdDrawIndirectCountAMD">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdDrawIndexedIndirectCountAMD">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceExternalImageFormatPropertiesNV">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetMemoryWin32HandleNV">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Buffer">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.Buffer.Null">
            <summary>
            Returns a value representing a null Buffer handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.BufferView">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.BufferView.Null">
            <summary>
            Returns a value representing a null BufferView handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.CommandBuffer">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.CommandBuffer.Null">
            <summary>
            Returns a value representing a null CommandBuffer handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.CommandPool">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.CommandPool.Null">
            <summary>
            Returns a value representing a null CommandPool handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DebugReportCallback">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.DebugReportCallback.Null">
            <summary>
            Returns a value representing a null DebugReportCallback handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DescriptorPool">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.DescriptorPool.Null">
            <summary>
            Returns a value representing a null DescriptorPool handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DescriptorSet">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.DescriptorSet.Null">
            <summary>
            Returns a value representing a null DescriptorSet handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DescriptorSetLayout">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.DescriptorSetLayout.Null">
            <summary>
            Returns a value representing a null DescriptorSetLayout handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Device">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.Device.Null">
            <summary>
            Returns a value representing a null Device handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DeviceMemory">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.DeviceMemory.Null">
            <summary>
            Returns a value representing a null DeviceMemory handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Display">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.Display.Null">
            <summary>
            Returns a value representing a null Display handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DisplayMode">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.DisplayMode.Null">
            <summary>
            Returns a value representing a null DisplayMode handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Event">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.Event.Null">
            <summary>
            Returns a value representing a null Event handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Fence">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.Fence.Null">
            <summary>
            Returns a value representing a null Fence handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Framebuffer">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.Framebuffer.Null">
            <summary>
            Returns a value representing a null Framebuffer handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Image">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.Image.Null">
            <summary>
            Returns a value representing a null Image handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ImageView">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.ImageView.Null">
            <summary>
            Returns a value representing a null ImageView handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Instance">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.Instance.Null">
            <summary>
            Returns a value representing a null Instance handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PhysicalDevice">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.PhysicalDevice.Null">
            <summary>
            Returns a value representing a null PhysicalDevice handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Pipeline">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.Pipeline.Null">
            <summary>
            Returns a value representing a null Pipeline handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineCache">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.PipelineCache.Null">
            <summary>
            Returns a value representing a null PipelineCache handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineLayout">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.PipelineLayout.Null">
            <summary>
            Returns a value representing a null PipelineLayout handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.QueryPool">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.QueryPool.Null">
            <summary>
            Returns a value representing a null QueryPool handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Queue">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.Queue.Null">
            <summary>
            Returns a value representing a null Queue handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.RenderPass">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.RenderPass.Null">
            <summary>
            Returns a value representing a null RenderPass handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Sampler">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.Sampler.Null">
            <summary>
            Returns a value representing a null Sampler handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Semaphore">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.Semaphore.Null">
            <summary>
            Returns a value representing a null Semaphore handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ShaderModule">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.ShaderModule.Null">
            <summary>
            Returns a value representing a null ShaderModule handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Surface">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.Surface.Null">
            <summary>
            Returns a value representing a null Surface handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Swapchain">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Interop.Swapchain.Null">
            <summary>
            Returns a value representing a null Swapchain handle.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.AllocationCallbacks">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.AllocationCallbacks.UserData">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.AllocationCallbacks.PfnAllocation">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.AllocationCallbacks.PfnReallocation">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.AllocationCallbacks.PfnFree">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.AllocationCallbacks.PfnInternalAllocation">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.AllocationCallbacks.PfnInternalFree">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.AndroidSurfaceCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.AndroidSurfaceCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.AndroidSurfaceCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.AndroidSurfaceCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.AndroidSurfaceCreateInfo.Window">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ApplicationInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ApplicationInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ApplicationInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ApplicationInfo.ApplicationName">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ApplicationInfo.ApplicationVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ApplicationInfo.EngineName">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ApplicationInfo.EngineVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ApplicationInfo.ApiVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.BindSparseInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BindSparseInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BindSparseInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BindSparseInfo.WaitSemaphoreCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BindSparseInfo.WaitSemaphores">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BindSparseInfo.BufferBindCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BindSparseInfo.BufferBinds">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BindSparseInfo.ImageOpaqueBindCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BindSparseInfo.ImageOpaqueBinds">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BindSparseInfo.ImageBindCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BindSparseInfo.ImageBinds">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BindSparseInfo.SignalSemaphoreCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BindSparseInfo.SignalSemaphores">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.BufferCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferCreateInfo.Size">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferCreateInfo.Usage">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferCreateInfo.SharingMode">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferCreateInfo.QueueFamilyIndexCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferCreateInfo.QueueFamilyIndices">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.BufferMemoryBarrier">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferMemoryBarrier.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferMemoryBarrier.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferMemoryBarrier.SourceAccessMask">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferMemoryBarrier.DestinationAccessMask">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferMemoryBarrier.SourceQueueFamilyIndex">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferMemoryBarrier.DestinationQueueFamilyIndex">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferMemoryBarrier.Buffer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferMemoryBarrier.Offset">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferMemoryBarrier.Size">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.BufferViewCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferViewCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferViewCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferViewCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferViewCreateInfo.Buffer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferViewCreateInfo.Format">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferViewCreateInfo.Offset">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferViewCreateInfo.Range">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.CommandBufferAllocateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferAllocateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferAllocateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferAllocateInfo.CommandPool">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferAllocateInfo.Level">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferAllocateInfo.CommandBufferCount">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.CommandBufferBeginInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferBeginInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferBeginInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferBeginInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferBeginInfo.InheritanceInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.CommandBufferInheritanceInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferInheritanceInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferInheritanceInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferInheritanceInfo.RenderPass">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferInheritanceInfo.Subpass">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferInheritanceInfo.Framebuffer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferInheritanceInfo.OcclusionQueryEnable">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferInheritanceInfo.QueryFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferInheritanceInfo.PipelineStatistics">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.CommandPoolCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandPoolCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandPoolCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandPoolCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandPoolCreateInfo.QueueFamilyIndex">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ComputePipelineCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ComputePipelineCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ComputePipelineCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ComputePipelineCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ComputePipelineCreateInfo.Stage">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ComputePipelineCreateInfo.Layout">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ComputePipelineCreateInfo.BasePipelineHandle">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ComputePipelineCreateInfo.BasePipelineIndex">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.CopyDescriptorSet">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CopyDescriptorSet.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CopyDescriptorSet.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CopyDescriptorSet.SourceSet">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CopyDescriptorSet.SourceBinding">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CopyDescriptorSet.SourceArrayElement">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CopyDescriptorSet.DestinationSet">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CopyDescriptorSet.DestinationBinding">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CopyDescriptorSet.DestinationArrayElement">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CopyDescriptorSet.DescriptorCount">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DebugMarkerMarkerInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerMarkerInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerMarkerInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerMarkerInfo.MarkerName">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerMarkerInfo.Color">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DebugMarkerObjectNameInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerObjectNameInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerObjectNameInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerObjectNameInfo.ObjectType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerObjectNameInfo.Object">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerObjectNameInfo.ObjectName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DebugMarkerObjectTagInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerObjectTagInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerObjectTagInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerObjectTagInfo.ObjectType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerObjectTagInfo.Object">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerObjectTagInfo.TagName">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerObjectTagInfo.TagSize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerObjectTagInfo.Tag">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DebugReportCallbackCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugReportCallbackCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugReportCallbackCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugReportCallbackCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugReportCallbackCreateInfo.PfnCallback">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugReportCallbackCreateInfo.UserData">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DedicatedAllocationBufferCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DedicatedAllocationBufferCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DedicatedAllocationBufferCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DedicatedAllocationBufferCreateInfo.DedicatedAllocation">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DedicatedAllocationImageCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DedicatedAllocationImageCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DedicatedAllocationImageCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DedicatedAllocationImageCreateInfo.DedicatedAllocation">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DedicatedAllocationMemoryAllocateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DedicatedAllocationMemoryAllocateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DedicatedAllocationMemoryAllocateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DedicatedAllocationMemoryAllocateInfo.Image">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DedicatedAllocationMemoryAllocateInfo.Buffer">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DescriptorBufferInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorBufferInfo.Buffer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorBufferInfo.Offset">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorBufferInfo.Range">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DescriptorImageInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorImageInfo.Sampler">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorImageInfo.ImageView">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorImageInfo.ImageLayout">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DescriptorPoolCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorPoolCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorPoolCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorPoolCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorPoolCreateInfo.MaxSets">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorPoolCreateInfo.PoolSizeCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorPoolCreateInfo.PoolSizes">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DescriptorSetAllocateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetAllocateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetAllocateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetAllocateInfo.DescriptorPool">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetAllocateInfo.DescriptorSetCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetAllocateInfo.SetLayouts">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DescriptorSetLayoutBinding">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetLayoutBinding.Binding">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetLayoutBinding.DescriptorType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetLayoutBinding.DescriptorCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetLayoutBinding.StageFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetLayoutBinding.ImmutableSamplers">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DescriptorSetLayoutCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetLayoutCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetLayoutCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetLayoutCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetLayoutCreateInfo.BindingCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetLayoutCreateInfo.Bindings">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DeviceCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceCreateInfo.QueueCreateInfoCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceCreateInfo.QueueCreateInfos">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceCreateInfo.EnabledLayerCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceCreateInfo.EnabledLayerNames">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceCreateInfo.EnabledExtensionCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceCreateInfo.EnabledExtensionNames">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceCreateInfo.EnabledFeatures">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DeviceQueueCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceQueueCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceQueueCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceQueueCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceQueueCreateInfo.QueueFamilyIndex">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceQueueCreateInfo.QueueCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceQueueCreateInfo.QueuePriorities">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DisplayModeCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayModeCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayModeCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayModeCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayModeCreateInfo.Parameters">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DisplayModeProperties">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayModeProperties.DisplayMode">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayModeProperties.Parameters">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DisplayPlaneProperties">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayPlaneProperties.CurrentDisplay">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayPlaneProperties.CurrentStackIndex">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DisplayPresentInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayPresentInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayPresentInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayPresentInfo.SourceRect">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayPresentInfo.DestinationRect">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayPresentInfo.Persistent">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DisplayProperties">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayProperties.Display">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayProperties.DisplayName">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayProperties.PhysicalDimensions">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayProperties.PhysicalResolution">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayProperties.SupportedTransforms">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayProperties.PlaneReorderPossible">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayProperties.PersistentContent">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DisplaySurfaceCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplaySurfaceCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplaySurfaceCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplaySurfaceCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplaySurfaceCreateInfo.DisplayMode">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplaySurfaceCreateInfo.PlaneIndex">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplaySurfaceCreateInfo.PlaneStackIndex">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplaySurfaceCreateInfo.Transform">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplaySurfaceCreateInfo.GlobalAlpha">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplaySurfaceCreateInfo.AlphaMode">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplaySurfaceCreateInfo.ImageExtent">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.EventCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.EventCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.EventCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.EventCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ExportMemoryAllocateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ExportMemoryAllocateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ExportMemoryAllocateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ExportMemoryAllocateInfo.HandleTypes">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ExportMemoryWin32HandleInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ExportMemoryWin32HandleInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ExportMemoryWin32HandleInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ExportMemoryWin32HandleInfo.Attributes">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ExportMemoryWin32HandleInfo.DwAccess">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ExtensionProperties">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ExtensionProperties.ExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ExtensionProperties.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ExternalMemoryImageCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ExternalMemoryImageCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ExternalMemoryImageCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ExternalMemoryImageCreateInfo.HandleTypes">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.FenceCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.FenceCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.FenceCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.FenceCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.FramebufferCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.FramebufferCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.FramebufferCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.FramebufferCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.FramebufferCreateInfo.RenderPass">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.FramebufferCreateInfo.AttachmentCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.FramebufferCreateInfo.Attachments">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.FramebufferCreateInfo.Width">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.FramebufferCreateInfo.Height">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.FramebufferCreateInfo.Layers">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.GraphicsPipelineCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.StageCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.Stages">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.VertexInputState">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.InputAssemblyState">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.TessellationState">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.ViewportState">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.RasterizationState">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.MultisampleState">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.DepthStencilState">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.ColorBlendState">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.DynamicState">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.Layout">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.RenderPass">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.Subpass">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.BasePipelineHandle">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.BasePipelineIndex">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ImageBlit">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageBlit.SourceSubresource">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageBlit.SourceOffsets">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageBlit.SourceOffsets_1">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageBlit.DestinationSubresource">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageBlit.DestinationOffsets">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageBlit.DestinationOffsets_1">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ImageCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.ImageType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.Format">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.Extent">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.MipLevels">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.ArrayLayers">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.Samples">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.Tiling">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.Usage">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.SharingMode">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.QueueFamilyIndexCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.QueueFamilyIndices">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.InitialLayout">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ImageMemoryBarrier">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageMemoryBarrier.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageMemoryBarrier.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageMemoryBarrier.SourceAccessMask">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageMemoryBarrier.DestinationAccessMask">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageMemoryBarrier.OldLayout">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageMemoryBarrier.NewLayout">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageMemoryBarrier.SourceQueueFamilyIndex">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageMemoryBarrier.DestinationQueueFamilyIndex">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageMemoryBarrier.Image">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageMemoryBarrier.SubresourceRange">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ImageViewCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageViewCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageViewCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageViewCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageViewCreateInfo.Image">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageViewCreateInfo.ViewType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageViewCreateInfo.Format">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageViewCreateInfo.Components">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageViewCreateInfo.SubresourceRange">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ImportMemoryWin32HandleInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImportMemoryWin32HandleInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImportMemoryWin32HandleInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImportMemoryWin32HandleInfo.HandleType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImportMemoryWin32HandleInfo.Handle">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.InstanceCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.InstanceCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.InstanceCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.InstanceCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.InstanceCreateInfo.ApplicationInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.InstanceCreateInfo.EnabledLayerCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.InstanceCreateInfo.EnabledLayerNames">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.InstanceCreateInfo.EnabledExtensionCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.InstanceCreateInfo.EnabledExtensionNames">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.LayerProperties">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.LayerProperties.LayerName">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.LayerProperties.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.LayerProperties.ImplementationVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.LayerProperties.Description">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.MappedMemoryRange">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MappedMemoryRange.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MappedMemoryRange.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MappedMemoryRange.Memory">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MappedMemoryRange.Offset">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MappedMemoryRange.Size">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.MemoryAllocateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MemoryAllocateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MemoryAllocateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MemoryAllocateInfo.AllocationSize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MemoryAllocateInfo.MemoryTypeIndex">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.MemoryBarrier">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MemoryBarrier.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MemoryBarrier.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MemoryBarrier.SourceAccessMask">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MemoryBarrier.DestinationAccessMask">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.MirSurfaceCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MirSurfaceCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MirSurfaceCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MirSurfaceCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MirSurfaceCreateInfo.Connection">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MirSurfaceCreateInfo.MirSurface">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PhysicalDeviceLimits">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxImageDimension1D">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxImageDimension2D">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxImageDimension3D">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxImageDimensionCube">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxImageArrayLayers">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxTexelBufferElements">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxUniformBufferRange">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxStorageBufferRange">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxPushConstantsSize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxMemoryAllocationCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxSamplerAllocationCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.BufferImageGranularity">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.SparseAddressSpaceSize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxBoundDescriptorSets">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxPerStageDescriptorSamplers">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxPerStageDescriptorUniformBuffers">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxPerStageDescriptorStorageBuffers">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxPerStageDescriptorSampledImages">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxPerStageDescriptorStorageImages">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxPerStageDescriptorInputAttachments">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxPerStageResources">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxDescriptorSetSamplers">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxDescriptorSetUniformBuffers">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxDescriptorSetUniformBuffersDynamic">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxDescriptorSetStorageBuffers">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxDescriptorSetStorageBuffersDynamic">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxDescriptorSetSampledImages">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxDescriptorSetStorageImages">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxDescriptorSetInputAttachments">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxVertexInputAttributes">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxVertexInputBindings">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxVertexInputAttributeOffset">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxVertexInputBindingStride">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxVertexOutputComponents">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxTessellationGenerationLevel">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxTessellationPatchSize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxTessellationControlPerVertexInputComponents">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxTessellationControlPerVertexOutputComponents">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxTessellationControlPerPatchOutputComponents">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxTessellationControlTotalOutputComponents">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxTessellationEvaluationInputComponents">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxTessellationEvaluationOutputComponents">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxGeometryShaderInvocations">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxGeometryInputComponents">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxGeometryOutputComponents">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxGeometryOutputVertices">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxGeometryTotalOutputComponents">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxFragmentInputComponents">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxFragmentOutputAttachments">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxFragmentDualSourceAttachments">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxFragmentCombinedOutputResources">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxComputeSharedMemorySize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxComputeWorkGroupCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxComputeWorkGroupInvocations">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxComputeWorkGroupSize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.SubPixelPrecisionBits">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.SubTexelPrecisionBits">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MipmapPrecisionBits">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxDrawIndexedIndexValue">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxDrawIndirectCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxSamplerLodBias">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxSamplerAnisotropy">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxViewports">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxViewportDimensions">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.ViewportBoundsRange">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.ViewportSubPixelBits">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MinMemoryMapAlignment">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MinTexelBufferOffsetAlignment">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MinUniformBufferOffsetAlignment">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MinStorageBufferOffsetAlignment">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MinTexelOffset">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxTexelOffset">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MinTexelGatherOffset">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxTexelGatherOffset">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MinInterpolationOffset">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxInterpolationOffset">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.SubPixelInterpolationOffsetBits">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxFramebufferWidth">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxFramebufferHeight">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxFramebufferLayers">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.FramebufferColorSampleCounts">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.FramebufferDepthSampleCounts">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.FramebufferStencilSampleCounts">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.FramebufferNoAttachmentsSampleCounts">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxColorAttachments">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.SampledImageColorSampleCounts">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.SampledImageIntegerSampleCounts">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.SampledImageDepthSampleCounts">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.SampledImageStencilSampleCounts">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.StorageImageSampleCounts">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxSampleMaskWords">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.TimestampComputeAndGraphics">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.TimestampPeriod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxClipDistances">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxCullDistances">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxCombinedClipAndCullDistances">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.DiscreteQueuePriorities">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.PointSizeRange">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.LineWidthRange">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.PointSizeGranularity">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.LineWidthGranularity">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.StrictLines">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.StandardSampleLocations">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.OptimalBufferCopyOffsetAlignment">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.OptimalBufferCopyRowPitchAlignment">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.NonCoherentAtomSize">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PhysicalDeviceMemoryProperties">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypeCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_1">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_2">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_3">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_4">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_5">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_6">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_7">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_8">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_9">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_10">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_11">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_12">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_13">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_14">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_15">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_16">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_17">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_18">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_19">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_20">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_21">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_22">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_23">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_24">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_25">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_26">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_27">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_28">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_29">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_30">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes_31">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryHeapCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryHeaps">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryHeaps_1">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryHeaps_2">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryHeaps_3">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryHeaps_4">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryHeaps_5">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryHeaps_6">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryHeaps_7">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryHeaps_8">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryHeaps_9">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryHeaps_10">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryHeaps_11">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryHeaps_12">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryHeaps_13">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryHeaps_14">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryHeaps_15">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PhysicalDeviceProperties">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceProperties.ApiVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceProperties.DriverVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceProperties.VendorID">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceProperties.DeviceID">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceProperties.DeviceType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceProperties.DeviceName">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceProperties.PipelineCacheUUID">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceProperties.Limits">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceProperties.SparseProperties">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineCacheCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineCacheCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineCacheCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineCacheCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineCacheCreateInfo.InitialDataSize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineCacheCreateInfo.InitialData">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineColorBlendStateCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineColorBlendStateCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineColorBlendStateCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineColorBlendStateCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineColorBlendStateCreateInfo.LogicOpEnable">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineColorBlendStateCreateInfo.LogicOp">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineColorBlendStateCreateInfo.AttachmentCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineColorBlendStateCreateInfo.Attachments">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineColorBlendStateCreateInfo.BlendConstants">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineDepthStencilStateCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDepthStencilStateCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDepthStencilStateCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDepthStencilStateCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDepthStencilStateCreateInfo.DepthTestEnable">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDepthStencilStateCreateInfo.DepthWriteEnable">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDepthStencilStateCreateInfo.DepthCompareOp">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDepthStencilStateCreateInfo.DepthBoundsTestEnable">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDepthStencilStateCreateInfo.StencilTestEnable">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDepthStencilStateCreateInfo.Front">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDepthStencilStateCreateInfo.Back">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDepthStencilStateCreateInfo.MinDepthBounds">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDepthStencilStateCreateInfo.MaxDepthBounds">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineDynamicStateCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDynamicStateCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDynamicStateCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDynamicStateCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDynamicStateCreateInfo.DynamicStateCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDynamicStateCreateInfo.DynamicStates">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineInputAssemblyStateCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineInputAssemblyStateCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineInputAssemblyStateCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineInputAssemblyStateCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineInputAssemblyStateCreateInfo.Topology">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineInputAssemblyStateCreateInfo.PrimitiveRestartEnable">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineLayoutCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineLayoutCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineLayoutCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineLayoutCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineLayoutCreateInfo.SetLayoutCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineLayoutCreateInfo.SetLayouts">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineLayoutCreateInfo.PushConstantRangeCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineLayoutCreateInfo.PushConstantRanges">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineMultisampleStateCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineMultisampleStateCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineMultisampleStateCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineMultisampleStateCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineMultisampleStateCreateInfo.RasterizationSamples">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineMultisampleStateCreateInfo.SampleShadingEnable">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineMultisampleStateCreateInfo.MinSampleShading">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineMultisampleStateCreateInfo.SampleMask">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineMultisampleStateCreateInfo.AlphaToCoverageEnable">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineMultisampleStateCreateInfo.AlphaToOneEnable">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineRasterizationStateCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateCreateInfo.DepthClampEnable">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateCreateInfo.RasterizerDiscardEnable">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateCreateInfo.PolygonMode">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateCreateInfo.CullMode">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateCreateInfo.FrontFace">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateCreateInfo.DepthBiasEnable">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateCreateInfo.DepthBiasConstantFactor">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateCreateInfo.DepthBiasClamp">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateCreateInfo.DepthBiasSlopeFactor">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateCreateInfo.LineWidth">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineRasterizationStateRasterizationOrder">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateRasterizationOrder.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateRasterizationOrder.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateRasterizationOrder.RasterizationOrder">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineShaderStageCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineShaderStageCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineShaderStageCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineShaderStageCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineShaderStageCreateInfo.Stage">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineShaderStageCreateInfo.Module">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineShaderStageCreateInfo.Name">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineShaderStageCreateInfo.SpecializationInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineTessellationStateCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineTessellationStateCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineTessellationStateCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineTessellationStateCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineTessellationStateCreateInfo.PatchControlPoints">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineVertexInputStateCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineVertexInputStateCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineVertexInputStateCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineVertexInputStateCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineVertexInputStateCreateInfo.VertexBindingDescriptionCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineVertexInputStateCreateInfo.VertexBindingDescriptions">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineVertexInputStateCreateInfo.VertexAttributeDescriptionCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineVertexInputStateCreateInfo.VertexAttributeDescriptions">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineViewportStateCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineViewportStateCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineViewportStateCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineViewportStateCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineViewportStateCreateInfo.ViewportCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineViewportStateCreateInfo.Viewports">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineViewportStateCreateInfo.ScissorCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineViewportStateCreateInfo.Scissors">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PresentInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PresentInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PresentInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PresentInfo.WaitSemaphoreCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PresentInfo.WaitSemaphores">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PresentInfo.SwapchainCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PresentInfo.Swapchains">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PresentInfo.ImageIndices">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PresentInfo.Results">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.QueryPoolCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.QueryPoolCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.QueryPoolCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.QueryPoolCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.QueryPoolCreateInfo.QueryType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.QueryPoolCreateInfo.QueryCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.QueryPoolCreateInfo.PipelineStatistics">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.RenderPassBeginInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassBeginInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassBeginInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassBeginInfo.RenderPass">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassBeginInfo.Framebuffer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassBeginInfo.RenderArea">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassBeginInfo.ClearValueCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassBeginInfo.ClearValues">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.RenderPassCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassCreateInfo.AttachmentCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassCreateInfo.Attachments">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassCreateInfo.SubpassCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassCreateInfo.Subpasses">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassCreateInfo.DependencyCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassCreateInfo.Dependencies">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.SamplerCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.MagFilter">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.MinFilter">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.MipmapMode">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.AddressModeU">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.AddressModeV">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.AddressModeW">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.MipLodBias">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.AnisotropyEnable">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.MaxAnisotropy">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.CompareEnable">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.CompareOp">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.MinLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.MaxLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.BorderColor">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.UnnormalizedCoordinates">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.SemaphoreCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SemaphoreCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SemaphoreCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SemaphoreCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ShaderModuleCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ShaderModuleCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ShaderModuleCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ShaderModuleCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ShaderModuleCreateInfo.CodeSize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ShaderModuleCreateInfo.Code">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.SparseBufferMemoryBindInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseBufferMemoryBindInfo.Buffer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseBufferMemoryBindInfo.BindCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseBufferMemoryBindInfo.Binds">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.SparseImageMemoryBind">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseImageMemoryBind.Subresource">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseImageMemoryBind.Offset">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseImageMemoryBind.Extent">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseImageMemoryBind.Memory">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseImageMemoryBind.MemoryOffset">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseImageMemoryBind.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.SparseImageMemoryBindInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseImageMemoryBindInfo.Image">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseImageMemoryBindInfo.BindCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseImageMemoryBindInfo.Binds">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.SparseImageOpaqueMemoryBindInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseImageOpaqueMemoryBindInfo.Image">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseImageOpaqueMemoryBindInfo.BindCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseImageOpaqueMemoryBindInfo.Binds">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.SparseMemoryBind">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseMemoryBind.ResourceOffset">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseMemoryBind.Size">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseMemoryBind.Memory">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseMemoryBind.MemoryOffset">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseMemoryBind.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.SpecializationInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SpecializationInfo.MapEntryCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SpecializationInfo.MapEntries">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SpecializationInfo.DataSize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SpecializationInfo.Data">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.SubmitInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubmitInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubmitInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubmitInfo.WaitSemaphoreCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubmitInfo.WaitSemaphores">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubmitInfo.WaitDestinationStageMask">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubmitInfo.CommandBufferCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubmitInfo.CommandBuffers">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubmitInfo.SignalSemaphoreCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubmitInfo.SignalSemaphores">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.SubpassDescription">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubpassDescription.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubpassDescription.PipelineBindPoint">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubpassDescription.InputAttachmentCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubpassDescription.InputAttachments">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubpassDescription.ColorAttachmentCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubpassDescription.ColorAttachments">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubpassDescription.ResolveAttachments">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubpassDescription.DepthStencilAttachment">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubpassDescription.PreserveAttachmentCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubpassDescription.PreserveAttachments">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.SwapchainCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.Surface">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.MinImageCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.ImageFormat">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.ImageColorSpace">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.ImageExtent">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.ImageArrayLayers">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.ImageUsage">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.ImageSharingMode">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.QueueFamilyIndexCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.QueueFamilyIndices">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.PreTransform">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.CompositeAlpha">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.PresentMode">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.Clipped">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.OldSwapchain">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ValidationFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ValidationFlags.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ValidationFlags.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ValidationFlags.DisabledValidationCheckCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ValidationFlags.DisabledValidationChecks">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.WaylandSurfaceCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WaylandSurfaceCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WaylandSurfaceCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WaylandSurfaceCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WaylandSurfaceCreateInfo.Display">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WaylandSurfaceCreateInfo.Surface">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Win32KeyedMutexAcquireReleaseInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Win32KeyedMutexAcquireReleaseInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Win32KeyedMutexAcquireReleaseInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Win32KeyedMutexAcquireReleaseInfo.AcquireCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Win32KeyedMutexAcquireReleaseInfo.AcquireSyncs">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Win32KeyedMutexAcquireReleaseInfo.AcquireKeys">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Win32KeyedMutexAcquireReleaseInfo.AcquireTimeoutMilliseconds">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Win32KeyedMutexAcquireReleaseInfo.ReleaseCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Win32KeyedMutexAcquireReleaseInfo.ReleaseSyncs">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Win32KeyedMutexAcquireReleaseInfo.ReleaseKeys">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Win32SurfaceCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Win32SurfaceCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Win32SurfaceCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Win32SurfaceCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Win32SurfaceCreateInfo.Hinstance">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Win32SurfaceCreateInfo.Hwnd">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.WriteDescriptorSet">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WriteDescriptorSet.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WriteDescriptorSet.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WriteDescriptorSet.DestinationSet">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WriteDescriptorSet.DestinationBinding">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WriteDescriptorSet.DestinationArrayElement">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WriteDescriptorSet.DescriptorCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WriteDescriptorSet.DescriptorType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WriteDescriptorSet.ImageInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WriteDescriptorSet.BufferInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WriteDescriptorSet.TexelBufferView">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.XcbSurfaceCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.XcbSurfaceCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.XcbSurfaceCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.XcbSurfaceCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.XcbSurfaceCreateInfo.Connection">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.XcbSurfaceCreateInfo.Window">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.XlibSurfaceCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.XlibSurfaceCreateInfo.SType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.XlibSurfaceCreateInfo.Next">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.XlibSurfaceCreateInfo.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.XlibSurfaceCreateInfo.Dpy">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Interop.XlibSurfaceCreateInfo.Window">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Commands">
            <summary>
            A container type for all interop methods to the Vulkan API commands.
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Commands.VulkanDll">
            <summary>
            The filename of the Vulkan DLL to which to bind interop calls.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateInstance(SharpVk.Interop.InstanceCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Instance*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyInstance(SharpVk.Interop.Instance,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkEnumeratePhysicalDevices(SharpVk.Interop.Instance,System.UInt32*,SharpVk.Interop.PhysicalDevice*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceFeatures(SharpVk.Interop.PhysicalDevice,SharpVk.PhysicalDeviceFeatures*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceFormatProperties(SharpVk.Interop.PhysicalDevice,SharpVk.Format,SharpVk.FormatProperties*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceImageFormatProperties(SharpVk.Interop.PhysicalDevice,SharpVk.Format,SharpVk.ImageType,SharpVk.ImageTiling,SharpVk.ImageUsageFlags,SharpVk.ImageCreateFlags,SharpVk.ImageFormatProperties*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceProperties(SharpVk.Interop.PhysicalDevice,SharpVk.Interop.PhysicalDeviceProperties*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceQueueFamilyProperties(SharpVk.Interop.PhysicalDevice,System.UInt32*,SharpVk.QueueFamilyProperties*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceMemoryProperties(SharpVk.Interop.PhysicalDevice,SharpVk.Interop.PhysicalDeviceMemoryProperties*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetInstanceProcAddr(SharpVk.Interop.Instance,System.Char*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetDeviceProcAddr(SharpVk.Interop.Device,System.Char*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateDevice(SharpVk.Interop.PhysicalDevice,SharpVk.Interop.DeviceCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Device*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyDevice(SharpVk.Interop.Device,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkEnumerateInstanceExtensionProperties(System.Char*,System.UInt32*,SharpVk.Interop.ExtensionProperties*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkEnumerateDeviceExtensionProperties(SharpVk.Interop.PhysicalDevice,System.Char*,System.UInt32*,SharpVk.Interop.ExtensionProperties*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkEnumerateInstanceLayerProperties(System.UInt32*,SharpVk.Interop.LayerProperties*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkEnumerateDeviceLayerProperties(SharpVk.Interop.PhysicalDevice,System.UInt32*,SharpVk.Interop.LayerProperties*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetDeviceQueue(SharpVk.Interop.Device,System.UInt32,System.UInt32,SharpVk.Interop.Queue*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkQueueSubmit(SharpVk.Interop.Queue,System.UInt32,SharpVk.Interop.SubmitInfo*,SharpVk.Interop.Fence)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkQueueWaitIdle(SharpVk.Interop.Queue)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDeviceWaitIdle(SharpVk.Interop.Device)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkAllocateMemory(SharpVk.Interop.Device,SharpVk.Interop.MemoryAllocateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.DeviceMemory*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkFreeMemory(SharpVk.Interop.Device,SharpVk.Interop.DeviceMemory,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkMapMemory(SharpVk.Interop.Device,SharpVk.Interop.DeviceMemory,SharpVk.DeviceSize,SharpVk.DeviceSize,SharpVk.MemoryMapFlags,System.Void**)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkUnmapMemory(SharpVk.Interop.Device,SharpVk.Interop.DeviceMemory)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkFlushMappedMemoryRanges(SharpVk.Interop.Device,System.UInt32,SharpVk.Interop.MappedMemoryRange*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkInvalidateMappedMemoryRanges(SharpVk.Interop.Device,System.UInt32,SharpVk.Interop.MappedMemoryRange*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetDeviceMemoryCommitment(SharpVk.Interop.Device,SharpVk.Interop.DeviceMemory,SharpVk.DeviceSize*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkBindBufferMemory(SharpVk.Interop.Device,SharpVk.Interop.Buffer,SharpVk.Interop.DeviceMemory,SharpVk.DeviceSize)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkBindImageMemory(SharpVk.Interop.Device,SharpVk.Interop.Image,SharpVk.Interop.DeviceMemory,SharpVk.DeviceSize)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetBufferMemoryRequirements(SharpVk.Interop.Device,SharpVk.Interop.Buffer,SharpVk.MemoryRequirements*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetImageMemoryRequirements(SharpVk.Interop.Device,SharpVk.Interop.Image,SharpVk.MemoryRequirements*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetImageSparseMemoryRequirements(SharpVk.Interop.Device,SharpVk.Interop.Image,System.UInt32*,SharpVk.SparseImageMemoryRequirements*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceSparseImageFormatProperties(SharpVk.Interop.PhysicalDevice,SharpVk.Format,SharpVk.ImageType,SharpVk.SampleCountFlags,SharpVk.ImageUsageFlags,SharpVk.ImageTiling,System.UInt32*,SharpVk.SparseImageFormatProperties*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkQueueBindSparse(SharpVk.Interop.Queue,System.UInt32,SharpVk.Interop.BindSparseInfo*,SharpVk.Interop.Fence)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateFence(SharpVk.Interop.Device,SharpVk.Interop.FenceCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Fence*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyFence(SharpVk.Interop.Device,SharpVk.Interop.Fence,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkResetFences(SharpVk.Interop.Device,System.UInt32,SharpVk.Interop.Fence*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetFenceStatus(SharpVk.Interop.Device,SharpVk.Interop.Fence)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkWaitForFences(SharpVk.Interop.Device,System.UInt32,SharpVk.Interop.Fence*,SharpVk.Bool32,System.UInt64)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateSemaphore(SharpVk.Interop.Device,SharpVk.Interop.SemaphoreCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Semaphore*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroySemaphore(SharpVk.Interop.Device,SharpVk.Interop.Semaphore,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateEvent(SharpVk.Interop.Device,SharpVk.Interop.EventCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Event*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyEvent(SharpVk.Interop.Device,SharpVk.Interop.Event,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetEventStatus(SharpVk.Interop.Device,SharpVk.Interop.Event)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkSetEvent(SharpVk.Interop.Device,SharpVk.Interop.Event)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkResetEvent(SharpVk.Interop.Device,SharpVk.Interop.Event)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateQueryPool(SharpVk.Interop.Device,SharpVk.Interop.QueryPoolCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.QueryPool*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyQueryPool(SharpVk.Interop.Device,SharpVk.Interop.QueryPool,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetQueryPoolResults(SharpVk.Interop.Device,SharpVk.Interop.QueryPool,System.UInt32,System.UInt32,SharpVk.Size,System.Void*,SharpVk.DeviceSize,SharpVk.QueryResultFlags)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateBuffer(SharpVk.Interop.Device,SharpVk.Interop.BufferCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Buffer*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyBuffer(SharpVk.Interop.Device,SharpVk.Interop.Buffer,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateBufferView(SharpVk.Interop.Device,SharpVk.Interop.BufferViewCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.BufferView*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyBufferView(SharpVk.Interop.Device,SharpVk.Interop.BufferView,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateImage(SharpVk.Interop.Device,SharpVk.Interop.ImageCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Image*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyImage(SharpVk.Interop.Device,SharpVk.Interop.Image,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetImageSubresourceLayout(SharpVk.Interop.Device,SharpVk.Interop.Image,SharpVk.ImageSubresource*,SharpVk.SubresourceLayout*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateImageView(SharpVk.Interop.Device,SharpVk.Interop.ImageViewCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.ImageView*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyImageView(SharpVk.Interop.Device,SharpVk.Interop.ImageView,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateShaderModule(SharpVk.Interop.Device,SharpVk.Interop.ShaderModuleCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.ShaderModule*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyShaderModule(SharpVk.Interop.Device,SharpVk.Interop.ShaderModule,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreatePipelineCache(SharpVk.Interop.Device,SharpVk.Interop.PipelineCacheCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.PipelineCache*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyPipelineCache(SharpVk.Interop.Device,SharpVk.Interop.PipelineCache,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPipelineCacheData(SharpVk.Interop.Device,SharpVk.Interop.PipelineCache,SharpVk.Size*,System.Void*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkMergePipelineCaches(SharpVk.Interop.Device,SharpVk.Interop.PipelineCache,System.UInt32,SharpVk.Interop.PipelineCache*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateGraphicsPipelines(SharpVk.Interop.Device,SharpVk.Interop.PipelineCache,System.UInt32,SharpVk.Interop.GraphicsPipelineCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Pipeline*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateComputePipelines(SharpVk.Interop.Device,SharpVk.Interop.PipelineCache,System.UInt32,SharpVk.Interop.ComputePipelineCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Pipeline*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyPipeline(SharpVk.Interop.Device,SharpVk.Interop.Pipeline,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreatePipelineLayout(SharpVk.Interop.Device,SharpVk.Interop.PipelineLayoutCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.PipelineLayout*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyPipelineLayout(SharpVk.Interop.Device,SharpVk.Interop.PipelineLayout,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateSampler(SharpVk.Interop.Device,SharpVk.Interop.SamplerCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Sampler*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroySampler(SharpVk.Interop.Device,SharpVk.Interop.Sampler,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateDescriptorSetLayout(SharpVk.Interop.Device,SharpVk.Interop.DescriptorSetLayoutCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.DescriptorSetLayout*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyDescriptorSetLayout(SharpVk.Interop.Device,SharpVk.Interop.DescriptorSetLayout,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateDescriptorPool(SharpVk.Interop.Device,SharpVk.Interop.DescriptorPoolCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.DescriptorPool*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyDescriptorPool(SharpVk.Interop.Device,SharpVk.Interop.DescriptorPool,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkResetDescriptorPool(SharpVk.Interop.Device,SharpVk.Interop.DescriptorPool,SharpVk.DescriptorPoolResetFlags)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkAllocateDescriptorSets(SharpVk.Interop.Device,SharpVk.Interop.DescriptorSetAllocateInfo*,SharpVk.Interop.DescriptorSet*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkFreeDescriptorSets(SharpVk.Interop.Device,SharpVk.Interop.DescriptorPool,System.UInt32,SharpVk.Interop.DescriptorSet*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkUpdateDescriptorSets(SharpVk.Interop.Device,System.UInt32,SharpVk.Interop.WriteDescriptorSet*,System.UInt32,SharpVk.Interop.CopyDescriptorSet*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateFramebuffer(SharpVk.Interop.Device,SharpVk.Interop.FramebufferCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Framebuffer*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyFramebuffer(SharpVk.Interop.Device,SharpVk.Interop.Framebuffer,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateRenderPass(SharpVk.Interop.Device,SharpVk.Interop.RenderPassCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.RenderPass*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyRenderPass(SharpVk.Interop.Device,SharpVk.Interop.RenderPass,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetRenderAreaGranularity(SharpVk.Interop.Device,SharpVk.Interop.RenderPass,SharpVk.Extent2D*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateCommandPool(SharpVk.Interop.Device,SharpVk.Interop.CommandPoolCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.CommandPool*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyCommandPool(SharpVk.Interop.Device,SharpVk.Interop.CommandPool,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkResetCommandPool(SharpVk.Interop.Device,SharpVk.Interop.CommandPool,SharpVk.CommandPoolResetFlags)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkAllocateCommandBuffers(SharpVk.Interop.Device,SharpVk.Interop.CommandBufferAllocateInfo*,SharpVk.Interop.CommandBuffer*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkFreeCommandBuffers(SharpVk.Interop.Device,SharpVk.Interop.CommandPool,System.UInt32,SharpVk.Interop.CommandBuffer*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkBeginCommandBuffer(SharpVk.Interop.CommandBuffer,SharpVk.Interop.CommandBufferBeginInfo*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkEndCommandBuffer(SharpVk.Interop.CommandBuffer)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkResetCommandBuffer(SharpVk.Interop.CommandBuffer,SharpVk.CommandBufferResetFlags)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdBindPipeline(SharpVk.Interop.CommandBuffer,SharpVk.PipelineBindPoint,SharpVk.Interop.Pipeline)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdSetViewport(SharpVk.Interop.CommandBuffer,System.UInt32,System.UInt32,SharpVk.Viewport*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdSetScissor(SharpVk.Interop.CommandBuffer,System.UInt32,System.UInt32,SharpVk.Rect2D*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdSetLineWidth(SharpVk.Interop.CommandBuffer,System.Single)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdSetDepthBias(SharpVk.Interop.CommandBuffer,System.Single,System.Single,System.Single)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdSetBlendConstants(SharpVk.Interop.CommandBuffer,System.Single)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdSetDepthBounds(SharpVk.Interop.CommandBuffer,System.Single,System.Single)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdSetStencilCompareMask(SharpVk.Interop.CommandBuffer,SharpVk.StencilFaceFlags,System.UInt32)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdSetStencilWriteMask(SharpVk.Interop.CommandBuffer,SharpVk.StencilFaceFlags,System.UInt32)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdSetStencilReference(SharpVk.Interop.CommandBuffer,SharpVk.StencilFaceFlags,System.UInt32)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdBindDescriptorSets(SharpVk.Interop.CommandBuffer,SharpVk.PipelineBindPoint,SharpVk.Interop.PipelineLayout,System.UInt32,System.UInt32,SharpVk.Interop.DescriptorSet*,System.UInt32,System.UInt32*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdBindIndexBuffer(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Buffer,SharpVk.DeviceSize,SharpVk.IndexType)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdBindVertexBuffers(SharpVk.Interop.CommandBuffer,System.UInt32,System.UInt32,SharpVk.Interop.Buffer*,SharpVk.DeviceSize*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdDraw(SharpVk.Interop.CommandBuffer,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdDrawIndexed(SharpVk.Interop.CommandBuffer,System.UInt32,System.UInt32,System.UInt32,System.Int32,System.UInt32)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdDrawIndirect(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Buffer,SharpVk.DeviceSize,System.UInt32,System.UInt32)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdDrawIndexedIndirect(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Buffer,SharpVk.DeviceSize,System.UInt32,System.UInt32)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdDispatch(SharpVk.Interop.CommandBuffer,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdDispatchIndirect(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Buffer,SharpVk.DeviceSize)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdCopyBuffer(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Buffer,SharpVk.Interop.Buffer,System.UInt32,SharpVk.BufferCopy*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdCopyImage(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Image,SharpVk.ImageLayout,SharpVk.Interop.Image,SharpVk.ImageLayout,System.UInt32,SharpVk.ImageCopy*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdBlitImage(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Image,SharpVk.ImageLayout,SharpVk.Interop.Image,SharpVk.ImageLayout,System.UInt32,SharpVk.Interop.ImageBlit*,SharpVk.Filter)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdCopyBufferToImage(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Buffer,SharpVk.Interop.Image,SharpVk.ImageLayout,System.UInt32,SharpVk.BufferImageCopy*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdCopyImageToBuffer(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Image,SharpVk.ImageLayout,SharpVk.Interop.Buffer,System.UInt32,SharpVk.BufferImageCopy*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdUpdateBuffer(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Buffer,SharpVk.DeviceSize,SharpVk.DeviceSize,System.Void*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdFillBuffer(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Buffer,SharpVk.DeviceSize,SharpVk.DeviceSize,System.UInt32)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdClearColorImage(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Image,SharpVk.ImageLayout,SharpVk.ClearColorValue*,System.UInt32,SharpVk.ImageSubresourceRange*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdClearDepthStencilImage(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Image,SharpVk.ImageLayout,SharpVk.ClearDepthStencilValue*,System.UInt32,SharpVk.ImageSubresourceRange*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdClearAttachments(SharpVk.Interop.CommandBuffer,System.UInt32,SharpVk.ClearAttachment*,System.UInt32,SharpVk.ClearRect*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdResolveImage(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Image,SharpVk.ImageLayout,SharpVk.Interop.Image,SharpVk.ImageLayout,System.UInt32,SharpVk.ImageResolve*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdSetEvent(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Event,SharpVk.PipelineStageFlags)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdResetEvent(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Event,SharpVk.PipelineStageFlags)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdWaitEvents(SharpVk.Interop.CommandBuffer,System.UInt32,SharpVk.Interop.Event*,SharpVk.PipelineStageFlags,SharpVk.PipelineStageFlags,System.UInt32,SharpVk.Interop.MemoryBarrier*,System.UInt32,SharpVk.Interop.BufferMemoryBarrier*,System.UInt32,SharpVk.Interop.ImageMemoryBarrier*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdPipelineBarrier(SharpVk.Interop.CommandBuffer,SharpVk.PipelineStageFlags,SharpVk.PipelineStageFlags,SharpVk.DependencyFlags,System.UInt32,SharpVk.Interop.MemoryBarrier*,System.UInt32,SharpVk.Interop.BufferMemoryBarrier*,System.UInt32,SharpVk.Interop.ImageMemoryBarrier*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdBeginQuery(SharpVk.Interop.CommandBuffer,SharpVk.Interop.QueryPool,System.UInt32,SharpVk.QueryControlFlags)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdEndQuery(SharpVk.Interop.CommandBuffer,SharpVk.Interop.QueryPool,System.UInt32)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdResetQueryPool(SharpVk.Interop.CommandBuffer,SharpVk.Interop.QueryPool,System.UInt32,System.UInt32)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdWriteTimestamp(SharpVk.Interop.CommandBuffer,SharpVk.PipelineStageFlags,SharpVk.Interop.QueryPool,System.UInt32)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdCopyQueryPoolResults(SharpVk.Interop.CommandBuffer,SharpVk.Interop.QueryPool,System.UInt32,System.UInt32,SharpVk.Interop.Buffer,SharpVk.DeviceSize,SharpVk.DeviceSize,SharpVk.QueryResultFlags)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdPushConstants(SharpVk.Interop.CommandBuffer,SharpVk.Interop.PipelineLayout,SharpVk.ShaderStageFlags,System.UInt32,System.UInt32,System.Void*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdBeginRenderPass(SharpVk.Interop.CommandBuffer,SharpVk.Interop.RenderPassBeginInfo*,SharpVk.SubpassContents)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdNextSubpass(SharpVk.Interop.CommandBuffer,SharpVk.SubpassContents)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdEndRenderPass(SharpVk.Interop.CommandBuffer)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdExecuteCommands(SharpVk.Interop.CommandBuffer,System.UInt32,SharpVk.Interop.CommandBuffer*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroySurfaceKHR(SharpVk.Interop.Instance,SharpVk.Interop.Surface,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceSurfaceSupportKHR(SharpVk.Interop.PhysicalDevice,System.UInt32,SharpVk.Interop.Surface,SharpVk.Bool32*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceSurfaceCapabilitiesKHR(SharpVk.Interop.PhysicalDevice,SharpVk.Interop.Surface,SharpVk.SurfaceCapabilities*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceSurfaceFormatsKHR(SharpVk.Interop.PhysicalDevice,SharpVk.Interop.Surface,System.UInt32*,SharpVk.SurfaceFormat*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceSurfacePresentModesKHR(SharpVk.Interop.PhysicalDevice,SharpVk.Interop.Surface,System.UInt32*,SharpVk.PresentMode*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateSwapchainKHR(SharpVk.Interop.Device,SharpVk.Interop.SwapchainCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Swapchain*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroySwapchainKHR(SharpVk.Interop.Device,SharpVk.Interop.Swapchain,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetSwapchainImagesKHR(SharpVk.Interop.Device,SharpVk.Interop.Swapchain,System.UInt32*,SharpVk.Interop.Image*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkAcquireNextImageKHR(SharpVk.Interop.Device,SharpVk.Interop.Swapchain,System.UInt64,SharpVk.Interop.Semaphore,SharpVk.Interop.Fence,System.UInt32*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkQueuePresentKHR(SharpVk.Interop.Queue,SharpVk.Interop.PresentInfo*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceDisplayPropertiesKHR(SharpVk.Interop.PhysicalDevice,System.UInt32*,SharpVk.Interop.DisplayProperties*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceDisplayPlanePropertiesKHR(SharpVk.Interop.PhysicalDevice,System.UInt32*,SharpVk.Interop.DisplayPlaneProperties*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetDisplayPlaneSupportedDisplaysKHR(SharpVk.Interop.PhysicalDevice,System.UInt32,System.UInt32*,SharpVk.Interop.Display*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetDisplayModePropertiesKHR(SharpVk.Interop.PhysicalDevice,SharpVk.Interop.Display,System.UInt32*,SharpVk.Interop.DisplayModeProperties*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateDisplayModeKHR(SharpVk.Interop.PhysicalDevice,SharpVk.Interop.Display,SharpVk.Interop.DisplayModeCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.DisplayMode*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetDisplayPlaneCapabilitiesKHR(SharpVk.Interop.PhysicalDevice,SharpVk.Interop.DisplayMode,System.UInt32,SharpVk.DisplayPlaneCapabilities*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateDisplayPlaneSurfaceKHR(SharpVk.Interop.Instance,SharpVk.Interop.DisplaySurfaceCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Surface*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateSharedSwapchainsKHR(SharpVk.Interop.Device,System.UInt32,SharpVk.Interop.SwapchainCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Swapchain*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateXlibSurfaceKHR(SharpVk.Interop.Instance,SharpVk.Interop.XlibSurfaceCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Surface*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceXlibPresentationSupportKHR(SharpVk.Interop.PhysicalDevice,System.UInt32,System.IntPtr*,System.IntPtr)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateXcbSurfaceKHR(SharpVk.Interop.Instance,SharpVk.Interop.XcbSurfaceCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Surface*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceXcbPresentationSupportKHR(SharpVk.Interop.PhysicalDevice,System.UInt32,System.IntPtr*,System.IntPtr)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateWaylandSurfaceKHR(SharpVk.Interop.Instance,SharpVk.Interop.WaylandSurfaceCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Surface*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceWaylandPresentationSupportKHR(SharpVk.Interop.PhysicalDevice,System.UInt32,System.IntPtr)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateMirSurfaceKHR(SharpVk.Interop.Instance,SharpVk.Interop.MirSurfaceCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Surface*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceMirPresentationSupportKHR(SharpVk.Interop.PhysicalDevice,System.UInt32,System.IntPtr*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateAndroidSurfaceKHR(SharpVk.Interop.Instance,SharpVk.Interop.AndroidSurfaceCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Surface*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateWin32SurfaceKHR(SharpVk.Interop.Instance,SharpVk.Interop.Win32SurfaceCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Surface*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceWin32PresentationSupportKHR(SharpVk.Interop.PhysicalDevice,System.UInt32)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateDebugReportCallbackEXT(SharpVk.Interop.Instance,SharpVk.Interop.DebugReportCallbackCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.DebugReportCallback*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyDebugReportCallbackEXT(SharpVk.Interop.Instance,SharpVk.Interop.DebugReportCallback,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDebugReportMessageEXT(SharpVk.Interop.Instance,SharpVk.DebugReportFlags,SharpVk.DebugReportObjectType,System.UInt64,SharpVk.Size,System.Int32,System.Char*,System.Char*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDebugMarkerSetObjectTagEXT(SharpVk.Interop.Device,SharpVk.Interop.DebugMarkerObjectTagInfo*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDebugMarkerSetObjectNameEXT(SharpVk.Interop.Device,SharpVk.Interop.DebugMarkerObjectNameInfo*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdDebugMarkerBeginEXT(SharpVk.Interop.CommandBuffer,SharpVk.Interop.DebugMarkerMarkerInfo*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdDebugMarkerEndEXT(SharpVk.Interop.CommandBuffer)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdDebugMarkerInsertEXT(SharpVk.Interop.CommandBuffer,SharpVk.Interop.DebugMarkerMarkerInfo*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdDrawIndirectCountAMD(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Buffer,SharpVk.DeviceSize,SharpVk.Interop.Buffer,SharpVk.DeviceSize,System.UInt32,System.UInt32)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdDrawIndexedIndirectCountAMD(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Buffer,SharpVk.DeviceSize,SharpVk.Interop.Buffer,SharpVk.DeviceSize,System.UInt32,System.UInt32)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceExternalImageFormatPropertiesNV(SharpVk.Interop.PhysicalDevice,SharpVk.Format,SharpVk.ImageType,SharpVk.ImageTiling,SharpVk.ImageUsageFlags,SharpVk.ImageCreateFlags,SharpVk.ExternalMemoryHandleTypeFlags,SharpVk.ExternalImageFormatProperties*)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetMemoryWin32HandleNV(SharpVk.Interop.Device,SharpVk.Interop.DeviceMemory,SharpVk.ExternalMemoryHandleTypeFlags,System.IntPtr*)">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.SharpVkException">
            <summary>
            The base type for exceptions thrown by the SharpVK library.
            </summary>
        </member>
        <member name="M:SharpVk.SharpVkException.#ctor(System.String)">
            <summary>
            Creates a new instance of the <see cref="T:SharpVk.SharpVkException"/> class .
            </summary>
            <param name="message">
            The message that describes the error.
            </param>
        </member>
        <member name="M:SharpVk.SharpVkException.IsError(SharpVk.Result)">
            <summary>
            Returns a value indicating whether the given Vulkan result code
            represents an error.
            </summary>
        </member>
        <member name="M:SharpVk.SharpVkException.Create(SharpVk.Result)">
            <summary>
            Creates and returns a new, specifically-typed exception that
            represents the given result code.
            </summary>
        </member>
        <member name="P:SharpVk.SharpVkException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.UnknownSharpVkException">
            <summary>
            An exception representing a result code not recognised by the SharpVk
            library.
            </summary>
        </member>
        <member name="P:SharpVk.UnknownSharpVkException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.OutOfHostMemoryException">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.OutOfHostMemoryException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.OutOfDeviceMemoryException">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.OutOfDeviceMemoryException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.InitializationFailedException">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.InitializationFailedException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.DeviceLostException">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.DeviceLostException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.MemoryMapFailedException">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.MemoryMapFailedException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.LayerNotPresentException">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.LayerNotPresentException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.ExtensionNotPresentException">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.ExtensionNotPresentException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.FeatureNotPresentException">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.FeatureNotPresentException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.IncompatibleDriverException">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.IncompatibleDriverException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.TooManyObjectsException">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.TooManyObjectsException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.FormatNotSupportedException">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.FormatNotSupportedException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.FragmentedPoolException">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.FragmentedPoolException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.SurfaceLostException">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.SurfaceLostException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.NativeWindowInUseException">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.NativeWindowInUseException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.OutOfDateException">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.OutOfDateException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.IncompatibleDisplayException">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.IncompatibleDisplayException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.ValidationFailedException">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.ValidationFailedException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.InvalidShaderException">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.InvalidShaderException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.KhrSurface">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.KhrSurface.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.KhrSurface.ExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.KhrSwapchain">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.KhrSwapchain.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.KhrSwapchain.ExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.KhrDisplay">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.KhrDisplay.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.KhrDisplay.ExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.KhrDisplaySwapchain">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.KhrDisplaySwapchain.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.KhrDisplaySwapchain.ExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.KhrXlibSurface">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.KhrXlibSurface.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.KhrXlibSurface.ExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.KhrXcbSurface">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.KhrXcbSurface.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.KhrXcbSurface.ExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.KhrWaylandSurface">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.KhrWaylandSurface.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.KhrWaylandSurface.ExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.KhrMirSurface">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.KhrMirSurface.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.KhrMirSurface.ExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.KhrAndroidSurface">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.KhrAndroidSurface.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.KhrAndroidSurface.ExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.KhrWin32Surface">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.KhrWin32Surface.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.KhrWin32Surface.ExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ExtDebugReport">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ExtDebugReport.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ExtDebugReport.ExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.NvGlslShader">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.NvGlslShader.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.NvGlslShader.ExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.KhrSamplerMirrorClampToEdge">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.KhrSamplerMirrorClampToEdge.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.KhrSamplerMirrorClampToEdge.ExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ImgFilterCubic">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ImgFilterCubic.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ImgFilterCubic.ExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.AmdRasterizationOrder">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.AmdRasterizationOrder.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.AmdRasterizationOrder.ExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.AmdShaderTrinaryMinmax">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.AmdShaderTrinaryMinmax.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.AmdShaderTrinaryMinmax.ExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.AmdShaderExplicitVertexParameter">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.AmdShaderExplicitVertexParameter.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.AmdShaderExplicitVertexParameter.ExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ExtDebugMarker">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ExtDebugMarker.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ExtDebugMarker.ExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.AmdGcnShader">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.AmdGcnShader.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.AmdGcnShader.ExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.NvDedicatedAllocation">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.NvDedicatedAllocation.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.NvDedicatedAllocation.ExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.AmdDrawIndirectCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.AmdDrawIndirectCount.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.AmdDrawIndirectCount.ExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.AmdNegativeViewportHeight">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.AmdNegativeViewportHeight.ExtensionNegativeViewportHeightSpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.AmdNegativeViewportHeight.ExtensionNegativeViewportHeightExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.AmdGpuShaderHalfFloat">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.AmdGpuShaderHalfFloat.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.AmdGpuShaderHalfFloat.ExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.AmdShaderBallot">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.AmdShaderBallot.ExtensionShaderBallotSpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.AmdShaderBallot.ExtensionShaderBallotExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ImgFormatPvrtc">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ImgFormatPvrtc.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ImgFormatPvrtc.ExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.NvExternalMemoryCapabilities">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.NvExternalMemoryCapabilities.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.NvExternalMemoryCapabilities.ExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.NvExternalMemory">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.NvExternalMemory.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.NvExternalMemory.ExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.NvExternalMemoryWin32">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.NvExternalMemoryWin32.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.NvExternalMemoryWin32.ExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.NvWin32KeyedMutex">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.NvWin32KeyedMutex.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.NvWin32KeyedMutex.ExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ExtValidationFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ExtValidationFlags.SpecVersion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ExtValidationFlags.ExtensionName">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Constants">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Constants.LodClampNone">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Constants.RemainingMipLevels">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Constants.RemainingArrayLayers">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Constants.WholeSize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Constants.AttachmentUnused">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Constants.True">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Constants.False">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Constants.QueueFamilyIgnored">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Constants.SubpassExternal">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Constants.MaxExtensionNameSize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Constants.MaxDescriptionSize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Constants.MaxMemoryTypes">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Constants.MaxMemoryHeaps">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Constants.MaxPhysicalDeviceNameSize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Constants.UuidSize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Constants.ApiVersion10">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Constants.SharpVkVersion">
            <summary>
            The version of the SharpVk bindings.
            </summary>
        </member>
        <member name="T:SharpVk.AccessFlags">
            <summary>
            <para>
            Bitmask specifying classes of memory access the will participate in a memory barrier dependency.
            </para>
            <para>
            Color attachment reads and writes are automatically (without memory or execution dependencies) coherent and ordered against themselves and each other for a given sample within a subpass of a render pass instance, executing in &lt;&lt;primrast-order,rasterization order&gt;&gt;. Similarly, depth/stencil attachment reads and writes are automatically coherent and ordered against themselves and each other in the same circumstances.
            </para>
            <para>
            Shader reads and/or writes through two variables (in the same or different shader invocations) decorated with code:Coherent and which use the same image view or buffer view are automatically coherent with each other, but require execution dependencies if a specific order is desired. Similarly, shader atomic operations are coherent with each other and with code:Coherent variables. Non-code:Coherent shader memory accesses require memory dependencies for writes to be available and reads to be visible.
            </para>
            <para>
            Certain memory access types are only supported on queues that support a particular set of operations. The following table lists, for each access flag, which queue capability flag must: be supported by the queue. When multiple flags are enumerated in the second column of the table it means that the access type is supported on the queue if it supports any of the listed capability flags. For further details on queue capabilities see &lt;&lt;devsandqueues-physical-device-enumeration,Physical Device Enumeration&gt;&gt; and &lt;&lt;devsandqueues-queues,Queues&gt;&gt;.
            </para>
            <para>
            .Supported access flags [width="100%",cols="67%,33%",options="header",align="center"] |==== |Access flag                                                  | Required queue capability flag |ename:VK_ACCESS_INDIRECT_COMMAND_READ_BIT                    | ename:VK_QUEUE_GRAPHICS_BIT or ename:VK_QUEUE_COMPUTE_BIT |ename:VK_ACCESS_INDEX_READ_BIT                               | ename:VK_QUEUE_GRAPHICS_BIT |ename:VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT                    | ename:VK_QUEUE_GRAPHICS_BIT |ename:VK_ACCESS_UNIFORM_READ_BIT                             | ename:VK_QUEUE_GRAPHICS_BIT or ename:VK_QUEUE_COMPUTE_BIT |ename:VK_ACCESS_INPUT_ATTACHMENT_READ_BIT                    | ename:VK_QUEUE_GRAPHICS_BIT |ename:VK_ACCESS_SHADER_READ_BIT                              | ename:VK_QUEUE_GRAPHICS_BIT or ename:VK_QUEUE_COMPUTE_BIT |ename:VK_ACCESS_SHADER_WRITE_BIT                             | ename:VK_QUEUE_GRAPHICS_BIT or ename:VK_QUEUE_COMPUTE_BIT |ename:VK_ACCESS_COLOR_ATTACHMENT_READ_BIT                    | ename:VK_QUEUE_GRAPHICS_BIT |ename:VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT                   | ename:VK_QUEUE_GRAPHICS_BIT |ename:VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT            | ename:VK_QUEUE_GRAPHICS_BIT |ename:VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT           | ename:VK_QUEUE_GRAPHICS_BIT |ename:VK_ACCESS_TRANSFER_READ_BIT                            | ename:VK_QUEUE_GRAPHICS_BIT, ename:VK_QUEUE_COMPUTE_BIT or ename:VK_QUEUE_TRANSFER_BIT |ename:VK_ACCESS_TRANSFER_WRITE_BIT                           | ename:VK_QUEUE_GRAPHICS_BIT, ename:VK_QUEUE_COMPUTE_BIT or ename:VK_QUEUE_TRANSFER_BIT |ename:VK_ACCESS_HOST_READ_BIT                                | None |ename:VK_ACCESS_HOST_WRITE_BIT                               | None |ename:VK_ACCESS_MEMORY_READ_BIT                              | None |ename:VK_ACCESS_MEMORY_WRITE_BIT                             | None |====
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.IndirectCommandRead">
            <summary>
            <para>
            ename:VK_ACCESS_INDIRECT_COMMAND_READ_BIT indicates that the access is an indirect command structure read as part of an indirect drawing command.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.IndexRead">
            <summary>
            <para>
            ename:VK_ACCESS_INDEX_READ_BIT indicates that the access is an index buffer read.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.VertexAttributeRead">
            <summary>
            <para>
            ename:VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT indicates that the access is a read via the vertex input bindings.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.UniformRead">
            <summary>
            <para>
            ename:VK_ACCESS_UNIFORM_READ_BIT indicates that the access is a read via a uniform buffer or dynamic uniform buffer descriptor.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.InputAttachmentRead">
            <summary>
            <para>
            ename:VK_ACCESS_INPUT_ATTACHMENT_READ_BIT indicates that the access is a read via an input attachment descriptor.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.ShaderRead">
            <summary>
            <para>
            ename:VK_ACCESS_SHADER_READ_BIT indicates that the access is a read from a shader via any other descriptor type.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.ShaderWrite">
            <summary>
            <para>
            ename:VK_ACCESS_SHADER_WRITE_BIT indicates that the access is a write or atomic from a shader via the same descriptor types as in ename:VK_ACCESS_SHADER_READ_BIT.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.ColorAttachmentRead">
            <summary>
            <para>
            ename:VK_ACCESS_COLOR_ATTACHMENT_READ_BIT indicates that the access is a read via a color attachment.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.ColorAttachmentWrite">
            <summary>
            <para>
            ename:VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT indicates that the access is a write via a color or resolve attachment.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.DepthStencilAttachmentRead">
            <summary>
            <para>
            ename:VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT indicates that the access is a read via a depth/stencil attachment.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.DepthStencilAttachmentWrite">
            <summary>
            <para>
            ename:VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT indicates that the access is a write via a depth/stencil attachment.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.TransferRead">
            <summary>
            <para>
            ename:VK_ACCESS_TRANSFER_READ_BIT indicates that the access is a read from a transfer (copy, blit, resolve, etc.) operation. For the complete set of transfer operations, see &lt;&lt;synchronization-transfer,ename:VK_PIPELINE_STAGE_TRANSFER_BIT&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.TransferWrite">
            <summary>
            <para>
            ename:VK_ACCESS_TRANSFER_WRITE_BIT indicates that the access is a write from a transfer (copy, blit, resolve, etc.) operation. For the complete set of transfer operations, see &lt;&lt;synchronization-transfer,ename:VK_PIPELINE_STAGE_TRANSFER_BIT&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.HostRead">
            <summary>
            <para>
            ename:VK_ACCESS_HOST_READ_BIT indicates that the access is a read via the host.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.HostWrite">
            <summary>
            <para>
            ename:VK_ACCESS_HOST_WRITE_BIT indicates that the access is a write via the host.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.MemoryRead">
            <summary>
            <para>
            ename:VK_ACCESS_MEMORY_READ_BIT indicates that the access is a read via a non-specific unit attached to the memory. This unit may: be external to the Vulkan device or otherwise not part of the core Vulkan pipeline. When included in pname:dstAccessMask, all writes using access types in pname:srcAccessMask performed by pipeline stages in pname:srcStageMask must: be visible in memory.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.MemoryWrite">
            <summary>
            <para>
            ename:VK_ACCESS_MEMORY_WRITE_BIT indicates that the access is a write via a non-specific unit attached to the memory. This unit may: be external to the Vulkan device or otherwise not part of the core Vulkan pipeline. When included in pname:srcAccessMask, all access types in pname:dstAccessMask from pipeline stages in pname:dstStageMask will observe the side effects of commands that executed before the barrier. When included in pname:dstAccessMask all writes using access types in pname:srcAccessMask performed by pipeline stages in pname:srcStageMask must: be visible in memory.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.AndroidSurfaceCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AndroidSurfaceCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.AttachmentDescriptionFlags">
            <summary>
            <para>
            Bitmask specifying additional properties of an attachment.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentDescriptionFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentDescriptionFlags.MayAlias">
            <summary>
            <para>
            The attachment may alias physical memory of another attachment in the same render pass
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.BufferCreateFlags">
            <summary>
            <para>
            Bitmask specifying additional parameters of a buffer.
            </para>
            <para>
            See &lt;&lt;sparsememory-sparseresourcefeatures,Sparse Resource Features&gt;&gt; and &lt;&lt;features-features,Physical Device Features&gt;&gt; for details of the sparse memory features supported on a device.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BufferCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BufferCreateFlags.SparseBinding">
            <summary>
            <para>
            ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT indicates that the buffer will be backed using sparse memory binding.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BufferCreateFlags.SparseResidency">
            <summary>
            <para>
            ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT indicates that the buffer can: be partially backed using sparse memory binding. Buffers created with this flag must: also be created with the ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT flag.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BufferCreateFlags.SparseAliased">
            <summary>
            <para>
            ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT indicates that the buffer will be backed using sparse memory binding with memory ranges that might also simultaneously be backing another buffer (or another portion of the same buffer). Buffers created with this flag must: also be created with the ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT flag.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.BufferUsageFlags">
            <summary>
            <para>
            Bitmask specifying allowed usage of a buffer.
            </para>
            <para>
            Any combination of bits can: be specified for pname:usage, but at least one of the bits must: be set in order to create a valid buffer.
            </para>
            <para>
            Bits which can: be set in pname:flags are:
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BufferUsageFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BufferUsageFlags.TransferSource">
            <summary>
            <para>
            ename:VK_BUFFER_USAGE_TRANSFER_SRC_BIT indicates that the buffer can: be used as the source of a _transfer command_ (see the definition of &lt;&lt;synchronization-transfer,ename:VK_PIPELINE_STAGE_TRANSFER_BIT&gt;&gt;).
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BufferUsageFlags.TransferDestination">
            <summary>
            <para>
            ename:VK_BUFFER_USAGE_TRANSFER_DST_BIT indicates that the buffer can: be used as the destination of a transfer command.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BufferUsageFlags.UniformTexelBuffer">
            <summary>
            <para>
            ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT indicates that the buffer can: be used to create a sname:VkBufferView suitable for occupying a sname:VkDescriptorSet slot of type ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BufferUsageFlags.StorageTexelBuffer">
            <summary>
            <para>
            ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT indicates that the buffer can: be used to create a sname:VkBufferView suitable for occupying a sname:VkDescriptorSet slot of type ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BufferUsageFlags.UniformBuffer">
            <summary>
            <para>
            ename:VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT indicates that the buffer can: be used in a sname:VkDescriptorBufferInfo suitable for occupying a sname:VkDescriptorSet slot either of type ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BufferUsageFlags.StorageBuffer">
            <summary>
            <para>
            ename:VK_BUFFER_USAGE_STORAGE_BUFFER_BIT indicates that the buffer can: be used in a sname:VkDescriptorBufferInfo suitable for occupying a sname:VkDescriptorSet slot either of type ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BufferUsageFlags.IndexBuffer">
            <summary>
            <para>
            ename:VK_BUFFER_USAGE_INDEX_BUFFER_BIT indicates that the buffer is suitable for passing as the pname:buffer parameter to fname:vkCmdBindIndexBuffer.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BufferUsageFlags.VertexBuffer">
            <summary>
            <para>
            ename:VK_BUFFER_USAGE_VERTEX_BUFFER_BIT indicates that the buffer is suitable for passing as an element of the pname:pBuffers array to fname:vkCmdBindVertexBuffers.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BufferUsageFlags.IndirectBuffer">
            <summary>
            <para>
            ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT indicates that the buffer is suitable for passing as the pname:buffer parameter to fname:vkCmdDrawIndirect, fname:vkCmdDrawIndexedIndirect, or fname:vkCmdDispatchIndirect.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.BufferViewCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BufferViewCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.ColorComponentFlags">
            <summary>
            <para>
            Bitmask controlling which components are written to the framebuffer.
            </para>
            <para>
            If ename:VK_COLOR_COMPONENT_R_BIT is set, then the latexmath:[$R$] value is written to color attachment for the appropriate sample, otherwise the value in memory is unmodified. The ename:VK_COLOR_COMPONENT_G_BIT, ename:VK_COLOR_COMPONENT_B_BIT, and ename:VK_COLOR_COMPONENT_A_BIT bits similarly control writing of the latexmath:[$G, B,$] and latexmath:[$A$] values. The pname:colorWriteMask is applied regardless of whether blending is enabled.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ColorComponentFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ColorComponentFlags.R">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ColorComponentFlags.G">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ColorComponentFlags.B">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ColorComponentFlags.A">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.CommandBufferResetFlags">
            <summary>
            <para>
            Bitmask controlling behavior of a command buffer reset.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CommandBufferResetFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CommandBufferResetFlags.ReleaseResources">
            <summary>
            <para>
            Release resources owned by the buffer
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.CommandBufferUsageFlags">
            <summary>
            <para>
            Bitmask specifying usage behavior for command buffer.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CommandBufferUsageFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CommandBufferUsageFlags.OneTimeSubmit">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CommandBufferUsageFlags.RenderPassContinue">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CommandBufferUsageFlags.SimultaneousUse">
            <summary>
            <para>
            Command buffer may be submitted/executed more than once simultaneously
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.CommandPoolCreateFlags">
            <summary>
            <para>
            Bitmask specifying usage behavior for a command pool.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CommandPoolCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CommandPoolCreateFlags.Transient">
            <summary>
            <para>
            Command buffers have a short lifetime
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CommandPoolCreateFlags.ResetCommandBuffer">
            <summary>
            <para>
            Command buffers may release their memory individually
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.CommandPoolResetFlags">
            <summary>
            <para>
            Bitmask controlling behavior of a command pool reset.
            </para>
            <para>
            Resetting a command pool recycles all of the resources from all of the command buffers allocated from the command pool back to the command pool. All command buffers that have been allocated from the command pool are put in the initial state.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CommandPoolResetFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CommandPoolResetFlags.ReleaseResources">
            <summary>
            <para>
            Release resources owned by the pool
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.CompositeAlphaFlags">
            <summary>
            <para>
            Alpha compositing modes supported on a device.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CompositeAlphaFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CompositeAlphaFlags.Opaque">
            <summary>
            <para>
            ename:VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR: The alpha channel, if it exists, of the images is ignored in the compositing process. Instead, the image is treated as if it has a constant alpha of 1.0.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CompositeAlphaFlags.PreMultiplied">
            <summary>
            <para>
            ename:VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR: The alpha channel, if it exists, of the images is respected in the compositing process. The non-alpha channels of the image are expected to already be multiplied by the alpha channel by the application.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CompositeAlphaFlags.PostMultiplied">
            <summary>
            <para>
            ename:VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR: The alpha channel, if it exists, of the images is respected in the compositing process. The non-alpha channels of the image are not expected to already be multiplied by the alpha channel by the application; instead, the compositor will multiply the non-alpha channels of the image by the alpha channel during compositing.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CompositeAlphaFlags.Inherit">
            <summary>
            <para>
            ename:VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR: The way in which the presentation engine treats the alpha channel in the images is unknown to the Vulkan API. Instead, the application is responsible for setting the composite alpha blending mode using native window system commands. If the application does not set the blending mode using native window system commands, then a platform-specific default will be used.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.CullModeFlags">
            <summary>
            <para>
            Bitmask controlling triangle culling.
            </para>
            <para>
            If the pname:cullMode is set to ename:VK_CULL_MODE_NONE no triangles are discarded, if it is set to ename:VK_CULL_MODE_FRONT_BIT front-facing triangles are discarded, if it is set to ename:VK_CULL_MODE_BACK_BIT then back-facing triangles are discarded and if it is set to ename:VK_CULL_MODE_FRONT_AND_BACK then all triangles are discarded. Following culling, fragments are produced for any triangles which have not been discarded.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CullModeFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CullModeFlags.Front">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CullModeFlags.Back">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CullModeFlags.FrontAndBack">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DebugReportFlags">
            <summary>
            <para>
            Bitmask specifying events which cause a debug report callback.
            </para>
            <para>
            * pname:pfnCallback is the application callback function to call. * pname:pUserData is user data to be passed to the callback. --
            </para>
            <para>
            For each sname:VkDebugReportCallbackEXT that is created the flags determine when that function is called. A callback will be made for issues that match any bit set in its flags. The callback will come directly from the component that detected the event, unless some other layer intercepts the calls for its own purposes (filter them in different way, log to system error log, etc.) An application may receive multiple callbacks if multiple sname:VkDebugReportCallbackEXT objects were created. A callback will always be executed in the same thread as the originating Vulkan call. A callback may be called from multiple threads simultaneously (if the application is making Vulkan calls from multiple threads).
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportFlags.Information">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_INFORMATION_BIT_EXT indicates an informational message such as resource details that may be handy when debugging an application.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportFlags.Warning">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_WARNING_BIT_EXT indicates an unexpected use. E.g. Not destroying objects prior to destroying the containing object or potential inconsistencies between descriptor set layout and the layout in the corresponding shader, etc.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportFlags.PerformanceWarning">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT indicates a potentially non-optimal use of Vulkan. E.g. using flink:vkCmdClearColorImage when a RenderPass load_op would have worked.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportFlags.Error">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_ERROR_BIT_EXT indicates an error that may cause undefined results, including an application crash.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportFlags.Debug">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_DEBUG_BIT_EXT indicates diagnostic information from the loader and layers.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DependencyFlags">
            <summary>
            <para>
            Bitmask specifying dependencies between subpasses.
            </para>
            <para>
            Each subpass dependency defines an execution and memory dependency between two sets of commands, with the second set depending on the first set. When pname:srcSubpass does not equal pname:dstSubpass then the first set of commands is:
            </para>
            <para>
            * All commands in the subpass indicated by pname:srcSubpass, if pname:srcSubpass is not ename:VK_SUBPASS_EXTERNAL. * All commands before the render pass instance, if pname:srcSubpass is ename:VK_SUBPASS_EXTERNAL.
            </para>
            <para>
            While the corresponding second set of commands is:
            </para>
            <para>
            * All commands in the subpass indicated by pname:dstSubpass, if pname:dstSubpass is not ename:VK_SUBPASS_EXTERNAL. * All commands after the render pass instance, if pname:dstSubpass is ename:VK_SUBPASS_EXTERNAL.
            </para>
            <para>
            When pname:srcSubpass equals pname:dstSubpass then the first set consists of commands in the subpass before a call to flink:vkCmdPipelineBarrier and the second set consists of commands in the subpass following that same call as described in the &lt;&lt;synchronization-pipeline-barriers-subpass-self-dependencies, Subpass Self-dependency&gt;&gt; section.
            </para>
            <para>
            The pname:srcStageMask, pname:dstStageMask, pname:srcAccessMask, pname:dstAccessMask, and pname:dependencyFlags parameters of the dependency are interpreted the same way as for other dependencies, as described in &lt;&lt;synchronization, Synchronization and Cache Control&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DependencyFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DependencyFlags.ByRegion">
            <summary>
            <para>
            Dependency is per pixel region 
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DescriptorPoolCreateFlags">
            <summary>
            <para>
            Bitmask specifying certain supported operations on a descriptor pool.
            </para>
            <para>
            If multiple sname:VkDescriptorPoolSize structures appear in the pname:pPoolSizes array then the pool will be created with enough storage for the total number of descriptors of each type.
            </para>
            <para>
            Fragmentation of a descriptor pool is possible and may: lead to descriptor set allocation failures. A failure due to fragmentation is defined as failing a descriptor set allocation despite the sum of all outstanding descriptor set allocations from the pool plus the requested allocation requiring no more than the total number of descriptors requested at pool creation. Implementations provide certain guarantees of when fragmentation must: not cause allocation failure, as described below.
            </para>
            <para>
            If a descriptor pool has not had any descriptor sets freed since it was created or most recently reset then fragmentation must: not cause an allocation failure (note that this is always the case for a pool created without the ename:VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT bit set). Additionally, if all sets allocated from the pool since it was created or most recently reset use the same number of descriptors (of each type) and the requested allocation also uses that same number of descriptors (of each type), then fragmentation must: not cause an allocation failure.
            </para>
            <para>
            If an allocation failure occurs due to fragmentation, an application can: create an additional descriptor pool to perform further descriptor set allocations.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorPoolCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorPoolCreateFlags.FreeDescriptorSet">
            <summary>
            <para>
            Descriptor sets may be freed individually
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DescriptorPoolResetFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorPoolResetFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DescriptorSetLayoutCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorSetLayoutCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DeviceCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DeviceCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DeviceQueueCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DeviceQueueCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DisplayModeCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DisplayModeCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DisplayPlaneAlphaFlags">
            <summary>
            <para>
            Alpha blending type.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPlaneAlphaFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPlaneAlphaFlags.Opaque">
            <summary>
            <para>
            ename:VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR: The source image will be treated as opaque.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPlaneAlphaFlags.Global">
            <summary>
            <para>
            ename:VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR: A global alpha value must: be specified that will be applied to all pixels in the source image.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPlaneAlphaFlags.PerPixel">
            <summary>
            <para>
            ename:VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR: The alpha value will be determined by the alpha channel of the source image's pixels. If the source format contains no alpha values, no blending will be applied. The source alpha values are not premultiplied into the source image's other color channels.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPlaneAlphaFlags.PerPixelPremultiplied">
            <summary>
            <para>
            ename:VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR: This is equivalent to ename:VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR except the source alpha values are assumed to be premultiplied into the source image's other color channels.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DisplaySurfaceCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DisplaySurfaceCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.EventCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.EventCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.ExternalMemoryFeatureFlags">
            <summary>
            <para>
            Bitmask specifying external memory features.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ExternalMemoryFeatureFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ExternalMemoryFeatureFlags.DedicatedOnly">
            <summary>
            <para>
            ename:VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV: External memory of the specified type must: be created as a dedicated allocation when used in the manner specified.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ExternalMemoryFeatureFlags.Exportable">
            <summary>
            <para>
            ename:VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV: The implementation supports exporting handles of the specified type.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ExternalMemoryFeatureFlags.Importable">
            <summary>
            <para>
            ename:VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV: The implementation supports importing handles of the specified type.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.ExternalMemoryHandleTypeFlags">
            <summary>
            <para>
            Bitmask specifying memory handle types.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ExternalMemoryHandleTypeFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ExternalMemoryHandleTypeFlags.OpaqueWin32">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ExternalMemoryHandleTypeFlags.OpaqueWin32Kmt">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ExternalMemoryHandleTypeFlags.D3D11Image">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ExternalMemoryHandleTypeFlags.D3D11ImageKmt">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.FenceCreateFlags">
            <summary>
            <para>
            Bitmask specifying initial state and behavior of a fence.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.FenceCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.FenceCreateFlags.Signaled">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.FormatFeatureFlags">
            <summary>
            <para>
            Bitmask specifying features supported by a buffer.
            </para>
            <para>
            The pname:linearTilingFeatures and pname:optimalTilingFeatures members of the sname:VkFormatProperties structure describe what features are supported by ename:VK_IMAGE_TILING_LINEAR and ename:VK_IMAGE_TILING_OPTIMAL images, respectively.
            </para>
            <para>
            The following bits may: be set in pname:linearTilingFeatures and pname:optimalTilingFeatures, indicating they are supported by images or image views created with the queried flink:vkGetPhysicalDeviceFormatProperties::pname:format:
            </para>
            <para>
            ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT:: sname:VkImageView can: be sampled from. See &lt;&lt;descriptorsets-sampledimage, sampled images&gt;&gt; section.
            </para>
            <para>
            ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT:: sname:VkImageView can: be used as storage image. See &lt;&lt;descriptorsets-storageimage, storage images&gt;&gt; section.
            </para>
            <para>
            ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT:: sname:VkImageView can: be used as storage image that supports atomic operations.
            </para>
            <para>
            ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT:: sname:VkImageView can: be used as a framebuffer color attachment and as an input attachment.
            </para>
            <para>
            ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT:: sname:VkImageView can: be used as a framebuffer color attachment that supports blending and as an input attachment.
            </para>
            <para>
            ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT:: sname:VkImageView can: be used as a framebuffer depth/stencil attachment and as an input attachment.
            </para>
            <para>
            ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT:: sname:VkImage can: be used as pname:srcImage for the fname:vkCmdBlitImage command.
            </para>
            <para>
            ename:VK_FORMAT_FEATURE_BLIT_DST_BIT:: sname:VkImage can: be used as pname:dstImage for the fname:vkCmdBlitImage command.
            </para>
            <para>
            ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT:: If ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT is also set, sname:VkImageView can: be used with a sampler that has either of pname:magFilter or pname:minFilter set to ename:VK_FILTER_LINEAR, or pname:mipmapMode set to ename:VK_SAMPLER_MIPMAP_MODE_LINEAR. If ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT is also set, sname:VkImage can be used as the pname:srcImage to flink:vkCmdBlitImage with a pname:filter of ename:VK_FILTER_LINEAR. This bit must: only be exposed for formats that also support the ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT or ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT. + If the format being queried is a depth/stencil format, this bit only indicates that the depth aspect (not the stencil aspect) of an image of this format supports linear filtering, and that linear filtering of the depth aspect is supported whether depth compare is enabled in the sampler or not. If this bit is not present, linear filtering with depth compare disabled is unsupported and linear filtering with depth compare enabled is supported, but may: compute the filtered value in an implementation-dependent manner which differs from the normal rules of linear filtering. The resulting value must: be in the range latexmath:[$[0,1\]$] and should: be proportional to, or a weighted average of, the number of comparison passes or failures.
            </para>
            <para>
            ifdef::VK_IMG_filter_cubic[] include::VK_IMG_filter_cubic/filter_cubic_sampled_bit_description.txt[] endif::VK_IMG_filter_cubic[]
            </para>
            <para>
            The following features may: appear in pname:bufferFeatures, indicating they are supported by buffers or buffer views created with the queried flink:vkGetPhysicalDeviceFormatProperties::pname:format:
            </para>
            <para>
            ename:VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT:: Format can: be used to create a sname:VkBufferView that can: be bound to a ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER descriptor.
            </para>
            <para>
            ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT:: Format can: be used to create a sname:VkBufferView that can: be bound to a ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER descriptor.
            </para>
            <para>
            ename:VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT:: Atomic operations are supported on ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER with this format.
            </para>
            <para>
            ename:VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT:: Format can: be used as a vertex attribute format (sname:VkVertexInputAttributeDescription::pname:format).
            </para>
            <para>
            [NOTE] .Note ==== If no format feature flags are supported, then the only possible use would be image transfers - which alone are not useful. As such, if no format feature flags are supported, the format itself is not supported, and images of that format cannot be created. ====
            </para>
            <para>
            If pname:format is a block-compression format, then buffers must: not support any features for the format.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.SampledImage">
            <summary>
            <para>
            Format can be used for sampled images (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.StorageImage">
            <summary>
            <para>
            Format can be used for storage images (STORAGE_IMAGE descriptor type)
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.StorageImageAtomic">
            <summary>
            <para>
            Format supports atomic operations in case it is used for storage images
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.UniformTexelBuffer">
            <summary>
            <para>
            Format can be used for uniform texel buffers (TBOs)
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.StorageTexelBuffer">
            <summary>
            <para>
            Format can be used for storage texel buffers (IBOs)
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.StorageTexelBufferAtomic">
            <summary>
            <para>
            Format supports atomic operations in case it is used for storage texel buffers
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.VertexBuffer">
            <summary>
            <para>
            Format can be used for vertex buffers (VBOs)
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.ColorAttachment">
            <summary>
            <para>
            Format can be used for color attachment images
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.ColorAttachmentBlend">
            <summary>
            <para>
            Format supports blending in case it is used for color attachment images
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.DepthStencilAttachment">
            <summary>
            <para>
            Format can be used for depth/stencil attachment images
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.BlitSource">
            <summary>
            <para>
            Format can be used as the source image of blits with vkCmdBlitImage
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.BlitDestination">
            <summary>
            <para>
            Format can be used as the destination image of blits with vkCmdBlitImage
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.SampledImageFilterLinear">
            <summary>
            <para>
            Format can be filtered with VK_FILTER_LINEAR when being sampled
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.SampledImageFilterCubicBitImg">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.FramebufferCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.FramebufferCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.ImageAspectFlags">
            <summary>
            <para>
            Bitmask specifying which aspects of an image are included in a view.
            </para>
            <para>
            The mask must: be only ename:VK_IMAGE_ASPECT_COLOR_BIT, ename:VK_IMAGE_ASPECT_DEPTH_BIT or ename:VK_IMAGE_ASPECT_STENCIL_BIT if pname:format is a color, depth-only or stencil-only format, respectively. If using a depth/stencil format with both depth and stencil components, pname:aspectMask must: include at least one of ename:VK_IMAGE_ASPECT_DEPTH_BIT and ename:VK_IMAGE_ASPECT_STENCIL_BIT, and can: include both.
            </para>
            <para>
            When using an imageView of a depth/stencil image to populate a descriptor set (e.g. for sampling in the shader, or for use as an input attachment), the pname:aspectMask must: only include one bit and selects whether the imageView is used for depth reads (i.e. using a floating-point sampler or input attachment in the shader) or stencil reads (i.e. using an unsigned integer sampler or input attachment in the shader). When an imageView of a depth/stencil image is used as a depth/stencil framebuffer attachment, the pname:aspectMask is ignored and both depth and stencil image subresources are used.
            </para>
            <para>
            The pname:components member is of type slink:VkComponentMapping, and describes a remapping from components of the image to components of the vector returned by shader image instructions. This remapping must: be identity for storage image descriptors, input attachment descriptors, and framebuffer attachments.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageAspectFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageAspectFlags.Color">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageAspectFlags.Depth">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageAspectFlags.Stencil">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageAspectFlags.Metadata">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.ImageCreateFlags">
            <summary>
            <para>
            Bitmask specifying additional parameters of an image.
            </para>
            <para>
            If any of the bits ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT, ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, or ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT are set, ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT must: not also be set.
            </para>
            <para>
            See &lt;&lt;sparsememory-sparseresourcefeatures,Sparse Resource Features&gt;&gt; and &lt;&lt;sparsememory-physicalfeatures,Sparse Physical Device Features&gt;&gt; for more details.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageCreateFlags.SparseBinding">
            <summary>
            <para>
            ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT indicates that the image will be backed using sparse memory binding.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageCreateFlags.SparseResidency">
            <summary>
            <para>
            ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT indicates that the image can: be partially backed using sparse memory binding. Images created with this flag must: also be created with the ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT flag.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageCreateFlags.SparseAliased">
            <summary>
            <para>
            ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT indicates that the image will be backed using sparse memory binding with memory ranges that might also simultaneously be backing another image (or another portion of the same image). Images created with this flag must: also be created with the ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT flag
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageCreateFlags.MutableFormat">
            <summary>
            <para>
            ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT indicates that the image can: be used to create a sname:VkImageView with a different format from the image.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageCreateFlags.CubeCompatible">
            <summary>
            <para>
            ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT indicates that the image can: be used to create a sname:VkImageView of type ename:VK_IMAGE_VIEW_TYPE_CUBE or ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.ImageUsageFlags">
            <summary>
            <para>
            Bitmask specifying intended usage of an image.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageUsageFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageUsageFlags.TransferSource">
            <summary>
            <para>
            ename:VK_IMAGE_USAGE_TRANSFER_SRC_BIT indicates that the image can: be used as the source of a transfer command.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageUsageFlags.TransferDestination">
            <summary>
            <para>
            ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT indicates that the image can: be used as the destination of a transfer command.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageUsageFlags.Sampled">
            <summary>
            <para>
            ename:VK_IMAGE_USAGE_SAMPLED_BIT indicates that the image can: be used to create a sname:VkImageView suitable for occupying a sname:VkDescriptorSet slot either of type ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE or ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and be sampled by a shader.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageUsageFlags.Storage">
            <summary>
            <para>
            ename:VK_IMAGE_USAGE_STORAGE_BIT indicates that the image can: be used to create a sname:VkImageView suitable for occupying a sname:VkDescriptorSet slot of type ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageUsageFlags.ColorAttachment">
            <summary>
            <para>
            ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT indicates that the image can: be used to create a sname:VkImageView suitable for use as a color or resolve attachment in a sname:VkFramebuffer.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageUsageFlags.DepthStencilAttachment">
            <summary>
            <para>
            ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT indicates that the image can: be used to create a sname:VkImageView suitable for use as a depth/stencil attachment in a sname:VkFramebuffer.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageUsageFlags.TransientAttachment">
            <summary>
            <para>
            ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT indicates that the memory bound to this image will have been allocated with the ename:VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT (see &lt;&lt;memory&gt;&gt; for more detail). This bit can: be set for any image that can: be used to create a sname:VkImageView suitable for use as a color, resolve, depth/stencil, or input attachment.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageUsageFlags.InputAttachment">
            <summary>
            <para>
            ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT indicates that the image can: be used to create a sname:VkImageView suitable for occupying sname:VkDescriptorSet slot of type ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT; be read from a shader as an input attachment; and be used as an input attachment in a framebuffer.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.ImageViewCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageViewCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.InstanceCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.InstanceCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.MemoryHeapFlags">
            <summary>
            <para>
            Bitmask specifying attribute flags for a heap.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.MemoryHeapFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.MemoryHeapFlags.DeviceLocal">
            <summary>
            <para>
            If set, heap represents device memory
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.MemoryMapFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.MemoryMapFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.MemoryPropertyFlags">
            <summary>
            <para>
            Bitmask specifying properties for a memory type.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.MemoryPropertyFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.MemoryPropertyFlags.DeviceLocal">
            <summary>
            <para>
            If otherwise stated, then allocate memory on device
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.MemoryPropertyFlags.HostVisible">
            <summary>
            <para>
            Memory is mappable by host
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.MemoryPropertyFlags.HostCoherent">
            <summary>
            <para>
            Memory will have i/o coherency. If not set, application may need to use vkFlushMappedMemoryRanges and vkInvalidateMappedMemoryRanges to flush/invalidate host cache
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.MemoryPropertyFlags.HostCached">
            <summary>
            <para>
            Memory will be cached by the host
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.MemoryPropertyFlags.LazilyAllocated">
            <summary>
            <para>
            Memory may be allocated by the driver when it is required
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.MirSurfaceCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.MirSurfaceCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PipelineCacheCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineCacheCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PipelineColorBlendStateCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineColorBlendStateCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PipelineCreateFlags">
            <summary>
            <para>
            Bitmask controlling how a pipeline is generated.
            </para>
            <para>
            It is valid to set both ename:VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT and ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT. This allows a pipeline to be both a parent and possibly a child in a pipeline hierarchy. See &lt;&lt;pipelines-pipeline-derivatives,Pipeline Derivatives&gt;&gt; for more information.
            </para>
            <para>
            pname:pDynamicState points to a structure of type sname:VkPipelineDynamicStateCreateInfo.
            </para>
            <para>
            ifdef::VK_NV_glsl_shader[] If any shader stage fails to compile, ifdef::VK_EXT_debug_report[] the compile log will be reported back to the application, and endif::VK_EXT_debug_report[] ename:VK_ERROR_INVALID_SHADER_NV will be generated. endif::VK_NV_glsl_shader[]
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineCreateFlags.DisableOptimization">
            <summary>
            <para>
            ename:VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT specifies that the created pipeline will not be optimized. Using this flag may: reduce the time taken to create the pipeline.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineCreateFlags.AllowDerivatives">
            <summary>
            <para>
            ename:VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT specifies that the pipeline to be created is allowed to be the parent of a pipeline that will be created in a subsequent call to flink:vkCreateGraphicsPipelines.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineCreateFlags.Derivative">
            <summary>
            <para>
            ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT specifies that the pipeline to be created will be a child of a previously created parent pipeline.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PipelineDepthStencilStateCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineDepthStencilStateCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PipelineDynamicStateCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineDynamicStateCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PipelineInputAssemblyStateCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineInputAssemblyStateCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PipelineLayoutCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineLayoutCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PipelineMultisampleStateCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineMultisampleStateCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PipelineRasterizationStateCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineRasterizationStateCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PipelineShaderStageCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineShaderStageCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PipelineStageFlags">
            <summary>
            <para>
            Bitmask specifying pipeline stages.
            </para>
            <para>
            [NOTE] .Note ==== The ename:VK_PIPELINE_STAGE_ALL_COMMANDS_BIT and ename:VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT differ from ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT in that they correspond to all (or all graphics) stages, rather than to a specific stage at the end of the pipeline. An execution dependency with only ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT in pname:dstStageMask will not delay subsequent commands, while including either of the other two bits will. Similarly, when defining a memory dependency, if the stage mask(s) refer to all stages, then the indicated access types from all stages will be made available and/or visible, but using only ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT would not make any accesses available and/or visible because this stage does not access memory. The ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT is useful for accomplishing memory barriers and layout transitions when the next accesses will be done in a different queue or by a presentation engine; in these cases subsequent commands in the same queue do not need to wait, but the barrier or transition must: complete before semaphores associated with the batch signal. ====
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.TopOfPipe">
            <summary>
            <para>
            ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT: Stage of the pipeline where commands are initially received by the queue.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.DrawIndirect">
            <summary>
            <para>
            ename:VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT: Stage of the pipeline where Draw/DispatchIndirect data structures are consumed.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.VertexInput">
            <summary>
            <para>
            ename:VK_PIPELINE_STAGE_VERTEX_INPUT_BIT: Stage of the pipeline where vertex and index buffers are consumed.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.VertexShader">
            <summary>
            <para>
            ename:VK_PIPELINE_STAGE_VERTEX_SHADER_BIT: Vertex shader stage.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.TessellationControlShader">
            <summary>
            <para>
            ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT: Tessellation control shader stage.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.TessellationEvaluationShader">
            <summary>
            <para>
            ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT: Tessellation evaluation shader stage.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.GeometryShader">
            <summary>
            <para>
            ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT: Geometry shader stage.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.FragmentShader">
            <summary>
            <para>
            ename:VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT: Fragment shader stage.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.EarlyFragmentTests">
            <summary>
            <para>
            ename:VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT: Stage of the pipeline where early fragment tests (depth and stencil tests before fragment shading) are performed.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.LateFragmentTests">
            <summary>
            <para>
            ename:VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT: Stage of the pipeline where late fragment tests (depth and stencil tests after fragment shading) are performed.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.ColorAttachmentOutput">
            <summary>
            <para>
            ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT: Stage of the pipeline after blending where the final color values are output from the pipeline. This stage also includes resolve operations that occur at the end of a subpass. Note that this does not necessarily indicate that the values have been committed to memory.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.ComputeShader">
            <summary>
            <para>
            ename:VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT: Execution of a compute shader.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.Transfer">
            <summary>
            <para>
            ename:VK_PIPELINE_STAGE_TRANSFER_BIT: Execution of copy commands. This includes the operations resulting from all transfer commands. The set of transfer commands comprises fname:vkCmdCopyBuffer, fname:vkCmdCopyImage, fname:vkCmdBlitImage, fname:vkCmdCopyBufferToImage, fname:vkCmdCopyImageToBuffer, fname:vkCmdUpdateBuffer, fname:vkCmdFillBuffer, fname:vkCmdClearColorImage, fname:vkCmdClearDepthStencilImage, fname:vkCmdResolveImage, and fname:vkCmdCopyQueryPoolResults.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.BottomOfPipe">
            <summary>
            <para>
            ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT: Final stage in the pipeline where commands complete execution.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.Host">
            <summary>
            <para>
            ename:VK_PIPELINE_STAGE_HOST_BIT: A pseudo-stage indicating execution on the host of reads/writes of device memory.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.AllGraphics">
            <summary>
            <para>
            ename:VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT: Execution of all graphics pipeline stages.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.AllCommands">
            <summary>
            <para>
            ename:VK_PIPELINE_STAGE_ALL_COMMANDS_BIT: Execution of all stages supported on the queue.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PipelineTessellationStateCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineTessellationStateCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PipelineVertexInputStateCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineVertexInputStateCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PipelineViewportStateCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineViewportStateCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.QueryControlFlags">
            <summary>
            <para>
            Bitmask specifying constraints on a query.
            </para>
            <para>
            If the pname:queryType of the pool is ename:VK_QUERY_TYPE_OCCLUSION and pname:flags contains ename:VK_QUERY_CONTROL_PRECISE_BIT, an implementation must: return a result that matches the actual number of samples passed. This is described in more detail in &lt;&lt;queries-occlusion,Occlusion Queries&gt;&gt;.
            </para>
            <para>
            After beginning a query, that query is considered _active_ within the command buffer it was called in until that same query is ended. Queries active in a primary command buffer when secondary command buffers are executed are considered active for those secondary command buffers.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueryControlFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueryControlFlags.Precise">
            <summary>
            <para>
            Require precise results to be collected by the query
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.QueryPipelineStatisticFlags">
            <summary>
            <para>
            Bitmask specifying queried pipeline statistics.
            </para>
            <para>
            These bits have the following meanings:
            </para>
            <para>
            * If ename:VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT is set, queries managed by the pool will count the number of vertices processed by the &lt;&lt;drawing,input assembly&gt;&gt; stage. Vertices corresponding to incomplete primitives may: contribute to the count. * If ename:VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT is set, queries managed by the pool will count the number of primitives processed by the &lt;&lt;drawing,input assembly&gt;&gt; stage. If primitive restart is enabled, restarting the primitive topology has no effect on the count. Incomplete primitives may: be counted. * If ename:VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT is set, queries managed by the pool will count the number of vertex shader invocations. This counter's value is incremented each time a vertex shader is &lt;&lt;shaders-vertex-execution,invoked&gt;&gt;. * If ename:VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT is set, queries managed by the pool will count the number of geometry shader invocations. This counter's value is incremented each time a geometry shader is &lt;&lt;shaders-geometry-execution,invoked&gt;&gt;. In the case of &lt;&lt;geometry-invocations,instanced geometry shaders&gt;&gt;, the geometry shader invocations count is incremented for each separate instanced invocation. * If ename:VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT is set, queries managed by the pool will count the number of primitives generated by geometry shader invocations. The counter's value is incremented each time the geometry shader emits a primitive. Restarting primitive topology using the SPIR-V instructions code:OpEndPrimitive or code:OpEndStreamPrimitive has no effect on the geometry shader output primitives count. * If ename:VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT is set, queries managed by the pool will count the number of primitives processed by the &lt;&lt;vertexpostproc-clipping,Primitive Clipping&gt;&gt; stage of the pipeline. The counter's value is incremented each time a primitive reaches the primitive clipping stage. * If ename:VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT is set, queries managed by the pool will count the number of primitives output by the &lt;&lt;vertexpostproc-clipping,Primitive Clipping&gt;&gt; stage of the pipeline. The counter's value is incremented each time a primitive passes the primitive clipping stage. The actual number of primitives output by the primitive clipping stage for a particular input primitive is implementation-dependent but must: satisfy the following conditions: ** If at least one vertex of the input primitive lies inside the clipping volume, the counter is incremented by one or more. ** Otherwise, the counter is incremented by zero or more. * If ename:VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT is set, queries managed by the pool will count the number of fragment shader invocations. The counter's value is incremented each time the fragment shader is &lt;&lt;shaders-fragment-execution,invoked&gt;&gt;. * If ename:VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT is set, queries managed by the pool will count the number of patches processed by the tessellation control shader. The counter's value is incremented once for each patch for which a tessellation control shader is &lt;&lt;shaders-tessellation-control-execution,invoked&gt;&gt;. * If ename:VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT is set, queries managed by the pool will count the number of invocations of the tessellation evaluation shader. The counter's value is incremented each time the tessellation evaluation shader is &lt;&lt;shaders-tessellation-evaluation-execution,invoked&gt;&gt;. * If ename:VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT is set, queries managed by the pool will count the number of compute shader invocations. The counter's value is incremented every time the compute shader is invoked. Implementations may: skip the execution of certain compute shader invocations or execute additional compute shader invocations for implementation-dependent reasons as long as the results of rendering otherwise remain unchanged.
            </para>
            <para>
            These values are intended to measure relative statistics on one implementation. Various device architectures will count these values differently. Any or all counters may: be affected by the issues described in &lt;&lt;queries-operation-undefined,Query Operation&gt;&gt;.
            </para>
            <para>
            [NOTE] .Note ==== For example, tile-based rendering devices may: need to replay the scene multiple times, affecting some of the counts. ====
            </para>
            <para>
            If a pipeline has pname:rasterizerDiscardEnable enabled, implementations may: discard primitives after the final vertex processing stage. As a result, if pname:rasterizerDiscardEnable is enabled, the clipping input and output primitives counters may: not be incremented.
            </para>
            <para>
            When a pipeline statistics query finishes, the result for that query is marked as available. The application can: copy the result to a buffer (via fname:vkCmdCopyQueryPoolResults), or request it be put into host memory (via fname:vkGetQueryPoolResults).
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueryPipelineStatisticFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueryPipelineStatisticFlags.InputAssemblyVertices">
            <summary>
            <para>
            Optional
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueryPipelineStatisticFlags.InputAssemblyPrimitives">
            <summary>
            <para>
            Optional
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueryPipelineStatisticFlags.VertexShaderInvocations">
            <summary>
            <para>
            Optional
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueryPipelineStatisticFlags.GeometryShaderInvocations">
            <summary>
            <para>
            Optional
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueryPipelineStatisticFlags.GeometryShaderPrimitives">
            <summary>
            <para>
            Optional
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueryPipelineStatisticFlags.ClippingInvocations">
            <summary>
            <para>
            Optional
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueryPipelineStatisticFlags.ClippingPrimitives">
            <summary>
            <para>
            Optional
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueryPipelineStatisticFlags.FragmentShaderInvocations">
            <summary>
            <para>
            Optional
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueryPipelineStatisticFlags.TessellationControlShaderPatches">
            <summary>
            <para>
            Optional
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueryPipelineStatisticFlags.TessellationEvaluationShaderInvocations">
            <summary>
            <para>
            Optional
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueryPipelineStatisticFlags.ComputeShaderInvocations">
            <summary>
            <para>
            Optional
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.QueryPoolCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueryPoolCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.QueryResultFlags">
            <summary>
            <para>
            Bitmask specifying how and when query results are returned.
            </para>
            <para>
            If no bits are set in pname:flags, and all requested queries are in the available state, results are written as an array of 32-bit unsigned integer values. The behavior when not all queries are available, is described &lt;&lt;queries-wait-bit-not-set, below&gt;&gt;.
            </para>
            <para>
            If ename:VK_QUERY_RESULT_64_BIT is not set and the result overflows a 32-bit value, the value may: either wrap or saturate. Similarly, if ename:VK_QUERY_RESULT_64_BIT is set and the result overflows a 64-bit value, the value may: either wrap or saturate.
            </para>
            <para>
            If ename:VK_QUERY_RESULT_WAIT_BIT is set, Vulkan will wait for each query to be in the available state before retrieving the numerical results for that query. In this case, fname:vkGetQueryPoolResults is guaranteed to succeed and return ename:VK_SUCCESS if the queries become available in a finite time (i.e. if they have been issued and not reset). If queries will never finish (e.g. due to being reset but not issued), then fname:vkGetQueryPoolResults may: not return in finite time.
            </para>
            <para>
            If ename:VK_QUERY_RESULT_WAIT_BIT and ename:VK_QUERY_RESULT_PARTIAL_BIT are both not set then no result values are written to pname:pData for queries that are in the unavailable state at the time of the call, and fname:vkGetQueryPoolResults returns ename:VK_NOT_READY. However, availability state is still written to pname:pData for those queries if ename:VK_QUERY_RESULT_WITH_AVAILABILITY_BIT is set.
            </para>
            <para>
            [NOTE] .Note ==== Applications must: take care to ensure that use of the ename:VK_QUERY_RESULT_WAIT_BIT bit has the desired effect.
            </para>
            <para>
            For example, if a query has been used previously and a command buffer records the commands fname:vkCmdResetQueryPool, fname:vkCmdBeginQuery, and fname:vkCmdEndQuery for that query, then the query will remain in the available state until the fname:vkCmdResetQueryPool command executes on a queue. Applications can: use fences or events to ensure that a query has already been reset before checking for its results or availability status. Otherwise, a stale value could be returned from a previous use of the query.
            </para>
            <para>
            The above also applies when ename:VK_QUERY_RESULT_WAIT_BIT is used in combination with ename:VK_QUERY_RESULT_WITH_AVAILABILITY_BIT. In this case, the returned availability status may: reflect the result of a previous use of the query unless the fname:vkCmdResetQueryPool command has been executed since the last use of the query. ====
            </para>
            <para>
            [NOTE] .Note ==== Applications can: double-buffer query pool usage, with a pool per frame, and reset queries at the end of the frame in which they are read. ====
            </para>
            <para>
            If ename:VK_QUERY_RESULT_PARTIAL_BIT is set, ename:VK_QUERY_RESULT_WAIT_BIT is not set, and the query's status is unavailable, an intermediate result value between zero and the final result value is written to pname:pData for that query.
            </para>
            <para>
            ename:VK_QUERY_RESULT_PARTIAL_BIT must: not be used if the pool's pname:queryType is ename:VK_QUERY_TYPE_TIMESTAMP.
            </para>
            <para>
            If ename:VK_QUERY_RESULT_WITH_AVAILABILITY_BIT is set, the final integer value written for each query is non-zero if the query's status was available or zero if the status was unavailable. When ename:VK_QUERY_RESULT_WITH_AVAILABILITY_BIT is used, implementations must: guarantee that if they return a non-zero availability value then the numerical results must: be valid, assuming the results are not reset by a subsequent command.
            </para>
            <para>
            [NOTE] .Note ==== Satisfying this guarantee may: require careful ordering by the application, e.g. to read the availability status before reading the results. ====
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueryResultFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueryResultFlags.QueryResult64">
            <summary>
            <para>
            Results of the queries are written to the destination buffer as 64-bit values
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueryResultFlags.Wait">
            <summary>
            <para>
            Results of the queries are waited on before proceeding with the result copy
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueryResultFlags.WithAvailability">
            <summary>
            <para>
            Besides the results of the query, the availability of the results is also written
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueryResultFlags.Partial">
            <summary>
            <para>
            Copy the partial results of the query even if the final results are not available
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.QueueFlags">
            <summary>
            <para>
            Bitmask specifying capabilities of queues in a queue family.
            </para>
            <para>
            If an implementation exposes any queue family that supports graphics operations, at least one queue family of at least one physical device exposed by the implementation must: support both graphics and compute operations.
            </para>
            <para>
            [NOTE] .Note ==== All commands that are allowed on a queue that supports transfer operations are also allowed on a queue that supports either graphics or compute operations thus if the capabilities of a queue family include ename:VK_QUEUE_GRAPHICS_BIT or ename:VK_QUEUE_COMPUTE_BIT then reporting the ename:VK_QUEUE_TRANSFER_BIT capability separately for that queue family is optional:. ====
            </para>
            <para>
            For further details see &lt;&lt;devsandqueues-queues,Queues&gt;&gt;.
            </para>
            <para>
            The value returned in pname:minImageTransferGranularity has a unit of compressed texel blocks for images having a block-compressed format, and a unit of texels otherwise.
            </para>
            <para>
            Possible values of pname:minImageTransferGranularity are:
            </para>
            <para>
            * latexmath:[$(0,0,0)$] which indicates that only whole mip levels must: be transferred using the image transfer operations on the corresponding queues. In this case, the following restrictions apply to all offset and extent parameters of image transfer operations:
            </para>
            <para>
            ** The pname:x, pname:y, and pname:z members of a slink:VkOffset3D parameter must: always be zero. ** The pname:width, pname:height, and pname:depth members of a slink:VkExtent3D parameter must: always match the width, height, and depth of the image subresource corresponding to the parameter, respectively.
            </para>
            <para>
            * latexmath:[$(Ax, Ay, Az)$] where latexmath:[$Ax$], latexmath:[$Ay$], and latexmath:[$Az$] are all integer powers of two. In this case the following restrictions apply to all image transfer operations:
            </para>
            <para>
            ** pname:x, pname:y, and pname:z of a slink:VkOffset3D parameter must: be integer multiples of latexmath:[$Ax$], latexmath:[$Ay$], and latexmath:[$Az$], respectively. ** pname:width of a slink:VkExtent3D parameter must: be an integer multiple of latexmath:[$Ax$], or else latexmath:[$(x + width)$] must: equal the width of the image subresource corresponding to the parameter. ** pname:height of a slink:VkExtent3D parameter must: be an integer multiple of latexmath:[$Ay$], or else latexmath:[$(y + height)$] must: equal the height of the image subresource corresponding to the parameter. ** pname:depth of a slink:VkExtent3D parameter must: be an integer multiple of latexmath:[$Az$], or else latexmath:[$(z + depth)$] must: equal the depth of the image subresource corresponding to the parameter. ** If the format of the image corresponding to the parameters is one of the block-compressed formats then for the purposes of the above calculations the granularity must: be scaled up by the compressed texel block dimensions.
            </para>
            <para>
            Queues supporting graphics and/or compute operations must: report latexmath:[$(1,1,1)$] in pname:minImageTransferGranularity, meaning that there are no additional restrictions on the granularity of image transfer operations for these queues. Other queues supporting image transfer operations are only required: to support whole mip level transfers, thus pname:minImageTransferGranularity for queues belonging to such queue families may: be latexmath:[$(0,0,0)$].
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueueFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueueFlags.Graphics">
            <summary>
            <para>
            if ename:VK_QUEUE_GRAPHICS_BIT is set, then the queues in this queue family support graphics operations.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueueFlags.Compute">
            <summary>
            <para>
            if ename:VK_QUEUE_COMPUTE_BIT is set, then the queues in this queue family support compute operations.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueueFlags.Transfer">
            <summary>
            <para>
            if ename:VK_QUEUE_TRANSFER_BIT is set, then the queues in this queue family support transfer operations.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueueFlags.SparseBinding">
            <summary>
            <para>
            if ename:VK_QUEUE_SPARSE_BINDING_BIT is set, then the queues in this queue family support sparse memory management operations (see &lt;&lt;sparsememory,Sparse Resources&gt;&gt;). If any of the sparse resource features are enabled, then at least one queue family must: support this bit.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.RenderPassCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.RenderPassCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.SampleCountFlags">
            <summary>
            <para>
            Bitmask specifying sample counts supported for an image used for storage operations.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SampleCountFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SampleCountFlags.SampleCount1">
            <summary>
            <para>
            Sample count 1 supported
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SampleCountFlags.SampleCount2">
            <summary>
            <para>
            Sample count 2 supported
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SampleCountFlags.SampleCount4">
            <summary>
            <para>
            Sample count 4 supported
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SampleCountFlags.SampleCount8">
            <summary>
            <para>
            Sample count 8 supported
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SampleCountFlags.SampleCount16">
            <summary>
            <para>
            Sample count 16 supported
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SampleCountFlags.SampleCount32">
            <summary>
            <para>
            Sample count 32 supported
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SampleCountFlags.SampleCount64">
            <summary>
            <para>
            Sample count 64 supported
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.SamplerCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SamplerCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.SemaphoreCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SemaphoreCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.ShaderModuleCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ShaderModuleCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.ShaderStageFlags">
            <summary>
            <para>
            Bitmask specifying a pipeline stage.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ShaderStageFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ShaderStageFlags.Vertex">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ShaderStageFlags.TessellationControl">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ShaderStageFlags.TessellationEvaluation">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ShaderStageFlags.Geometry">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ShaderStageFlags.Fragment">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ShaderStageFlags.Compute">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ShaderStageFlags.AllGraphics">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ShaderStageFlags.All">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.SparseImageFormatFlags">
            <summary>
            <para>
            Bitmask specifying additional information about a sparse image resource.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SparseImageFormatFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SparseImageFormatFlags.SingleMiptail">
            <summary>
            <para>
            Image uses a single mip tail region for all array layers
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SparseImageFormatFlags.AlignedMipSize">
            <summary>
            <para>
            Image requires mip level dimensions to be an integer multiple of the sparse image block dimensions for non-tail mip levels.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SparseImageFormatFlags.NonstandardBlockSize">
            <summary>
            <para>
            Image uses a non-standard sparse image block dimensions
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.SparseMemoryBindFlags">
            <summary>
            <para>
            Bitmask specifying usage of a sparse memory binding operation.
            </para>
            <para>
            The _binding range_ latexmath:[$[\mathit{resourceOffset}, \mathit{resourceOffset} + \mathit{size})$] has different constraints based on pname:flags. If pname:flags contains ename:VK_SPARSE_MEMORY_BIND_METADATA_BIT, the binding range must: be within the mip tail region of the metadata aspect. This metadata region is defined by:
            </para>
            <para>
            [latexmath] ++++++++++++++++++++++++++ \begin{align*} \mathit{metadataRegion} = [&amp; \mathit{imageMipTailOffset} + \mathit{imageMipTailStride} \times n,\\ &amp;\mathit{imageMipTailOffset} + \mathit{imageMipTailStride} \times n + \mathit{imageMipTailSize}) \end{align*} ++++++++++++++++++++++++++
            </para>
            <para>
            Where pname:imageMipTailOffset, pname:imageMipTailSize, and pname:imageMipTailStride values are from the slink:VkSparseImageMemoryRequirements that correspond to the metadata aspect of the image. The term latexmath:[$n$] is a valid array layer index for the image.
            </para>
            <para>
            pname:imageMipTailStride is considered to be zero for aspects where sname:VkSparseImageMemoryRequirements::pname:formatProperties.flags contains ename:VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT.
            </para>
            <para>
            If pname:flags does not contain ename:VK_SPARSE_MEMORY_BIND_METADATA_BIT, the binding range must: be within the range latexmath:[$[0, {\mathit{VkMemoryRequirements}::\mathit{size}})$].
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SparseMemoryBindFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SparseMemoryBindFlags.Metadata">
            <summary>
            <para>
            Operation binds resource metadata to memory
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.StencilFaceFlags">
            <summary>
            <para>
            Bitmask specifying sets of stencil state for which to update the compare mask.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StencilFaceFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StencilFaceFlags.Front">
            <summary>
            <para>
            Front face
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StencilFaceFlags.Back">
            <summary>
            <para>
            Back face
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StencilFaceFlags.FrontAndBack">
            <summary>
            <para>
            Front and back faces
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.SubpassDescriptionFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SubpassDescriptionFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.SurfaceTransformFlags">
            <summary>
            <para>
            Presentation transforms supported on a device.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceTransformFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceTransformFlags.Identity">
            <summary>
            <para>
            ename:VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR: The image content is presented without being transformed.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceTransformFlags.Rotate90">
            <summary>
            <para>
            ename:VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR: The image content is rotated 90 degrees clockwise.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceTransformFlags.Rotate180">
            <summary>
            <para>
            ename:VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR: The image content is rotated 180 degrees clockwise.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceTransformFlags.Rotate270">
            <summary>
            <para>
            ename:VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR: The image content is rotated 270 degrees clockwise.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceTransformFlags.HorizontalMirror">
            <summary>
            <para>
            ename:VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR: The image content is mirrored horizontally.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceTransformFlags.HorizontalMirrorRotate90">
            <summary>
            <para>
            ename:VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR: The image content is mirrored horizontally, then rotated 90 degrees clockwise.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceTransformFlags.HorizontalMirrorRotate180">
            <summary>
            <para>
            ename:VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR: The image content is mirrored horizontally, then rotated 180 degrees clockwise.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceTransformFlags.HorizontalMirrorRotate270">
            <summary>
            <para>
            ename:VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR: The image content is mirrored horizontally, then rotated 270 degrees clockwise.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceTransformFlags.Inherit">
            <summary>
            <para>
            ename:VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR: The presentation transform is not specified, and is instead determined by platform-specific considerations and mechanisms outside Vulkan.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.SwapchainCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SwapchainCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.WaylandSurfaceCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.WaylandSurfaceCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Win32SurfaceCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Win32SurfaceCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.XcbSurfaceCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.XcbSurfaceCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.XlibSurfaceCreateFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.XlibSurfaceCreateFlags.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.AttachmentLoadOp">
            <summary>
            <para>
            Specify how contents of an attachment are treated at the beginning of a subpass.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentLoadOp.Load">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentLoadOp.Clear">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentLoadOp.DontCare">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.AttachmentStoreOp">
            <summary>
            <para>
            Specify how contents of an attachment are treated at the end of a subpass.
            </para>
            <para>
            If the attachment uses a color format, then pname:loadOp and pname:storeOp are used, and pname:stencilLoadOp and pname:stencilStoreOp are ignored. If the format has depth and/or stencil components, pname:loadOp and pname:storeOp apply only to the depth data, while pname:stencilLoadOp and pname:stencilStoreOp define how the stencil data is handled.
            </para>
            <para>
            During a render pass instance, input/color attachments with color formats that have a component size of 8, 16, or 32 bits must: be represented in the attachment's format throughout the instance. Attachments with other floating- or fixed-point color formats, or with depth components may: be represented in a format with a precision higher than the attachment format, but must: be represented with the same range. When such a component is loaded via the pname:loadOp, it will be converted into an implementation-dependent format used by the render pass. Such components must: be converted from the render pass format, to the format of the attachment, before they are stored or resolved at the end of a render pass instance via pname:storeOp. Conversions occur as described in &lt;&lt;fundamentals-numerics,Numeric Representation and Computation&gt;&gt; and &lt;&lt;fundamentals-fixedconv, Fixed-Point Data Conversions&gt;&gt;.
            </para>
            <para>
            If pname:flags includes ename:VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT, then the attachment is treated as if it shares physical memory with another attachment in the same render pass. This information limits the ability of the implementation to reorder certain operations (like layout transitions and the pname:loadOp) such that it is not improperly reordered against other uses of the same physical memory via a different attachment. This is described in more detail below.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentStoreOp.Store">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentStoreOp.DontCare">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.BlendFactor">
            <summary>
            <para>
            Framebuffer blending factors.
            </para>
            <para>
            The semantics of each enum value is described in the table below:
            </para>
            <para>
            .Blend Factors [width="100%",options="header",align="center",cols="59%,28%,13%"] |==== |VkBlendFactor                                  | RGB Blend Factors (latexmath:[$S_r,S_g,S_b$]) or (latexmath:[$D_r,D_g,D_b$]) | Alpha Blend Factor (latexmath:[$S_a$] or latexmath:[$D_a$]) |ename:VK_BLEND_FACTOR_ZERO                     | latexmath:[$(0,0,0)$]                           | latexmath:[$0$] |ename:VK_BLEND_FACTOR_ONE                      | latexmath:[$(1,1,1)$]                           | latexmath:[$1$] |ename:VK_BLEND_FACTOR_SRC_COLOR                | latexmath:[$(R_{s0},G_{s0},B_{s0})$]            | latexmath:[$A_{s0}$] |ename:VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR      | latexmath:[$(1-R_{s0},1-G_{s0},1-B_{s0})$]      | latexmath:[$1-A_{s0}$] |ename:VK_BLEND_FACTOR_DST_COLOR                | latexmath:[$(R_d,G_d,B_d)$]                     | latexmath:[$A_d$] |ename:VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR      | latexmath:[$(1-R_d,1-G_d,1-B_d)$]               | latexmath:[$1-A_d$] |ename:VK_BLEND_FACTOR_SRC_ALPHA                | latexmath:[$(A_{s0},A_{s0},A_{s0})$]            | latexmath:[$A_{s0}$] |ename:VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA      | latexmath:[$(1-A_{s0},1-A_{s0},1-A_{s0})$]      | latexmath:[$1-A_{s0}$] |ename:VK_BLEND_FACTOR_DST_ALPHA                | latexmath:[$(A_d,A_d,A_d)$]                     | latexmath:[$A_d$] |ename:VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA      | latexmath:[$(1-A_d,1-A_d,1-A_d)$]               | latexmath:[$1-A_d$] |ename:VK_BLEND_FACTOR_CONSTANT_COLOR           | latexmath:[$(R_c,G_c,B_c)$]                     | latexmath:[$A_c$] |ename:VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR | latexmath:[$(1-R_c,1-G_c,1-B_c)$]               | latexmath:[$1-A_c$] |ename:VK_BLEND_FACTOR_CONSTANT_ALPHA           | latexmath:[$(A_c,A_c,A_c)$]                     | latexmath:[$A_c$] |ename:VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA | latexmath:[$(1-A_c,1-A_c,1-A_c)$]               | latexmath:[$1-A_c$] |ename:VK_BLEND_FACTOR_SRC_ALPHA_SATURATE       | latexmath:[$(f,f,f); f=\min(A_{s0},1-A_d)$]     | latexmath:[$1$] |ename:VK_BLEND_FACTOR_SRC1_COLOR               | latexmath:[$(R_{s1},G_{s1},B_{s1})$]            | latexmath:[$A_{s1}$] |ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR     | latexmath:[$(1-R_{s1},1-G_{s1},1-B_{s1})$]      | latexmath:[$1-A_{s1}$] |ename:VK_BLEND_FACTOR_SRC1_ALPHA               | latexmath:[$(A_{s1},A_{s1},A_{s1})$]            | latexmath:[$A_{s1}$] |ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA     | latexmath:[$(1-A_{s1},1-A_{s1},1-A_{s1})$]      | latexmath:[$1-A_{s1}$] |====
            </para>
            <para>
            In this table, the following conventions are used:
            </para>
            <para>
            * latexmath:[$R_{s0},G_{s0},B_{s0}$] and latexmath:[$A_{s0}$] represent the first source color R, G, B, and A components, respectively, for the fragment output location corresponding to the color attachment being blended. * latexmath:[$R_{s1},G_{s1},B_{s1}$] and latexmath:[$A_{s1}$] represent the second source color R, G, B, and A components, respectively, used in dual source blending modes, for the fragment output location corresponding to the color attachment being blended. * latexmath:[$R_d,G_d,B_d$] and latexmath:[$A_d$] represent the R, G, B, and A components of the destination color. That is, the color currently in the corresponding color attachment for this fragment/sample. * latexmath:[$R_c,G_c,B_c$] and latexmath:[$A_c$] represent the blend constant R, G, B, and A components, respectively.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.Zero">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.One">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.SourceColor">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.OneMinusSourceColor">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.DestinationColor">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.OneMinusDestinationColor">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.SourceAlpha">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.OneMinusSourceAlpha">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.DestinationAlpha">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.OneMinusDestinationAlpha">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.ConstantColor">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.OneMinusConstantColor">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.ConstantAlpha">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.OneMinusConstantAlpha">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.SourceAlphaSaturate">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.Src1Color">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.OneMinusSrc1Color">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.Src1Alpha">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.OneMinusSrc1Alpha">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.BlendOp">
            <summary>
            <para>
            Framebuffer blending operations.
            </para>
            <para>
            &lt;&lt;&lt;
            </para>
            <para>
            The semantics of each enum value is described in the table below:
            </para>
            <para>
            .Blend Operations [width="100%",cols="45%,30%,25%",options="header",align="center"] |==== |VkBlendOp                                   | RGB Components                    | Alpha Component
            </para>
            <para>
            |ename:VK_BLEND_OP_ADD | latexmath:[$R=R_{s0}\times S_r+R_d\times D_r$] + latexmath:[$G=G_{s0}\times S_g+G_d\times D_g$] + latexmath:[$B=B_{s0}\times S_b+B_d\times D_b$] | latexmath:[$A=A_{s0}\times S_a+A_d\times D_a$]
            </para>
            <para>
            |ename:VK_BLEND_OP_SUBTRACT | latexmath:[$R=R_{s0}\times S_r-R_d\times D_r$] + latexmath:[$G=G_{s0}\times S_g-G_d\times D_g$] + latexmath:[$B=B_{s0}\times S_b-B_d\times D_b$] | latexmath:[$A=A_{s0}\times S_a-A_d\times D_a$]
            </para>
            <para>
            |ename:VK_BLEND_OP_REVERSE_SUBTRACT | latexmath:[$R=R_d\times D_r-R_{s0}\times S_r$] + latexmath:[$G=G_d\times D_g-G_{s0}\times S_g$] + latexmath:[$B=B_d\times D_b-B_{s0}\times S_b$] | latexmath:[$A=A_d\times D_a-A_{s0}\times S_a$]
            </para>
            <para>
            |ename:VK_BLEND_OP_MIN | latexmath:[$R=\min(R_{s0},R_d)$] + latexmath:[$G=\min(G_{s0},G_d)$] + latexmath:[$B=\min(B_{s0},B_d)$] | latexmath:[$A=\min(A_{s0},A_d)$]
            </para>
            <para>
            |ename:VK_BLEND_OP_MAX | latexmath:[$R=\max(R_{s0},R_d)$] + latexmath:[$G=\max(G_{s0},G_d)$] + latexmath:[$B=\max(B_{s0},B_d)$] | latexmath:[$A=\max(A_{s0},A_d)$] |====
            </para>
            <para>
            In this table, the following conventions are used:
            </para>
            <para>
            * latexmath:[$R_{s0},G_{s0},B_{s0}$] and latexmath:[$A_{s0}$] represent the first source color R, G, B, and A components, respectively. * latexmath:[$R_d,G_d,B_d$] and latexmath:[$A_d$] represent the R, G, B, and A components of the destination color. That is, the color currently in the corresponding color attachment for this fragment/sample. * latexmath:[$S_r,S_g,S_b$] and latexmath:[$S_a$] represent the source blend factor R, G, B, and A components, respectively. * latexmath:[$D_r,D_g,D_b$] and latexmath:[$D_a$] represent the destination blend factor R, G, B, and A components, respectively.
            </para>
            <para>
            The blending operation produces a new set of values latexmath:[$R, G, B$] and latexmath:[$A$], which are written to the framebuffer attachment. If blending is not enabled for this attachment, then latexmath:[$R, G, B$] and latexmath:[$A$] are assigned latexmath:[$R_{s0},G_{s0},B_{s0}$] and latexmath:[$A_{s0}$], respectively.
            </para>
            <para>
            If the color attachment is fixed-point, the components of the source and destination values and blend factors are each clamped to latexmath:[$[0,1\]$] or latexmath:[$[-1,1\]$] respectively for an unsigned normalized or signed normalized color attachment prior to evaluating the blend operations. If the color attachment is floating-point, no clamping occurs.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BlendOp.Add">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BlendOp.Subtract">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BlendOp.ReverseSubtract">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BlendOp.Min">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BlendOp.Max">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.BorderColor">
            <summary>
            <para>
            Specify border color used for texture lookups.
            </para>
            <para>
            [NOTE] .Mapping of OpenGL to Vulkan filter modes ================== pname:magFilter values of ename:VK_FILTER_NEAREST and ename:VK_FILTER_LINEAR directly correspond to code:GL_NEAREST and code:GL_LINEAR magnification filters. pname:minFilter and pname:mipmapMode combine to correspond to the similarly named OpenGL minification filter of code:GL_minFilter_MIPMAP_mipmapMode (e.g. pname:minFilter of ename:VK_FILTER_LINEAR and pname:mipmapMode of ename:VK_SAMPLER_MIPMAP_MODE_NEAREST correspond to code:GL_LINEAR_MIPMAP_NEAREST).
            </para>
            <para>
            There are no Vulkan filter modes that directly correspond to OpenGL minification filters of code:GL_LINEAR or code:GL_NEAREST, but they can: be emulated using ename:VK_SAMPLER_MIPMAP_MODE_NEAREST, pname:minLod = 0, and pname:maxLod = 0.25, and using pname:minFilter = ename:VK_FILTER_LINEAR or pname:minFilter = ename:VK_FILTER_NEAREST, respectively.
            </para>
            <para>
            Note that using a pname:maxLod of zero would cause &lt;&lt;textures-texel-filtering,magnification&gt;&gt; to always be performed, and the pname:magFilter to always be used. This is valid, just not an exact match for OpenGL behavior. Clamping the maximum LOD to 0.25 allows the latexmath:[$\lambda$] value to be non-zero and minification to be performed, while still always rounding down to the base level. If the pname:minFilter and pname:magFilter are equal, then using a pname:maxLod of zero also works. ==================
            </para>
            <para>
            pname:addressModeU, pname:addressModeV, and pname:addressModeW must: each have one of the following values:
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BorderColor.FloatTransparentBlack">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BorderColor.IntTransparentBlack">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BorderColor.FloatOpaqueBlack">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BorderColor.IntOpaqueBlack">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BorderColor.FloatOpaqueWhite">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BorderColor.IntOpaqueWhite">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.ColorSpace">
            <summary>
            <para>
            Supported color space of the presentation engine.
            </para>
            <para>
            [NOTE] .Note ==== If pname:pSurfaceFormats includes just one entry, whose value for pname:format is ename:VK_FORMAT_UNDEFINED, pname:surface has no preferred format. In this case, the application can: use any valid ename:VkFormat value. ====
            </para>
            <para>
            [NOTE] .Note ==== In the initial release of the +VK_KHR_surface+ and +VK_KHR_swapchain+ extensions, the token ename:VK_COLORSPACE_SRGB_NONLINEAR_KHR was used. Starting in the May 13, 2016 updates to the extension branches, matching release 1.0.13 of the core API specification, ename:VK_COLOR_SPACE_SRGB_NONLINEAR_KHR is used instead for consistency with Vulkan naming rules. The older enum is still available for backwards compatibility. ====
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ColorSpace.SrgbNonlinear">
            <summary>
            <para>
            ename:VK_COLOR_SPACE_SRGB_NONLINEAR_KHR: The presentation engine supports the sRGB color space.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.CommandBufferLevel">
            <summary>
            <para>
            Structure specifying a command buffer level.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CommandBufferLevel.Primary">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CommandBufferLevel.Secondary">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.CompareOp">
            <summary>
            <para>
            Stencil comparison function.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CompareOp.Never">
            <summary>
            <para>
            ename:VK_COMPARE_OP_NEVER: the test never passes.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CompareOp.Less">
            <summary>
            <para>
            ename:VK_COMPARE_OP_LESS: the test passes when latexmath:[$R \lt S$].
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CompareOp.Equal">
            <summary>
            <para>
            ename:VK_COMPARE_OP_EQUAL: the test passes when latexmath:[$R = S$].
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CompareOp.LessOrEqual">
            <summary>
            <para>
            ename:VK_COMPARE_OP_LESS_OR_EQUAL: the test passes when latexmath:[$R \leq S$].
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CompareOp.Greater">
            <summary>
            <para>
            ename:VK_COMPARE_OP_GREATER: the test passes when latexmath:[$R \gt S$].
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CompareOp.NotEqual">
            <summary>
            <para>
            ename:VK_COMPARE_OP_NOT_EQUAL: the test passes when latexmath:[$R \neq S$].
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CompareOp.GreaterOrEqual">
            <summary>
            <para>
            ename:VK_COMPARE_OP_GREATER_OR_EQUAL: the test passes when latexmath:[$R \geq S$].
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CompareOp.Always">
            <summary>
            <para>
            ename:VK_COMPARE_OP_ALWAYS: the test always passes.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.ComponentSwizzle">
            <summary>
            <para>
            Specify how a component is swizzled.
            </para>
            <para>
            Setting the identity swizzle on a component is equivalent to setting the identity mapping on that component. That is:
            </para>
            <para>
            .Component Mappings Equivalent To ename:VK_COMPONENT_SWIZZLE_IDENTITY [options="header"] |==== | Component          | Identity Mapping | pname:components.r | ename:VK_COMPONENT_SWIZZLE_R | pname:components.g | ename:VK_COMPONENT_SWIZZLE_G | pname:components.b | ename:VK_COMPONENT_SWIZZLE_B | pname:components.a | ename:VK_COMPONENT_SWIZZLE_A |====
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ComponentSwizzle.Identity">
            <summary>
            <para>
            ename:VK_COMPONENT_SWIZZLE_IDENTITY: the component is set to the identity swizzle.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ComponentSwizzle.Zero">
            <summary>
            <para>
            ename:VK_COMPONENT_SWIZZLE_ZERO: the component is set to zero.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ComponentSwizzle.One">
            <summary>
            <para>
            ename:VK_COMPONENT_SWIZZLE_ONE: the component is set to either 1 or 1.0 depending on whether the type of the image view format is integer or floating-point respectively, as determined by the &lt;&lt;features-formats-definition,Format Definition&gt;&gt; section for each elink:VkFormat.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ComponentSwizzle.R">
            <summary>
            <para>
            ename:VK_COMPONENT_SWIZZLE_R: the component is set to the value of the R component of the image.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ComponentSwizzle.G">
            <summary>
            <para>
            ename:VK_COMPONENT_SWIZZLE_G: the component is set to the value of the G component of the image.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ComponentSwizzle.B">
            <summary>
            <para>
            ename:VK_COMPONENT_SWIZZLE_B: the component is set to the value of the B component of the image.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ComponentSwizzle.A">
            <summary>
            <para>
            ename:VK_COMPONENT_SWIZZLE_A: the component is set to the value of the A component of the image.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DebugReportError">
            <summary>
            <para>
            Unknown VK_EXT_debug_report enumeration type.
            </para>
            <para>
            [NOTE] .Note ==== The +VK_EXT_debug_report+ extension defines the elink:VkDebugReportErrorEXT enumerant type, but does not currently explain what the enumeration is used for. It is included here for completeness. ====
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportError.None">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportError.CallbackRef">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DebugReportObjectType">
            <summary>
            <para>
            Specify the type of an object handle.
            </para>
            <para>
            === Command Buffer Markers
            </para>
            <para>
            Typical Vulkan applications will submit many command buffers in each frame, with each command buffer containing a large number of individual commands. Being able to logically annotate regions of command buffers that belong together as well as hierarchically subdivide the frame is important to a developer's ability to navigate the commands viewed holistically.
            </para>
            <para>
            The marker commands fname:vkCmdDebugMarkerBeginEXT and fname:vkCmdDebugMarkerEndEXT define regions of a series of commands that are grouped together, and they can be nested to create a hierarchy. The fname:vkCmdDebugMarkerInsertEXT command allows insertion of a single label within a command buffer.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.Unknown">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT is an unknown object.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.Instance">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT is a sname:VkInstance.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.PhysicalDevice">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT is a sname:VkPhysicalDevice.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.Device">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT is a sname:VkDevice.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.Queue">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT is a sname:VkQueue.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.Semaphore">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT is a sname:VkSemaphore.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.CommandBuffer">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT is a sname:VkCommandBuffer.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.Fence">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT is a sname:VkFence.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.DeviceMemory">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT is a sname:VkDeviceMemory.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.Buffer">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT is a sname:VkBuffer.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.Image">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT is a sname:VkImage.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.Event">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT is a sname:VkEvent.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.QueryPool">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT is a sname:VkQueryPool.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.BufferView">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT is a sname:VkBufferView.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.ImageView">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT is a sname:VkImageView.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.ShaderModule">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT is a sname:VkShaderModule.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.PipelineCache">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT is a sname:VkPipelineCache.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.PipelineLayout">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT is a sname:VkPipelineLayout.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.RenderPass">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT is a sname:VkRenderPass.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.Pipeline">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT is a sname:VkPipeline.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.DescriptorSetLayout">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT is a sname:VkDescriptorSetLayout.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.Sampler">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT is a sname:VkSampler.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.DescriptorPool">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT is a sname:VkDescriptorPool.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.DescriptorSet">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT is a sname:VkDescriptorSet.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.Framebuffer">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT is a sname:VkFramebuffer.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.CommandPool">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT is a sname:VkCommandPool.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.SurfaceKhr">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT is a sname:VkSurfaceKHR.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.SwapchainKhr">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT is a sname:VkSwapchainKHR.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.DebugReport">
            <summary>
            <para>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT is a sname:VkDebugReportCallbackEXT.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DescriptorType">
            <summary>
            <para>
            Specifies the type of a descriptor in a descriptor set.
            </para>
            <para>
            If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the elements of the slink:VkWriteDescriptorSet::pname:pBufferInfo array of slink:VkDescriptorBufferInfo structures will be used to update the descriptors, and other arrays will be ignored.
            </para>
            <para>
            If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, the slink:VkWriteDescriptorSet::pname:pTexelBufferView array will be used to update the descriptors, and other arrays will be ignored.
            </para>
            <para>
            If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the elements of the slink:VkWriteDescriptorSet::pname:pImageInfo array of slink:VkDescriptorImageInfo structures will be used to update the descriptors, and other arrays will be ignored.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorType.Sampler">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorType.CombinedImageSampler">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorType.SampledImage">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorType.StorageImage">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorType.UniformTexelBuffer">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorType.StorageTexelBuffer">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorType.UniformBuffer">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorType.StorageBuffer">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorType.UniformBufferDynamic">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorType.StorageBufferDynamic">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorType.InputAttachment">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DynamicState">
            <summary>
            <para>
            Indicate which dynamic state is taken from dynamic state commands.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DynamicState.Viewport">
            <summary>
            <para>
            ename:VK_DYNAMIC_STATE_VIEWPORT indicates that the pname:pViewports state in sname:VkPipelineViewportStateCreateInfo will be ignored and must: be set dynamically with flink:vkCmdSetViewport before any draw commands. The number of viewports used by a pipeline is still specified by the pname:viewportCount member of sname:VkPipelineViewportStateCreateInfo.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DynamicState.Scissor">
            <summary>
            <para>
            ename:VK_DYNAMIC_STATE_SCISSOR indicates that the pname:pScissors state in sname:VkPipelineViewportStateCreateInfo will be ignored and must: be set dynamically with flink:vkCmdSetScissor before any draw commands. The number of scissor rectangles used by a pipeline is still specified by the pname:scissorCount member of sname:VkPipelineViewportStateCreateInfo.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DynamicState.LineWidth">
            <summary>
            <para>
            ename:VK_DYNAMIC_STATE_LINE_WIDTH indicates that the pname:lineWidth state in sname:VkPipelineRasterizationStateCreateInfo will be ignored and must: be set dynamically with flink:vkCmdSetLineWidth before any draw commands that generate line primitives for the rasterizer.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DynamicState.DepthBias">
            <summary>
            <para>
            ename:VK_DYNAMIC_STATE_DEPTH_BIAS indicates that the pname:depthBiasConstantFactor, pname:depthBiasClamp and pname:depthBiasSlopeFactor states in sname:VkPipelineRasterizationStateCreateInfo will be ignored and must: be set dynamically with flink:vkCmdSetDepthBias before any draws are performed with pname:depthBiasEnable in sname:VkPipelineRasterizationStateCreateInfo set to ename:VK_TRUE.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DynamicState.BlendConstants">
            <summary>
            <para>
            ename:VK_DYNAMIC_STATE_BLEND_CONSTANTS indicates that the pname:blendConstants state in sname:VkPipelineColorBlendStateCreateInfo will be ignored and must: be set dynamically with flink:vkCmdSetBlendConstants before any draws are performed with a pipeline state with sname:VkPipelineColorBlendAttachmentState member pname:blendEnable set to ename:VK_TRUE and any of the blend functions using a constant blend color.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DynamicState.DepthBounds">
            <summary>
            <para>
            ename:VK_DYNAMIC_STATE_DEPTH_BOUNDS indicates that the pname:minDepthBounds and pname:maxDepthBounds states of slink:VkPipelineDepthStencilStateCreateInfo will be ignored and must: be set dynamically with flink:vkCmdSetDepthBounds before any draws are performed with a pipeline state with sname:VkPipelineDepthStencilStateCreateInfo member pname:depthBoundsTestEnable set to ename:VK_TRUE.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DynamicState.StencilCompareMask">
            <summary>
            <para>
            ename:VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK indicates that the pname:compareMask state in sname:VkPipelineDepthStencilStateCreateInfo for both pname:front and pname:back will be ignored and must: be set dynamically with flink:vkCmdSetStencilCompareMask before any draws are performed with a pipeline state with sname:VkPipelineDepthStencilStateCreateInfo member pname:stencilTestEnable set to ename:VK_TRUE
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DynamicState.StencilWriteMask">
            <summary>
            <para>
            ename:VK_DYNAMIC_STATE_STENCIL_WRITE_MASK indicates that the pname:writeMask state in sname:VkPipelineDepthStencilStateCreateInfo for both pname:front and pname:back will be ignored and must: be set dynamically with flink:vkCmdSetStencilWriteMask before any draws are performed with a pipeline state with sname:VkPipelineDepthStencilStateCreateInfo member pname:stencilTestEnable set to ename:VK_TRUE
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DynamicState.StencilReference">
            <summary>
            <para>
            ename:VK_DYNAMIC_STATE_STENCIL_REFERENCE indicates that the pname:reference state in sname:VkPipelineDepthStencilStateCreateInfo for both pname:front and pname:back will be ignored and must: be set dynamically with flink:vkCmdSetStencilReference before any draws are performed with a pipeline state with sname:VkPipelineDepthStencilStateCreateInfo member pname:stencilTestEnable set to ename:VK_TRUE
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Filter">
            <summary>
            <para>
            Specify filters used for texture lookups.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Filter.Nearest">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Filter.Linear">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Filter.CubicImg">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Format">
            <summary>
            <para>
            Available image formats.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Undefined">
            <summary>
            <para>
            ename:VK_FORMAT_UNDEFINED:: The format is not specified.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R4G4UNormPack8">
            <summary>
            <para>
            ename:VK_FORMAT_R4G4_UNORM_PACK8:: A two-component, 8-bit packed unsigned normalized format that has a 4-bit R component in bits 4..7, and a 4-bit G component in bits 0..3.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R4G4B4A4UNormPack16">
            <summary>
            <para>
            ename:VK_FORMAT_R4G4B4A4_UNORM_PACK16:: A four-component, 16-bit packed unsigned normalized format that has a 4-bit R component in bits 12..15, a 4-bit G component in bits 8..11, a 4-bit B component in bits 4..7, and a 4-bit A component in bits 0..3.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.B4G4R4A4UNormPack16">
            <summary>
            <para>
            ename:VK_FORMAT_B4G4R4A4_UNORM_PACK16:: A four-component, 16-bit packed unsigned normalized format that has a 4-bit B component in bits 12..15, a 4-bit G component in bits 8..11, a 4-bit R component in bits 4..7, and a 4-bit A component in bits 0..3.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R5G6B5UNormPack16">
            <summary>
            <para>
            ename:VK_FORMAT_R5G6B5_UNORM_PACK16:: A three-component, 16-bit packed unsigned normalized format that has a 5-bit R component in bits 11..15, a 6-bit G component in bits 5..10, and a 5-bit B component in bits 0..4.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.B5G6R5UNormPack16">
            <summary>
            <para>
            ename:VK_FORMAT_B5G6R5_UNORM_PACK16:: A three-component, 16-bit packed unsigned normalized format that has a 5-bit B component in bits 11..15, a 6-bit G component in bits 5..10, and a 5-bit R component in bits 0..4.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R5G5B5A1UNormPack16">
            <summary>
            <para>
            ename:VK_FORMAT_R5G5B5A1_UNORM_PACK16:: A four-component, 16-bit packed unsigned normalized format that has a 5-bit R component in bits 11..15, a 5-bit G component in bits 6..10, a 5-bit B component in bits 1..5, and a 1-bit A component in bit 0.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.B5G5R5A1UNormPack16">
            <summary>
            <para>
            ename:VK_FORMAT_B5G5R5A1_UNORM_PACK16:: A four-component, 16-bit packed unsigned normalized format that has a 5-bit B component in bits 11..15, a 5-bit G component in bits 6..10, a 5-bit R component in bits 1..5, and a 1-bit A component in bit 0.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.A1R5G5B5UNormPack16">
            <summary>
            <para>
            ename:VK_FORMAT_A1R5G5B5_UNORM_PACK16:: A four-component, 16-bit packed unsigned normalized format that has a 1-bit A component in bit 15, a 5-bit R component in bits 10..14, a 5-bit G component in bits 5..9, and a 5-bit B component in bits 0..4.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8UNorm">
            <summary>
            <para>
            ename:VK_FORMAT_R8_UNORM:: A one-component, 8-bit unsigned normalized format that has a single 8-bit R component.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8SNorm">
            <summary>
            <para>
            ename:VK_FORMAT_R8_SNORM:: A one-component, 8-bit signed normalized format that has a single 8-bit R component.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8UScaled">
            <summary>
            <para>
            ename:VK_FORMAT_R8_USCALED:: A one-component, 8-bit unsigned scaled integer format that has a single 8-bit R component.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8SScaled">
            <summary>
            <para>
            ename:VK_FORMAT_R8_SSCALED:: A one-component, 8-bit signed scaled integer format that has a single 8-bit R component.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8UInt">
            <summary>
            <para>
            ename:VK_FORMAT_R8_UINT:: A one-component, 8-bit unsigned integer format that has a single 8-bit R component.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8SInt">
            <summary>
            <para>
            ename:VK_FORMAT_R8_SINT:: A one-component, 8-bit signed integer format that has a single 8-bit R component.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8Srgb">
            <summary>
            <para>
            ename:VK_FORMAT_R8_SRGB:: A one-component, 8-bit unsigned normalized format that has a single 8-bit R component stored with sRGB nonlinear encoding.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8UNorm">
            <summary>
            <para>
            ename:VK_FORMAT_R8G8_UNORM:: A two-component, 16-bit unsigned normalized format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8SNorm">
            <summary>
            <para>
            ename:VK_FORMAT_R8G8_SNORM:: A two-component, 16-bit signed normalized format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8UScaled">
            <summary>
            <para>
            ename:VK_FORMAT_R8G8_USCALED:: A two-component, 16-bit unsigned scaled integer format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8SScaled">
            <summary>
            <para>
            ename:VK_FORMAT_R8G8_SSCALED:: A two-component, 16-bit signed scaled integer format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8UInt">
            <summary>
            <para>
            ename:VK_FORMAT_R8G8_UINT:: A two-component, 16-bit unsigned integer format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8SInt">
            <summary>
            <para>
            ename:VK_FORMAT_R8G8_SINT:: A two-component, 16-bit signed integer format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8Srgb">
            <summary>
            <para>
            ename:VK_FORMAT_R8G8_SRGB:: A two-component, 16-bit unsigned normalized format that has an 8-bit R component stored with sRGB nonlinear encoding in byte 0, and an 8-bit G component stored with sRGB nonlinear encoding in byte 1.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8B8UNorm">
            <summary>
            <para>
            ename:VK_FORMAT_R8G8B8_UNORM:: A three-component, 24-bit unsigned normalized format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8B8SNorm">
            <summary>
            <para>
            ename:VK_FORMAT_R8G8B8_SNORM:: A three-component, 24-bit signed normalized format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8B8UScaled">
            <summary>
            <para>
            ename:VK_FORMAT_R8G8B8_USCALED:: A three-component, 24-bit unsigned scaled format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8B8SScaled">
            <summary>
            <para>
            ename:VK_FORMAT_R8G8B8_SSCALED:: A three-component, 24-bit signed scaled format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8B8UInt">
            <summary>
            <para>
            ename:VK_FORMAT_R8G8B8_UINT:: A three-component, 24-bit unsigned integer format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8B8SInt">
            <summary>
            <para>
            ename:VK_FORMAT_R8G8B8_SINT:: A three-component, 24-bit signed integer format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8B8Srgb">
            <summary>
            <para>
            ename:VK_FORMAT_R8G8B8_SRGB:: A three-component, 24-bit unsigned normalized format that has an 8-bit R component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, and an 8-bit B component stored with sRGB nonlinear encoding in byte 2.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.B8G8R8UNorm">
            <summary>
            <para>
            ename:VK_FORMAT_B8G8R8_UNORM:: A three-component, 24-bit unsigned normalized format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.B8G8R8SNorm">
            <summary>
            <para>
            ename:VK_FORMAT_B8G8R8_SNORM:: A three-component, 24-bit signed normalized format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.B8G8R8UScaled">
            <summary>
            <para>
            ename:VK_FORMAT_B8G8R8_USCALED:: A three-component, 24-bit unsigned scaled format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.B8G8R8SScaled">
            <summary>
            <para>
            ename:VK_FORMAT_B8G8R8_SSCALED:: A three-component, 24-bit signed scaled format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.B8G8R8UInt">
            <summary>
            <para>
            ename:VK_FORMAT_B8G8R8_UINT:: A three-component, 24-bit unsigned integer format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.B8G8R8SInt">
            <summary>
            <para>
            ename:VK_FORMAT_B8G8R8_SINT:: A three-component, 24-bit signed integer format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.B8G8R8Srgb">
            <summary>
            <para>
            ename:VK_FORMAT_B8G8R8_SRGB:: A three-component, 24-bit unsigned normalized format that has an 8-bit B component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, and an 8-bit R component stored with sRGB nonlinear encoding in byte 2.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8B8A8UNorm">
            <summary>
            <para>
            ename:VK_FORMAT_R8G8B8A8_UNORM:: A four-component, 32-bit unsigned normalized format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8B8A8SNorm">
            <summary>
            <para>
            ename:VK_FORMAT_R8G8B8A8_SNORM:: A four-component, 32-bit signed normalized format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8B8A8UScaled">
            <summary>
            <para>
            ename:VK_FORMAT_R8G8B8A8_USCALED:: A four-component, 32-bit unsigned scaled format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8B8A8SScaled">
            <summary>
            <para>
            ename:VK_FORMAT_R8G8B8A8_SSCALED:: A four-component, 32-bit signed scaled format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8B8A8UInt">
            <summary>
            <para>
            ename:VK_FORMAT_R8G8B8A8_UINT:: A four-component, 32-bit unsigned integer format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8B8A8SInt">
            <summary>
            <para>
            ename:VK_FORMAT_R8G8B8A8_SINT:: A four-component, 32-bit signed integer format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8B8A8Srgb">
            <summary>
            <para>
            ename:VK_FORMAT_R8G8B8A8_SRGB:: A four-component, 32-bit unsigned normalized format that has an 8-bit R component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, an 8-bit B component stored with sRGB nonlinear encoding in byte 2, and an 8-bit A component in byte 3.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.B8G8R8A8UNorm">
            <summary>
            <para>
            ename:VK_FORMAT_B8G8R8A8_UNORM:: A four-component, 32-bit unsigned normalized format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.B8G8R8A8SNorm">
            <summary>
            <para>
            ename:VK_FORMAT_B8G8R8A8_SNORM:: A four-component, 32-bit signed normalized format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.B8G8R8A8UScaled">
            <summary>
            <para>
            ename:VK_FORMAT_B8G8R8A8_USCALED:: A four-component, 32-bit unsigned scaled format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.B8G8R8A8SScaled">
            <summary>
            <para>
            ename:VK_FORMAT_B8G8R8A8_SSCALED:: A four-component, 32-bit signed scaled format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.B8G8R8A8UInt">
            <summary>
            <para>
            ename:VK_FORMAT_B8G8R8A8_UINT:: A four-component, 32-bit unsigned integer format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.B8G8R8A8SInt">
            <summary>
            <para>
            ename:VK_FORMAT_B8G8R8A8_SINT:: A four-component, 32-bit signed integer format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.B8G8R8A8Srgb">
            <summary>
            <para>
            ename:VK_FORMAT_B8G8R8A8_SRGB:: A four-component, 32-bit unsigned normalized format that has an 8-bit B component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, an 8-bit R component stored with sRGB nonlinear encoding in byte 2, and an 8-bit A component in byte 3.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.A8B8G8R8UNormPack32">
            <summary>
            <para>
            ename:VK_FORMAT_A8B8G8R8_UNORM_PACK32:: A four-component, 32-bit packed unsigned normalized format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.A8B8G8R8SNormPack32">
            <summary>
            <para>
            ename:VK_FORMAT_A8B8G8R8_SNORM_PACK32:: A four-component, 32-bit packed signed normalized format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.A8B8G8R8UScaledPack32">
            <summary>
            <para>
            ename:VK_FORMAT_A8B8G8R8_USCALED_PACK32:: A four-component, 32-bit packed unsigned scaled integer format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.A8B8G8R8SScaledPack32">
            <summary>
            <para>
            ename:VK_FORMAT_A8B8G8R8_SSCALED_PACK32:: A four-component, 32-bit packed signed scaled integer format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.A8B8G8R8UIntPack32">
            <summary>
            <para>
            ename:VK_FORMAT_A8B8G8R8_UINT_PACK32:: A four-component, 32-bit packed unsigned integer format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.A8B8G8R8SIntPack32">
            <summary>
            <para>
            ename:VK_FORMAT_A8B8G8R8_SINT_PACK32:: A four-component, 32-bit packed signed integer format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.A8B8G8R8SrgbPack32">
            <summary>
            <para>
            ename:VK_FORMAT_A8B8G8R8_SRGB_PACK32:: A four-component, 32-bit packed unsigned normalized format that has an 8-bit A component in bits 24..31, an 8-bit B component stored with sRGB nonlinear encoding in bits 16..23, an 8-bit G component stored with sRGB nonlinear encoding in bits 8..15, and an 8-bit R component stored with sRGB nonlinear encoding in bits 0..7.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.A2R10G10B10UNormPack32">
            <summary>
            <para>
            ename:VK_FORMAT_A2R10G10B10_UNORM_PACK32:: A four-component, 32-bit packed unsigned normalized format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.A2R10G10B10SNormPack32">
            <summary>
            <para>
            ename:VK_FORMAT_A2R10G10B10_SNORM_PACK32:: A four-component, 32-bit packed signed normalized format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.A2R10G10B10UScaledPack32">
            <summary>
            <para>
            ename:VK_FORMAT_A2R10G10B10_USCALED_PACK32:: A four-component, 32-bit packed unsigned scaled integer format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.A2R10G10B10SScaledPack32">
            <summary>
            <para>
            ename:VK_FORMAT_A2R10G10B10_SSCALED_PACK32:: A four-component, 32-bit packed signed scaled integer format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.A2R10G10B10UIntPack32">
            <summary>
            <para>
            ename:VK_FORMAT_A2R10G10B10_UINT_PACK32:: A four-component, 32-bit packed unsigned integer format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.A2R10G10B10SIntPack32">
            <summary>
            <para>
            ename:VK_FORMAT_A2R10G10B10_SINT_PACK32:: A four-component, 32-bit packed signed integer format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.A2B10G10R10UNormPack32">
            <summary>
            <para>
            ename:VK_FORMAT_A2B10G10R10_UNORM_PACK32:: A four-component, 32-bit packed unsigned normalized format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.A2B10G10R10SNormPack32">
            <summary>
            <para>
            ename:VK_FORMAT_A2B10G10R10_SNORM_PACK32:: A four-component, 32-bit packed signed normalized format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.A2B10G10R10UScaledPack32">
            <summary>
            <para>
            ename:VK_FORMAT_A2B10G10R10_USCALED_PACK32:: A four-component, 32-bit packed unsigned scaled integer format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.A2B10G10R10SScaledPack32">
            <summary>
            <para>
            ename:VK_FORMAT_A2B10G10R10_SSCALED_PACK32:: A four-component, 32-bit packed signed scaled integer format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.A2B10G10R10UIntPack32">
            <summary>
            <para>
            ename:VK_FORMAT_A2B10G10R10_UINT_PACK32:: A four-component, 32-bit packed unsigned integer format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.A2B10G10R10SIntPack32">
            <summary>
            <para>
            ename:VK_FORMAT_A2B10G10R10_SINT_PACK32:: A four-component, 32-bit packed signed integer format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16UNorm">
            <summary>
            <para>
            ename:VK_FORMAT_R16_UNORM:: A one-component, 16-bit unsigned normalized format that has a single 16-bit R component.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16SNorm">
            <summary>
            <para>
            ename:VK_FORMAT_R16_SNORM:: A one-component, 16-bit signed normalized format that has a single 16-bit R component.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16UScaled">
            <summary>
            <para>
            ename:VK_FORMAT_R16_USCALED:: A one-component, 16-bit unsigned scaled integer format that has a single 16-bit R component.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16SScaled">
            <summary>
            <para>
            ename:VK_FORMAT_R16_SSCALED:: A one-component, 16-bit signed scaled integer format that has a single 16-bit R component.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16UInt">
            <summary>
            <para>
            ename:VK_FORMAT_R16_UINT:: A one-component, 16-bit unsigned integer format that has a single 16-bit R component.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16SInt">
            <summary>
            <para>
            ename:VK_FORMAT_R16_SINT:: A one-component, 16-bit signed integer format that has a single 16-bit R component.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16SFloat">
            <summary>
            <para>
            ename:VK_FORMAT_R16_SFLOAT:: A one-component, 16-bit signed floating-point format that has a single 16-bit R component.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16UNorm">
            <summary>
            <para>
            ename:VK_FORMAT_R16G16_UNORM:: A two-component, 32-bit unsigned normalized format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16SNorm">
            <summary>
            <para>
            ename:VK_FORMAT_R16G16_SNORM:: A two-component, 32-bit signed normalized format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16UScaled">
            <summary>
            <para>
            ename:VK_FORMAT_R16G16_USCALED:: A two-component, 32-bit unsigned scaled integer format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16SScaled">
            <summary>
            <para>
            ename:VK_FORMAT_R16G16_SSCALED:: A two-component, 32-bit signed scaled integer format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16UInt">
            <summary>
            <para>
            ename:VK_FORMAT_R16G16_UINT:: A two-component, 32-bit unsigned integer format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16SInt">
            <summary>
            <para>
            ename:VK_FORMAT_R16G16_SINT:: A two-component, 32-bit signed integer format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16SFloat">
            <summary>
            <para>
            ename:VK_FORMAT_R16G16_SFLOAT:: A two-component, 32-bit signed floating-point format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16B16UNorm">
            <summary>
            <para>
            ename:VK_FORMAT_R16G16B16_UNORM:: A three-component, 48-bit unsigned normalized format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16B16SNorm">
            <summary>
            <para>
            ename:VK_FORMAT_R16G16B16_SNORM:: A three-component, 48-bit signed normalized format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16B16UScaled">
            <summary>
            <para>
            ename:VK_FORMAT_R16G16B16_USCALED:: A three-component, 48-bit unsigned scaled integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16B16SScaled">
            <summary>
            <para>
            ename:VK_FORMAT_R16G16B16_SSCALED:: A three-component, 48-bit signed scaled integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16B16UInt">
            <summary>
            <para>
            ename:VK_FORMAT_R16G16B16_UINT:: A three-component, 48-bit unsigned integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16B16SInt">
            <summary>
            <para>
            ename:VK_FORMAT_R16G16B16_SINT:: A three-component, 48-bit signed integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16B16SFloat">
            <summary>
            <para>
            ename:VK_FORMAT_R16G16B16_SFLOAT:: A three-component, 48-bit signed floating-point format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16B16A16UNorm">
            <summary>
            <para>
            ename:VK_FORMAT_R16G16B16A16_UNORM:: A four-component, 64-bit unsigned normalized format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16B16A16SNorm">
            <summary>
            <para>
            ename:VK_FORMAT_R16G16B16A16_SNORM:: A four-component, 64-bit signed normalized format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16B16A16UScaled">
            <summary>
            <para>
            ename:VK_FORMAT_R16G16B16A16_USCALED:: A four-component, 64-bit unsigned scaled integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16B16A16SScaled">
            <summary>
            <para>
            ename:VK_FORMAT_R16G16B16A16_SSCALED:: A four-component, 64-bit signed scaled integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16B16A16UInt">
            <summary>
            <para>
            ename:VK_FORMAT_R16G16B16A16_UINT:: A four-component, 64-bit unsigned integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16B16A16SInt">
            <summary>
            <para>
            ename:VK_FORMAT_R16G16B16A16_SINT:: A four-component, 64-bit signed integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16B16A16SFloat">
            <summary>
            <para>
            ename:VK_FORMAT_R16G16B16A16_SFLOAT:: A four-component, 64-bit signed floating-point format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R32UInt">
            <summary>
            <para>
            ename:VK_FORMAT_R32_UINT:: A one-component, 32-bit unsigned integer format that has a single 32-bit R component.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R32SInt">
            <summary>
            <para>
            ename:VK_FORMAT_R32_SINT:: A one-component, 32-bit signed integer format that has a single 32-bit R component.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R32SFloat">
            <summary>
            <para>
            ename:VK_FORMAT_R32_SFLOAT:: A one-component, 32-bit signed floating-point format that has a single 32-bit R component.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R32G32UInt">
            <summary>
            <para>
            ename:VK_FORMAT_R32G32_UINT:: A two-component, 64-bit unsigned integer format that has a 32-bit R component in bytes 0..3, and a 32-bit G component in bytes 4..7.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R32G32SInt">
            <summary>
            <para>
            ename:VK_FORMAT_R32G32_SINT:: A two-component, 64-bit signed integer format that has a 32-bit R component in bytes 0..3, and a 32-bit G component in bytes 4..7.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R32G32SFloat">
            <summary>
            <para>
            ename:VK_FORMAT_R32G32_SFLOAT:: A two-component, 64-bit signed floating-point format that has a 32-bit R component in bytes 0..3, and a 32-bit G component in bytes 4..7.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R32G32B32UInt">
            <summary>
            <para>
            ename:VK_FORMAT_R32G32B32_UINT:: A three-component, 96-bit unsigned integer format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, and a 32-bit B component in bytes 8..11.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R32G32B32SInt">
            <summary>
            <para>
            ename:VK_FORMAT_R32G32B32_SINT:: A three-component, 96-bit signed integer format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, and a 32-bit B component in bytes 8..11.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R32G32B32SFloat">
            <summary>
            <para>
            ename:VK_FORMAT_R32G32B32_SFLOAT:: A three-component, 96-bit signed floating-point format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, and a 32-bit B component in bytes 8..11.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R32G32B32A32UInt">
            <summary>
            <para>
            ename:VK_FORMAT_R32G32B32A32_UINT:: A four-component, 128-bit unsigned integer format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, a 32-bit B component in bytes 8..11, and a 32-bit A component in bytes 12..15.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R32G32B32A32SInt">
            <summary>
            <para>
            ename:VK_FORMAT_R32G32B32A32_SINT:: A four-component, 128-bit signed integer format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, a 32-bit B component in bytes 8..11, and a 32-bit A component in bytes 12..15.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R32G32B32A32SFloat">
            <summary>
            <para>
            ename:VK_FORMAT_R32G32B32A32_SFLOAT:: A four-component, 128-bit signed floating-point format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, a 32-bit B component in bytes 8..11, and a 32-bit A component in bytes 12..15.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R64UInt">
            <summary>
            <para>
            ename:VK_FORMAT_R64_UINT:: A one-component, 64-bit unsigned integer format that has a single 64-bit R component.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R64SInt">
            <summary>
            <para>
            ename:VK_FORMAT_R64_SINT:: A one-component, 64-bit signed integer format that has a single 64-bit R component.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R64SFloat">
            <summary>
            <para>
            ename:VK_FORMAT_R64_SFLOAT:: A one-component, 64-bit signed floating-point format that has a single 64-bit R component.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R64G64UInt">
            <summary>
            <para>
            ename:VK_FORMAT_R64G64_UINT:: A two-component, 128-bit unsigned integer format that has a 64-bit R component in bytes 0..7, and a 64-bit G component in bytes 8..15.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R64G64SInt">
            <summary>
            <para>
            ename:VK_FORMAT_R64G64_SINT:: A two-component, 128-bit signed integer format that has a 64-bit R component in bytes 0..7, and a 64-bit G component in bytes 8..15.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R64G64SFloat">
            <summary>
            <para>
            ename:VK_FORMAT_R64G64_SFLOAT:: A two-component, 128-bit signed floating-point format that has a 64-bit R component in bytes 0..7, and a 64-bit G component in bytes 8..15.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R64G64B64UInt">
            <summary>
            <para>
            ename:VK_FORMAT_R64G64B64_UINT:: A three-component, 192-bit unsigned integer format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, and a 64-bit B component in bytes 16..23.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R64G64B64SInt">
            <summary>
            <para>
            ename:VK_FORMAT_R64G64B64_SINT:: A three-component, 192-bit signed integer format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, and a 64-bit B component in bytes 16..23.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R64G64B64SFloat">
            <summary>
            <para>
            ename:VK_FORMAT_R64G64B64_SFLOAT:: A three-component, 192-bit signed floating-point format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, and a 64-bit B component in bytes 16..23.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R64G64B64A64UInt">
            <summary>
            <para>
            ename:VK_FORMAT_R64G64B64A64_UINT:: A four-component, 256-bit unsigned integer format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, a 64-bit B component in bytes 16..23, and a 64-bit A component in bytes 24..31.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R64G64B64A64SInt">
            <summary>
            <para>
            ename:VK_FORMAT_R64G64B64A64_SINT:: A four-component, 256-bit signed integer format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, a 64-bit B component in bytes 16..23, and a 64-bit A component in bytes 24..31.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.R64G64B64A64SFloat">
            <summary>
            <para>
            ename:VK_FORMAT_R64G64B64A64_SFLOAT:: A four-component, 256-bit signed floating-point format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, a 64-bit B component in bytes 16..23, and a 64-bit A component in bytes 24..31.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.B10G11R11UfloatPack32">
            <summary>
            <para>
            ename:VK_FORMAT_B10G11R11_UFLOAT_PACK32:: A three-component, 32-bit packed unsigned floating-point format that has a 10-bit B component in bits 22..31, an 11-bit G component in bits 11..21, an 11-bit R component in bits 0..10. See &lt;&lt;fundamentals-fp10&gt;&gt; and &lt;&lt;fundamentals-fp11&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.E5b9g9r9UfloatPack32">
            <summary>
            <para>
            ename:VK_FORMAT_E5B9G9R9_UFLOAT_PACK32:: A three-component, 32-bit packed unsigned floating-point format that has a 5-bit shared exponent in bits 27..31, a 9-bit B component mantissa in bits 18..26, a 9-bit G component mantissa in bits 9..17, and a 9-bit R component mantissa in bits 0..8.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.D16UNorm">
            <summary>
            <para>
            ename:VK_FORMAT_D16_UNORM:: A one-component, 16-bit unsigned normalized format that has a single 16-bit depth component.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.X8D24UNormPack32">
            <summary>
            <para>
            ename:VK_FORMAT_X8_D24_UNORM_PACK32:: A two-component, 32-bit format that has 24 unsigned normalized bits in the depth component and, optionally:, 8 bits that are unused.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.D32SFloat">
            <summary>
            <para>
            ename:VK_FORMAT_D32_SFLOAT:: A one-component, 32-bit signed floating-point format that has 32-bits in the depth component.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.S8UInt">
            <summary>
            <para>
            ename:VK_FORMAT_S8_UINT:: A one-component, 8-bit unsigned integer format that has 8-bits in the stencil component.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.D16UNormS8UInt">
            <summary>
            <para>
            ename:VK_FORMAT_D16_UNORM_S8_UINT:: A two-component, 24-bit format that has 16 unsigned normalized bits in the depth component and 8 unsigned integer bits in the stencil component.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.D24UNormS8UInt">
            <summary>
            <para>
            ename:VK_FORMAT_D24_UNORM_S8_UINT:: A two-component, 32-bit packed format that has 8 unsigned integer bits in the stencil component, and 24 unsigned normalized bits in the depth component.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.D32SFloatS8UInt">
            <summary>
            <para>
            ename:VK_FORMAT_D32_SFLOAT_S8_UINT:: A two-component format that has 32 signed float bits in the depth component and 8 unsigned integer bits in the stencil component. There are optionally: 24-bits that are unused.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc1RgbUNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_BC1_RGB_UNORM_BLOCK:: A three-component, block-compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data. This format has no alpha and is considered opaque.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc1RgbSrgbBlock">
            <summary>
            <para>
            ename:VK_FORMAT_BC1_RGB_SRGB_BLOCK:: A three-component, block-compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data with sRGB nonlinear encoding. This format has no alpha and is considered opaque.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc1RgbaUNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_BC1_RGBA_UNORM_BLOCK:: A four-component, block-compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data, and provides 1 bit of alpha.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc1RgbaSrgbBlock">
            <summary>
            <para>
            ename:VK_FORMAT_BC1_RGBA_SRGB_BLOCK:: A four-component, block-compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data with sRGB nonlinear encoding, and provides 1 bit of alpha.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc2UNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_BC2_UNORM_BLOCK:: A four-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc2SrgbBlock">
            <summary>
            <para>
            ename:VK_FORMAT_BC2_SRGB_BLOCK:: A four-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values with sRGB nonlinear encoding.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc3UNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_BC3_UNORM_BLOCK:: A four-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc3SrgbBlock">
            <summary>
            <para>
            ename:VK_FORMAT_BC3_SRGB_BLOCK:: A four-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values with sRGB nonlinear encoding.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc4UNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_BC4_UNORM_BLOCK:: A one-component, block-compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized red texel data.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc4SNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_BC4_SNORM_BLOCK:: A one-component, block-compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of signed normalized red texel data.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc5UNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_BC5_UNORM_BLOCK:: A two-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RG texel data with the first 64 bits encoding red values followed by 64 bits encoding green values.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc5SNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_BC5_SNORM_BLOCK:: A two-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of signed normalized RG texel data with the first 64 bits encoding red values followed by 64 bits encoding green values.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc6hUfloatBlock">
            <summary>
            <para>
            ename:VK_FORMAT_BC6H_UFLOAT_BLOCK:: A three-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned floating-point RGB texel data.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc6hSFloatBlock">
            <summary>
            <para>
            ename:VK_FORMAT_BC6H_SFLOAT_BLOCK:: A three-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of signed floating-point RGB texel data.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc7UNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_BC7_UNORM_BLOCK:: A four-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc7SrgbBlock">
            <summary>
            <para>
            ename:VK_FORMAT_BC7_SRGB_BLOCK:: A four-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Etc2R8G8B8UNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK:: A three-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data. This format has no alpha and is considered opaque.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Etc2R8G8B8SrgbBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK:: A three-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data with sRGB nonlinear encoding. This format has no alpha and is considered opaque.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Etc2R8G8B8A1UNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK:: A four-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data, and provides 1 bit of alpha.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Etc2R8G8B8A1SrgbBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK:: A four-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data with sRGB nonlinear encoding, and provides 1 bit of alpha.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Etc2R8G8B8A8UNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK:: A four-component, ETC2 compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Etc2R8G8B8A8SrgbBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK:: A four-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values with sRGB nonlinear encoding applied.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.EacR11UNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_EAC_R11_UNORM_BLOCK:: A one-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized red texel data.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.EacR11SNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_EAC_R11_SNORM_BLOCK:: A one-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of signed normalized red texel data.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.EacR11G11UNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_EAC_R11G11_UNORM_BLOCK:: A two-component, ETC2 compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RG texel data with the first 64 bits encoding red values followed by 64 bits encoding green values.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.EacR11G11SNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_EAC_R11G11_SNORM_BLOCK:: A two-component, ETC2 compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of signed normalized RG texel data with the first 64 bits encoding red values followed by 64 bits encoding green values.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc4x4UNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ASTC_4x4_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc4x4SrgbBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ASTC_4x4_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc5x4UNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ASTC_5x4_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 5x4 rectangle of unsigned normalized RGBA texel data.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc5x4SrgbBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ASTC_5x4_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 5x4 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc5x5UNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ASTC_5x5_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 5x5 rectangle of unsigned normalized RGBA texel data.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc5x5SrgbBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ASTC_5x5_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 5x5 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc6x5UNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ASTC_6x5_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 6x5 rectangle of unsigned normalized RGBA texel data.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc6x5SrgbBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ASTC_6x5_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 6x5 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc6x6UNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ASTC_6x6_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 6x6 rectangle of unsigned normalized RGBA texel data.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc6x6SrgbBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ASTC_6x6_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 6x6 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc8x5UNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ASTC_8x5_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8x5 rectangle of unsigned normalized RGBA texel data.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc8x5SrgbBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ASTC_8x5_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8x5 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc8x6UNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ASTC_8x6_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8x6 rectangle of unsigned normalized RGBA texel data.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc8x6SrgbBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ASTC_8x6_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8x6 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc8x8UNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ASTC_8x8_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8x8 rectangle of unsigned normalized RGBA texel data.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc8x8SrgbBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ASTC_8x8_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8x8 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc10x5UNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ASTC_10x5_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x5 rectangle of unsigned normalized RGBA texel data.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc10x5SrgbBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ASTC_10x5_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x5 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc10x6UNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ASTC_10x6_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x6 rectangle of unsigned normalized RGBA texel data.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc10x6SrgbBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ASTC_10x6_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x6 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc10x8UNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ASTC_10x8_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x8 rectangle of unsigned normalized RGBA texel data.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc10x8SrgbBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ASTC_10x8_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x8 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc10x10UNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ASTC_10x10_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x10 rectangle of unsigned normalized RGBA texel data.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc10x10SrgbBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ASTC_10x10_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x10 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc12x10UNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ASTC_12x10_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 12x10 rectangle of unsigned normalized RGBA texel data.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc12x10SrgbBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ASTC_12x10_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 12x10 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc12x12UNormBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ASTC_12x12_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 12x12 rectangle of unsigned normalized RGBA texel data.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc12x12SrgbBlock">
            <summary>
            <para>
            ename:VK_FORMAT_ASTC_12x12_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 12x12 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Pvrtc12bppUNormBlockImg">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Pvrtc14bppUNormBlockImg">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Pvrtc22bppUNormBlockImg">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Pvrtc24bppUNormBlockImg">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Pvrtc12bppSrgbBlockImg">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Pvrtc14bppSrgbBlockImg">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Pvrtc22bppSrgbBlockImg">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Format.Pvrtc24bppSrgbBlockImg">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.FrontFace">
            <summary>
            <para>
            Interpret polygon front-facing orientation.
            </para>
            <para>
            The first step of polygon rasterization is to determine whether the triangle is _back-facing_ or _front-facing_. This determination is made based on the sign of the (clipped or unclipped) polygon's area computed in framebuffer coordinates. One way to compute this area is:
            </para>
            <para>
            [latexmath] ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ \[ a = -{1 \over 2}\sum_{i=0}^{n-1} x_f^i y_f^{i \oplus 1} - x_f^{i \oplus 1} y_f^i \] ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            </para>
            <para>
            where latexmath:[$x_f^i$] and latexmath:[$y_f^i$] are the latexmath:[$x$] and latexmath:[$y$] framebuffer coordinates of the latexmath:[$i$]th vertex of the latexmath:[$n$]-vertex polygon (vertices are numbered starting at zero for the purposes of this computation) and latexmath:[$i \oplus 1$] is latexmath:[$(i + 1)~ \textrm{mod}~ n$].
            </para>
            <para>
            If pname:frontFace is set to ename:VK_FRONT_FACE_COUNTER_CLOCKWISE, a triangle with positive area is considered front-facing. If it is set to ename:VK_FRONT_FACE_CLOCKWISE, a triangle with negative area is considered front-facing. Any triangle which is not front-facing is back-facing, including zero-area triangles.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.FrontFace.CounterClockwise">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.FrontFace.Clockwise">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.ImageLayout">
            <summary>
            <para>
            Layout of image and image subresources.
            </para>
            <para>
            For each mechanism of accessing an image in the API, there is a parameter or structure member that controls the image layout used to access the image. For transfer commands, this is a parameter to the command (see &lt;&lt;clears&gt;&gt; and &lt;&lt;copies&gt;&gt;). For use as a framebuffer attachment, this is a member in the substructures of the sname:VkRenderPassCreateInfo (see &lt;&lt;renderpass,Render Pass&gt;&gt;). For use in a descriptor set, this is a member in the sname:VkDescriptorImageInfo structure (see &lt;&lt;descriptorsets-updates&gt;&gt;). At the time that any command buffer command accessing an image executes on any queue, the layouts of the image subresources that are accessed must: all match the layout specified via the API controlling those accesses.
            </para>
            <para>
            The image layout of each image subresource must: be well-defined at each point in the image subresource's lifetime. This means that when performing a layout transition on the image subresource, the old layout value must: either equal the current layout of the image subresource (at the time the transition executes), or else be ename:VK_IMAGE_LAYOUT_UNDEFINED (implying that the contents of the image subresource need not be preserved). The new layout used in a transition must: not be ename:VK_IMAGE_LAYOUT_UNDEFINED or ename:VK_IMAGE_LAYOUT_PREINITIALIZED.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageLayout.Undefined">
            <summary>
            <para>
            ename:VK_IMAGE_LAYOUT_UNDEFINED: Supports no device access. This layout must: only be used as the pname:initialLayout member of sname:VkImageCreateInfo or sname:VkAttachmentDescription, or as the pname:oldLayout in an image transition. When transitioning out of this layout, the contents of the memory are not guaranteed to be preserved.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageLayout.General">
            <summary>
            <para>
            ename:VK_IMAGE_LAYOUT_GENERAL: Supports all types of device access.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageLayout.ColorAttachmentOptimal">
            <summary>
            <para>
            ename:VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL: must: only be used as a color or resolve attachment in a sname:VkFramebuffer. This layout is valid only for image subresources of images created with the ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT usage bit enabled.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageLayout.DepthStencilAttachmentOptimal">
            <summary>
            <para>
            ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL: must: only be used as a depth/stencil attachment in a sname:VkFramebuffer. This layout is valid only for image subresources of images created with the ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT usage bit enabled.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageLayout.DepthStencilReadOnlyOptimal">
            <summary>
            <para>
            ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL: must: only be used as a read-only depth/stencil attachment in a sname:VkFramebuffer and/or as a read-only image in a shader (which can: be read as a sampled image, combined image/sampler and/or input attachment). This layout is valid only for image subresources of images created with the ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT usage bit enabled.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageLayout.ShaderReadOnlyOptimal">
            <summary>
            <para>
            ename:VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL: must: only be used as a read-only image in a shader (which can: be read as a sampled image, combined image/sampler and/or input attachment). This layout is valid only for image subresources of images created with the ename:VK_IMAGE_USAGE_SAMPLED_BIT or ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT usage bit enabled.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageLayout.TransferSourceOptimal">
            <summary>
            <para>
            ename:VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL: must: only be used as a source image of a transfer command (see the definition of &lt;&lt;synchronization-transfer,ename:VK_PIPELINE_STAGE_TRANSFER_BIT&gt;&gt;). This layout is valid only for image subresources of images created with the ename:VK_IMAGE_USAGE_TRANSFER_SRC_BIT usage bit enabled.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageLayout.TransferDestinationOptimal">
            <summary>
            <para>
            ename:VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL: must: only be used as a destination image of a transfer command. This layout is valid only for image subresources of images created with the ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT usage bit enabled. ifdef::VK_KHR_swapchain[]
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageLayout.Preinitialized">
            <summary>
            <para>
            ename:VK_IMAGE_LAYOUT_PREINITIALIZED: Supports no device access. This layout must: only be used as the pname:initialLayout member of sname:VkImageCreateInfo or sname:VkAttachmentDescription, or as the pname:oldLayout in an image transition. When transitioning out of this layout, the contents of the memory are preserved. This layout is intended to be used as the initial layout for an image whose contents are written by the host, and hence the data can: be written to memory immediately, without first executing a layout transition. Currently, ename:VK_IMAGE_LAYOUT_PREINITIALIZED is only useful with ename:VK_IMAGE_TILING_LINEAR images because there is not a standard layout defined for ename:VK_IMAGE_TILING_OPTIMAL images.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageLayout.PresentSource">
            <summary>
            <para>
            ename:VK_IMAGE_LAYOUT_PRESENT_SRC_KHR: must: only be used for presenting a swapchain image for display. A swapchain's image must: be transitioned to this layout before calling flink:vkQueuePresentKHR, and must: be transitioned away from this layout after calling flink:vkAcquireNextImageKHR. endif::VK_KHR_swapchain[]
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.ImageTiling">
            <summary>
            <para>
            Specifies the tiling arrangement of data in an image.
            </para>
            <para>
            ename:VK_IMAGE_TILING_OPTIMAL specifies optimal tiling (texels are laid out in an implementation-dependent arrangement, for more optimal memory access), and ename:VK_IMAGE_TILING_LINEAR specifies linear tiling (texels are laid out in memory in row-major order, possibly with some padding on each row).
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageTiling.Optimal">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageTiling.Linear">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.ImageType">
            <summary>
            <para>
            Specifies the type of an image object.
            </para>
            <para>
            These values specify one-, two-, or three-dimensional images, respectively.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageType.Image1d">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageType.Image2d">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageType.Image3d">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.ImageViewType">
            <summary>
            <para>
            Image view types.
            </para>
            <para>
            The exact image view type is partially implicit, based on the image's type and sample count, as well as the view creation parameters as described in the &lt;&lt;resources-image-views-compatibility,table below&gt;&gt;. This table also shows which SPIR-V OpTypeImage Dim and Arrayed parameters correspond to each image view type.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageViewType.ImageView1d">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageViewType.ImageView2d">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageViewType.ImageView3d">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageViewType.Cube">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageViewType.ImageView1dArray">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageViewType.ImageView2dArray">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageViewType.CubeArray">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.IndexType">
            <summary>
            <para>
            Type of index buffer indices.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.IndexType.UInt16">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.IndexType.UInt32">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.InternalAllocationType">
            <summary>
            <para>
            Allocation type.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.InternalAllocationType.Executable">
            <summary>
            <para>
            ename:VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE - The allocation is intended for execution by the host.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.LogicOp">
            <summary>
            <para>
            Framebuffer logical operations.
            </para>
            <para>
            &lt;&lt;&lt;
            </para>
            <para>
            The logical operations supported by Vulkan are summarized in the following table in which
            </para>
            <para>
            * latexmath:[$\lnot$] is bitwise invert, * latexmath:[$\land$] is bitwise and, * latexmath:[$\lor$] is bitwise or, * latexmath:[$\oplus$] is bitwise exclusive or, * latexmath:[$s$] is the fragment's latexmath:[$R_{s0}, G_{s0}, B_{s0}$] or latexmath:[$A_{s0}$] component value for the fragment output corresponding to the color attachment being updated, and * latexmath:[$d$] is the color attachment's latexmath:[$R, G, B$] or latexmath:[$A$] component value:
            </para>
            <para>
            .Logical Operations [width="75%",options="header",align="center"] |==== |Mode                            | Operation |ename:VK_LOGIC_OP_CLEAR         | latexmath:[$0$] |ename:VK_LOGIC_OP_AND           | latexmath:[$s \land d$] |ename:VK_LOGIC_OP_AND_REVERSE   | latexmath:[$s \land \lnot d$] |ename:VK_LOGIC_OP_COPY          | latexmath:[$s$] |ename:VK_LOGIC_OP_AND_INVERTED  | latexmath:[$\lnot s \land d$] |ename:VK_LOGIC_OP_NO_OP         | latexmath:[$d$] |ename:VK_LOGIC_OP_XOR           | latexmath:[$s \oplus d$] |ename:VK_LOGIC_OP_OR            | latexmath:[$s \lor d$] |ename:VK_LOGIC_OP_NOR           | latexmath:[$\lnot (s \lor d)$] |ename:VK_LOGIC_OP_EQUIVALENT    | latexmath:[$\lnot (s \oplus d)$] |ename:VK_LOGIC_OP_INVERT        | latexmath:[$\lnot d$] |ename:VK_LOGIC_OP_OR_REVERSE    | latexmath:[$s \lor \lnot d$] |ename:VK_LOGIC_OP_COPY_INVERTED | latexmath:[$\lnot s$] |ename:VK_LOGIC_OP_OR_INVERTED   | latexmath:[$\lnot s \lor d$] |ename:VK_LOGIC_OP_NAND          | latexmath:[$\lnot (s \land d)$] |ename:VK_LOGIC_OP_SET           | all 1s |====
            </para>
            <para>
            The result of the logical operation is then written to the color attachment as controlled by the component write mask, described in &lt;&lt;framebuffer-blendoperations,Blend Operations&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.Clear">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.And">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.AndReverse">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.Copy">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.AndInverted">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.NoOp">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.Xor">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.Or">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.Nor">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.Equivalent">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.Invert">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.OrReverse">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.CopyInverted">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.OrInverted">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.Nand">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.Set">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PhysicalDeviceType">
            <summary>
            <para>
            Supported physical device types.
            </para>
            <para>
            The physical device type is advertised for informational purposes only, and does not directly affect the operation of the system. However, the device type may: correlate with other advertised properties or capabilities of the system, such as how many memory heaps there are.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceType.Other">
            <summary>
            <para>
            ename:VK_PHYSICAL_DEVICE_TYPE_OTHER The device does not match any other available types.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceType.IntegratedGpu">
            <summary>
            <para>
            ename:VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU The device is typically one embedded in or tightly coupled with the host.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceType.DiscreteGpu">
            <summary>
            <para>
            ename:VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU The device is typically a separate processor connected to the host via an interlink.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceType.VirtualGpu">
            <summary>
            <para>
            ename:VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU The device is typically a virtual node in a virtualization environment.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceType.Cpu">
            <summary>
            <para>
            ename:VK_PHYSICAL_DEVICE_TYPE_CPU The device is typically running on the same processors as the host.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PipelineBindPoint">
            <summary>
            <para>
            Specify the bind point of a pipeline object to a command buffer.
            </para>
            <para>
            Once bound, a pipeline binding affects subsequent graphics or compute commands in the command buffer until a different pipeline is bound to the bind point. The pipeline bound to ename:VK_PIPELINE_BIND_POINT_COMPUTE controls the behavior of flink:vkCmdDispatch and flink:vkCmdDispatchIndirect. The pipeline bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS controls the behavior of flink:vkCmdDraw, flink:vkCmdDrawIndexed, flink:vkCmdDrawIndirect, and flink:vkCmdDrawIndexedIndirect. No other commands are affected by the pipeline state.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineBindPoint.Graphics">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineBindPoint.Compute">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PipelineCacheHeaderVersion">
            <summary>
            <para>
            Encode pipeline cache version.
            </para>
            <para>
            A consumer of the pipeline cache should: use the cache version to interpret the remainder of the cache header.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineCacheHeaderVersion.One">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PolygonMode">
            <summary>
            <para>
            Control polygon rasterization mode.
            </para>
            <para>
            The pname:polygonMode selects which method of rasterization is used for polygons. If pname:polygonMode is ename:VK_POLYGON_MODE_POINT, then the vertices of polygons are treated, for rasterization purposes, as if they had been drawn as points. ename:VK_POLYGON_MODE_LINE causes polygon edges to be drawn as line segments. ename:VK_POLYGON_MODE_FILL causes polygons to render using the polygon rasterization rules in this section.
            </para>
            <para>
            Note that these modes affect only the final rasterization of polygons: in particular, a polygon's vertices are shaded and the polygon is clipped and possibly culled before these modes are applied.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PolygonMode.Fill">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PolygonMode.Line">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PolygonMode.Point">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PresentMode">
            <summary>
            <para>
            Presentation mode supported for a surface.
            </para>
            <para>
            [NOTE] .Note ==== For reference, the mode indicated by ename:VK_PRESENT_MODE_FIFO_KHR is equivalent to the behavior of {wgl|glX|egl}SwapBuffers with a swap interval of 1, while the mode indicated by ename:VK_PRESENT_MODE_FIFO_RELAXED_KHR is equivalent to the behavior of {wgl|glX}SwapBuffers with a swap interval of -1 (from the {WGL|GLX}_EXT_swap_control_tear extensions). ====
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PresentMode.Immediate">
            <summary>
            <para>
            ename:VK_PRESENT_MODE_IMMEDIATE_KHR: The presentation engine does not wait for a vertical blanking period to update the current image, meaning this mode may: result in visible tearing. No internal queuing of presentation requests is needed, as the requests are applied immediately.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PresentMode.Mailbox">
            <summary>
            <para>
            ename:VK_PRESENT_MODE_MAILBOX_KHR: The presentation engine waits for the next vertical blanking period to update the current image. Tearing cannot: be observed. An internal single-entry queue is used to hold pending presentation requests. If the queue is full when a new presentation request is received, the new request replaces the existing entry, and any images associated with the prior entry become available for re-use by the application. One request is removed from the queue and processed during each vertical blanking period in which the queue is non-empty.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PresentMode.Fifo">
            <summary>
            <para>
            ename:VK_PRESENT_MODE_FIFO_KHR: The presentation engine waits for the next vertical blanking period to update the current image. Tearing cannot: be observed. An internal queue is used to hold pending presentation requests. New requests are appended to the end of the queue, and one request is removed from the beginning of the queue and processed during each vertical blanking period in which the queue is non-empty. This is the only value of pname:presentMode that is required: to be supported.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PresentMode.FifoRelaxed">
            <summary>
            <para>
            ename:VK_PRESENT_MODE_FIFO_RELAXED_KHR: The presentation engine generally waits for the next vertical blanking period to update the current image. If a vertical blanking period has already passed since the last update of the current image then the presentation engine does not wait for another vertical blanking period for the update, meaning this mode may: result in visible tearing in this case. This mode is useful for reducing visual stutter with an application that will mostly present a new image before the next vertical blanking period, but may occasionally be late, and present a new image just after the next vertical blanking period. An internal queue is used to hold pending presentation requests. New requests are appended to the end of the queue, and one request is removed from the beginning of the queue and processed during or after each vertical blanking period in which the queue is non-empty.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PrimitiveTopology">
            <summary>
            <para>
            Supported primitive topologies.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PrimitiveTopology.PointList">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PrimitiveTopology.LineList">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PrimitiveTopology.LineStrip">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PrimitiveTopology.TriangleList">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PrimitiveTopology.TriangleStrip">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PrimitiveTopology.TriangleFan">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PrimitiveTopology.LineListWithAdjacency">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PrimitiveTopology.LineStripWithAdjacency">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PrimitiveTopology.TriangleListWithAdjacency">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PrimitiveTopology.TriangleStripWithAdjacency">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PrimitiveTopology.PatchList">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.QueryType">
            <summary>
            <para>
            Specify the type of queries managed by a query pool.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueryType.Occlusion">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueryType.PipelineStatistics">
            <summary>
            <para>
            Optional
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueryType.Timestamp">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.RasterizationOrder">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.RasterizationOrder.Strict">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.RasterizationOrder.Relaxed">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Result">
            <summary>
            <para>
            Vulkan command return codes.
            </para>
            <para>
            While the core Vulkan API is not designed to capture incorrect usage, some circumstances still require return codes. Commands in Vulkan return their status via return codes that are in one of two categories:
            </para>
            <para>
            * Successful completion codes are returned when a command needs to communicate success or status information. All successful completion codes are non-negative values. * Run time error codes are returned when a command needs to communicate a failure that could only be detected at run time. All run time error codes are negative values.
            </para>
            <para>
            .Success Codes * ename:VK_SUCCESS Command successfully completed * ename:VK_NOT_READY A fence or query has not yet completed * ename:VK_TIMEOUT A wait operation has not completed in the specified time * ename:VK_EVENT_SET An event is signaled * ename:VK_EVENT_RESET An event is unsignaled * ename:VK_INCOMPLETE A return array was too small for the result ifdef::VK_KHR_swapchain[] * ename:VK_SUBOPTIMAL_KHR A swapchain no longer matches the surface properties exactly, but can: still be used to present to the surface successfully. endif::VK_KHR_swapchain[]
            </para>
            <para>
            .Error codes * ename:VK_ERROR_OUT_OF_HOST_MEMORY A host memory allocation has failed. * ename:VK_ERROR_OUT_OF_DEVICE_MEMORY A device memory allocation has failed. * ename:VK_ERROR_INITIALIZATION_FAILED Initialization of an object could not be completed for implementation-specific reasons. * ename:VK_ERROR_DEVICE_LOST The logical or physical device has been lost. See &lt;&lt;devsandqueues-lost-device,Lost Device&gt;&gt; * ename:VK_ERROR_MEMORY_MAP_FAILED Mapping of a memory object has failed. * ename:VK_ERROR_LAYER_NOT_PRESENT A requested layer is not present or could not be loaded. * ename:VK_ERROR_EXTENSION_NOT_PRESENT A requested extension is not supported. * ename:VK_ERROR_FEATURE_NOT_PRESENT A requested feature is not supported. * ename:VK_ERROR_INCOMPATIBLE_DRIVER The requested version of Vulkan is not supported by the driver or is otherwise incompatible for implementation-specific reasons. * ename:VK_ERROR_TOO_MANY_OBJECTS Too many objects of the type have already been created. * ename:VK_ERROR_FORMAT_NOT_SUPPORTED A requested format is not supported on this device. * ename:VK_ERROR_FRAGMENTED_POOL A requested pool allocation has failed due to fragmentation of the pool's memory. ifdef::VK_KHR_surface[] * ename:VK_ERROR_SURFACE_LOST_KHR A surface is no longer available. * ename:VK_ERROR_NATIVE_WINDOW_IN_USE_KHR The requested window is already connected to a VkSurfaceKHR, or to some other non-Vulkan API. endif::VK_KHR_surface[] ifdef::VK_KHR_swapchain[] * ename:VK_ERROR_OUT_OF_DATE_KHR A surface has changed in such a way that it is no longer compatible with the swapchain, and further presentation requests using the swapchain will fail. Applications must: query the new surface properties and recreate their swapchain if they wish to continue presenting to the surface. endif::VK_KHR_swapchain[] ifdef::VK_KHR_display_swapchain[] * ename:VK_ERROR_INCOMPATIBLE_DISPLAY_KHR The display used by a swapchain does not use the same presentable image layout, or is incompatible in a way that prevents sharing an image. endif::VK_KHR_display_swapchain[] ifdef::VK_NV_glsl_shader[] * ename:VK_ERROR_INVALID_SHADER_NV One or more shaders failed to compile or link. More details are reported back to the application via +VK_EXT_debug_report+ if enabled. endif::VK_NV_glsl_shader[]
            </para>
            <para>
            If a command returns a run time error, it will leave any result pointers unmodified, unless other behavior is explicitly defined in the specification.
            </para>
            <para>
            Out of memory errors do not damage any currently existing Vulkan objects. Objects that have already been successfully created can: still be used by the application.
            </para>
            <para>
            Performance-critical commands generally do not have return codes. If a run time error occurs in such commands, the implementation will defer reporting the error until a specified point. For commands that record into command buffers (ftext:vkCmd*) run time errors are reported by fname:vkEndCommandBuffer.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Result.Success">
            <summary>
            <para>
            Command completed successfully
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Result.NotReady">
            <summary>
            <para>
            A fence or query has not yet completed
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Result.Timeout">
            <summary>
            <para>
            A wait operation has not completed in the specified time
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Result.EventSet">
            <summary>
            <para>
            An event is signaled
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Result.EventReset">
            <summary>
            <para>
            An event is unsignaled
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Result.Incomplete">
            <summary>
            <para>
            A return array was too small for the result
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorOutOfHostMemory">
            <summary>
            <para>
            A host memory allocation has failed
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorOutOfDeviceMemory">
            <summary>
            <para>
            A device memory allocation has failed
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorInitializationFailed">
            <summary>
            <para>
            Initialization of a object has failed
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorDeviceLost">
            <summary>
            <para>
            The logical device has been lost. See &lt;&lt;devsandqueues-lost-device&gt;&gt;
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorMemoryMapFailed">
            <summary>
            <para>
            Mapping of a memory object has failed
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorLayerNotPresent">
            <summary>
            <para>
            Layer specified does not exist
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorExtensionNotPresent">
            <summary>
            <para>
            Extension specified does not exist
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorFeatureNotPresent">
            <summary>
            <para>
            Requested feature is not available on this device
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorIncompatibleDriver">
            <summary>
            <para>
            Unable to find a Vulkan driver
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorTooManyObjects">
            <summary>
            <para>
            Too many objects of the type have already been created
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorFormatNotSupported">
            <summary>
            <para>
            Requested format is not supported on this device
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorFragmentedPool">
            <summary>
            <para>
            A requested pool allocation has failed due to fragmentation of the pool's memory
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorSurfaceLost">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorNativeWindowInUse">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Result.Suboptimal">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorOutOfDate">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorIncompatibleDisplay">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorValidationFailed">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorInvalidShader">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.SamplerAddressMode">
            <summary>
            <para>
            Specify behavior of sampling with texture coordinates outside an image.
            </para>
            <para>
            The maximum number of sampler objects which can: be simultaneously created on a device is implementation-dependent and specified by the &lt;&lt;features-limits-maxSamplerAllocationCount,pname:maxSamplerAllocationCount&gt;&gt; member of the sname:VkPhysicalDeviceLimits structure. If pname:maxSamplerAllocationCount is exceeded, fname:vkCreateSampler will return ename:VK_ERROR_TOO_MANY_OBJECTS.
            </para>
            <para>
            Since sname:VkSampler is a non-dispatchable handle type, implementations may: return the same handle for sampler state vectors that are identical. In such cases, all such objects would only count once against the pname:maxSamplerAllocationCount limit.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SamplerAddressMode.Repeat">
            <summary>
            <para>
            ename:VK_SAMPLER_ADDRESS_MODE_REPEAT indicates that the repeat wrap mode will be used.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SamplerAddressMode.MirroredRepeat">
            <summary>
            <para>
            ename:VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT indicates that the mirrored repeat wrap mode will be used.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SamplerAddressMode.ClampToEdge">
            <summary>
            <para>
            ename:VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE indicates that the clamp to edge wrap mode will be used.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SamplerAddressMode.ClampToBorder">
            <summary>
            <para>
            ename:VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER indicates that the clamp to border wrap mode will be used.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SamplerAddressMode.MirrorClampToEdge">
            <summary>
            <para>
            ename:VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE indicates that the mirror clamp to edge wrap mode will be used. This is only valid if the +VK_KHR_mirror_clamp_to_edge+ extension is enabled.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.SamplerMipmapMode">
            <summary>
            <para>
            Specify mipmap mode used for texture lookups.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SamplerMipmapMode.Nearest">
            <summary>
            <para>
            Choose nearest mip level
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SamplerMipmapMode.Linear">
            <summary>
            <para>
            Linear filter between mip levels
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.SharingMode">
            <summary>
            <para>
            Buffer and image sharing modes.
            </para>
            <para>
            [NOTE] .Note ==== ename:VK_SHARING_MODE_CONCURRENT may: result in lower performance access to the buffer or image than ename:VK_SHARING_MODE_EXCLUSIVE. ====
            </para>
            <para>
            Ranges of buffers and image subresources of image objects created using ename:VK_SHARING_MODE_EXCLUSIVE must: only be accessed by queues in the same queue family at any given time. In order for a different queue family to be able to interpret the memory contents of a range or image subresource, the application must: transfer exclusive ownership of the range or image subresource between the source and destination queue families with the following sequence of operations:
            </para>
            <para>
            . Release exclusive ownership from the source queue family to the destination queue family. . Use semaphores to ensure proper execution control for the ownership transfer. . Acquire exclusive ownership for the destination queue family from the source queue family.
            </para>
            <para>
            To release exclusive ownership of a range of a buffer or image subresource of an image object, the application must: execute a buffer or image memory barrier, respectively (see slink:VkBufferMemoryBarrier and slink:VkImageMemoryBarrier) on a queue from the source queue family. The pname:srcQueueFamilyIndex parameter of the barrier must: be set to the source queue family index, and the pname:dstQueueFamilyIndex parameter to the destination queue family index.
            </para>
            <para>
            To acquire exclusive ownership, the application must: execute the same buffer or image memory barrier (i.e. an identically defined instance of the slink:VkBufferMemoryBarrier or slink:VkImageMemoryBarrier structure that was used for the exclusive ownership release) on a queue from the destination queue family.
            </para>
            <para>
            Upon creation, resources using ename:VK_SHARING_MODE_EXCLUSIVE are not owned by any queue family. A buffer or image memory barrier is not required to acquire ownership when no queue family owns the resource - it is implicitly acquired upon first use within a queue. However, images still require a &lt;&lt;resources-image-layouts,layout transition&gt;&gt; from ename:VK_IMAGE_LAYOUT_UNDEFINED or ename:VK_IMAGE_LAYOUT_PREINITIALIZED before being used on the first queue. This layout transition can: either be accomplished by an image memory barrier or by use in a render pass instance.
            </para>
            <para>
            Once a queue family has used a range or image subresource of an ename:VK_SHARING_MODE_EXCLUSIVE resource, its contents are undefined to other queue families unless ownership is transferred. The contents may: also become undefined for other reasons, e.g. as a result of writes to an image subresource that aliases the same memory. A queue family can: take ownership of a range or image subresource without an ownership transfer in the same way as for a resource that was just created, however doing so means any contents written by other queue families or via incompatible aliases are undefined.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SharingMode.Exclusive">
            <summary>
            <para>
            ename:VK_SHARING_MODE_EXCLUSIVE specifies that access to any range or image subresource of the object will be exclusive to a single queue family at a time.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SharingMode.Concurrent">
            <summary>
            <para>
            ename:VK_SHARING_MODE_CONCURRENT specifies that concurrent access to any range or image subresource of the object from multiple queue families is supported.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.StencilOp">
            <summary>
            <para>
            Stencil comparison function.
            </para>
            <para>
            For purposes of increment and decrement, the stencil bits are considered as an unsigned integer.
            </para>
            <para>
            If the stencil test fails, the sample's coverage bit is cleared in the fragment. If there is no stencil framebuffer attachment, stencil modification cannot: occur, and it is as if the stencil tests always pass.
            </para>
            <para>
            If the stencil test passes, the pname:writeMask member of the slink:VkStencilOpState structures controls how the updated stencil value is written to the stencil framebuffer attachment.
            </para>
            <para>
            The least significant latexmath:[$s$] bits of pname:writeMask, where latexmath:[$s$] is the number of bits in the stencil framebuffer attachment, specify an integer mask. Where a latexmath:[$1$] appears in this mask, the corresponding bit in the stencil value in the depth/stencil attachment is written; where a latexmath:[$0$] appears, the bit is not written. The pname:writeMask value uses either the front-facing or back-facing state based on the facing-ness of the fragment. Fragments generated by front-facing primitives use the front mask and fragments generated by back-facing primitives use the back mask.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StencilOp.Keep">
            <summary>
            <para>
            ename:VK_STENCIL_OP_KEEP keeps the current value.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StencilOp.Zero">
            <summary>
            <para>
            ename:VK_STENCIL_OP_ZERO sets the value to 0.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StencilOp.Replace">
            <summary>
            <para>
            ename:VK_STENCIL_OP_REPLACE sets the value to pname:reference.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StencilOp.IncrementAndClamp">
            <summary>
            <para>
            ename:VK_STENCIL_OP_INCREMENT_AND_CLAMP increments the current value and clamps to the maximum representable unsigned value.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StencilOp.DecrementAndClamp">
            <summary>
            <para>
            ename:VK_STENCIL_OP_DECREMENT_AND_CLAMP decrements the current value and clamps to 0.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StencilOp.Invert">
            <summary>
            <para>
            ename:VK_STENCIL_OP_INVERT bitwise-inverts the current value.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StencilOp.IncrementAndWrap">
            <summary>
            <para>
            ename:VK_STENCIL_OP_INCREMENT_AND_WRAP increments the current value and wraps to 0 when the maximum value would have been exceeded.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StencilOp.DecrementAndWrap">
            <summary>
            <para>
            ename:VK_STENCIL_OP_DECREMENT_AND_WRAP decrements the current value and wraps to the maximum possible value when the value would go below 0.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.StructureType">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.ApplicationInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.InstanceCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DeviceQueueCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DeviceCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.SubmitInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.MemoryAllocateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.MappedMemoryRange">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.BindSparseInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.FenceCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.SemaphoreCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.EventCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.QueryPoolCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.BufferCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.BufferViewCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.ImageCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.ImageViewCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.ShaderModuleCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PipelineCacheCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PipelineShaderStageCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PipelineVertexInputStateCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PipelineInputAssemblyStateCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PipelineTessellationStateCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PipelineViewportStateCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PipelineRasterizationStateCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PipelineMultisampleStateCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PipelineDepthStencilStateCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PipelineColorBlendStateCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PipelineDynamicStateCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.GraphicsPipelineCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.ComputePipelineCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PipelineLayoutCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.SamplerCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DescriptorSetLayoutCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DescriptorPoolCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DescriptorSetAllocateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.WriteDescriptorSet">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.CopyDescriptorSet">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.FramebufferCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.RenderPassCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.CommandPoolCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.CommandBufferAllocateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.CommandBufferInheritanceInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.CommandBufferBeginInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.RenderPassBeginInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.BufferMemoryBarrier">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.ImageMemoryBarrier">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.MemoryBarrier">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.LoaderInstanceCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.LoaderDeviceCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.SwapchainCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PresentInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DisplayModeCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DisplaySurfaceCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DisplayPresentInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.XlibSurfaceCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.XcbSurfaceCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.WaylandSurfaceCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.MirSurfaceCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.AndroidSurfaceCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.Win32SurfaceCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DebugReportCallbackCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PipelineRasterizationStateRasterizationOrder">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DebugMarkerObjectNameInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DebugMarkerObjectTagInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DebugMarkerMarkerInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DedicatedAllocationImageCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DedicatedAllocationBufferCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DedicatedAllocationMemoryAllocateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.ExternalMemoryImageCreateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.ExportMemoryAllocateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.ImportMemoryWin32HandleInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.ExportMemoryWin32HandleInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.Win32KeyedMutexAcquireReleaseInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.ValidationFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.SubpassContents">
            <summary>
            <para>
            Specify how commands in the first subpass of a render pass are provided.
            </para>
            <para>
            After beginning a render pass instance, the command buffer is ready to record the commands for the first subpass of that render pass.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SubpassContents.Inline">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SubpassContents.SecondaryCommandBuffers">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.SystemAllocationScope">
            <summary>
            <para>
            Allocation scope.
            </para>
            <para>
            Most Vulkan commands operate on a single object, or there is a sole object that is being created or manipulated. When an allocation uses a scope of ename:VK_SYSTEM_ALLOCATION_SCOPE_OBJECT or ename:VK_SYSTEM_ALLOCATION_SCOPE_CACHE, the allocation is scoped to the object being created or manipulated.
            </para>
            <para>
            When an implementation requires host memory, it will make callbacks to the application using the most specific allocator and scope available:
            </para>
            <para>
            * If an allocation is scoped to the duration of a command, the allocator will use the ename:VK_SYSTEM_ALLOCATION_SCOPE_COMMAND scope. The most specific allocator available is used: if the object being created or manipulated has an allocator, that object's allocator will be used, else if the parent sname:VkDevice has an allocator it will be used, else if the parent sname:VkInstance has an allocator it will be used. Else, * If an allocation is associated with an object of type sname:VkPipelineCache, the allocator will use the ename:VK_SYSTEM_ALLOCATION_SCOPE_CACHE scope. The most specific allocator available is used (pipeline cache, else device, else instance). Else, * If an allocation is scoped to the lifetime of an object, that object is being created or manipulated by the command, and that object's type is not sname:VkDevice or sname:VkInstance, the allocator will use a scope of ename:VK_SYSTEM_ALLOCATION_SCOPE_OBJECT. The most specific allocator available is used (object, else device, else instance). Else, * If an allocation is scoped to the lifetime of a device, the allocator will use scope of ename:VK_SYSTEM_ALLOCATION_SCOPE_DEVICE. The most specific allocator available is used (device, else instance). Else, * If the allocation is scoped to the lifetime of an instance and the instance has an allocator, its allocator will be used with a scope of ename:VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE. * Otherwise an implementation will allocate memory through an alternative mechanism that is unspecified.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SystemAllocationScope.Command">
            <summary>
            <para>
            ename:VK_SYSTEM_ALLOCATION_SCOPE_COMMAND - The allocation is scoped to the duration of the Vulkan command.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SystemAllocationScope.Object">
            <summary>
            <para>
            ename:VK_SYSTEM_ALLOCATION_SCOPE_OBJECT - The allocation is scoped to the lifetime of the Vulkan object that is being created or used.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SystemAllocationScope.Cache">
            <summary>
            <para>
            ename:VK_SYSTEM_ALLOCATION_SCOPE_CACHE - The allocation is scoped to the lifetime of a sname:VkPipelineCache object.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SystemAllocationScope.Device">
            <summary>
            <para>
            ename:VK_SYSTEM_ALLOCATION_SCOPE_DEVICE - The allocation is scoped to the lifetime of the Vulkan device.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SystemAllocationScope.Instance">
            <summary>
            <para>
            ename:VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE - The allocation is scoped to the lifetime of the Vulkan instance.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.ValidationCheck">
            <summary>
            <para>
            Specify validation checks to disable.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ValidationCheck.All">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.VertexInputRate">
            <summary>
            <para>
            Specify rate at which vertex attributes are pulled from buffers.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.VertexInputRate.Vertex">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.VertexInputRate.Instance">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.MemUtil">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.MemUtil.SizeOf``1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:SharpVk.MemUtil.SizeOfCache`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:SharpVk.MemUtil.WriteToPtr``1(System.IntPtr,``0)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="dest"></param>
            <param name="value"></param>
        </member>
        <member name="M:SharpVk.MemUtil.WriteToPtr``1(System.IntPtr,``0[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="dest"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <param name="count"></param>
        </member>
        <member name="T:SharpVk.Spirv.OpCode">
            <summary>
            Represents the metadata for a SharpVk.Spirv.Op value.
            </summary>
        </member>
        <member name="P:SharpVk.Spirv.OpCode.Op">
            <summary>
            The SharpVk.Spirv.Op value described by this instance.
            </summary>
        </member>
        <member name="P:SharpVk.Spirv.OpCode.Operands">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.Lookup">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpNop">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpUndef">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSourceContinued">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSource">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSourceExtension">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpName">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpMemberName">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpString">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpLine">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpExtension">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpExtInstImport">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpExtInst">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpMemoryModel">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpEntryPoint">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpExecutionMode">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpCapability">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeVoid">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeBool">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeInt">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeFloat">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeVector">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeMatrix">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeImage">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeSampler">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeSampledImage">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeArray">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeRuntimeArray">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeStruct">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeOpaque">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypePointer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeFunction">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeEvent">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeDeviceEvent">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeReserveId">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeQueue">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypePipe">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeForwardPointer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpConstantTrue">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpConstantFalse">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpConstant">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpConstantComposite">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpConstantSampler">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpConstantNull">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSpecConstantTrue">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSpecConstantFalse">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSpecConstant">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSpecConstantComposite">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSpecConstantOp">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFunction">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFunctionParameter">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFunctionEnd">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFunctionCall">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpVariable">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageTexelPointer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpLoad">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpStore">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpCopyMemory">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpCopyMemorySized">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAccessChain">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpInBoundsAccessChain">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpPtrAccessChain">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpArrayLength">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGenericPtrMemSemantics">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpInBoundsPtrAccessChain">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpDecorate">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpMemberDecorate">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpDecorationGroup">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupDecorate">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupMemberDecorate">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpVectorExtractDynamic">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpVectorInsertDynamic">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpVectorShuffle">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpCompositeConstruct">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpCompositeExtract">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpCompositeInsert">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpCopyObject">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTranspose">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSampledImage">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSampleImplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSampleExplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSampleDrefImplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSampleDrefExplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSampleProjImplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSampleProjExplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSampleProjDrefImplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSampleProjDrefExplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageFetch">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageGather">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageDrefGather">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageRead">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageWrite">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImage">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageQueryFormat">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageQueryOrder">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageQuerySizeLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageQuerySize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageQueryLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageQueryLevels">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageQuerySamples">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpConvertFToU">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpConvertFToS">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpConvertSToF">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpConvertUToF">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpUConvert">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSConvert">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFConvert">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpQuantizeToF16">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpConvertPtrToU">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSatConvertSToU">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSatConvertUToS">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpConvertUToPtr">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpPtrCastToGeneric">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGenericCastToPtr">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGenericCastToPtrExplicit">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpBitcast">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSNegate">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFNegate">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpIAdd">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFAdd">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpISub">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFSub">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpIMul">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFMul">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpUDiv">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSDiv">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFDiv">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpUMod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSRem">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSMod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFRem">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFMod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpVectorTimesScalar">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpMatrixTimesScalar">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpVectorTimesMatrix">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpMatrixTimesVector">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpMatrixTimesMatrix">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpOuterProduct">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpDot">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpIAddCarry">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpISubBorrow">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpUMulExtended">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSMulExtended">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAny">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAll">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpIsNan">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpIsInf">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpIsFinite">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpIsNormal">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSignBitSet">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpLessOrGreater">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpOrdered">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpUnordered">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpLogicalEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpLogicalNotEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpLogicalOr">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpLogicalAnd">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpLogicalNot">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSelect">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpIEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpINotEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpUGreaterThan">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSGreaterThan">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpUGreaterThanEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSGreaterThanEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpULessThan">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSLessThan">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpULessThanEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSLessThanEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFOrdEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFUnordEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFOrdNotEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFUnordNotEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFOrdLessThan">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFUnordLessThan">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFOrdGreaterThan">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFUnordGreaterThan">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFOrdLessThanEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFUnordLessThanEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFOrdGreaterThanEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFUnordGreaterThanEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpShiftRightLogical">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpShiftRightArithmetic">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpShiftLeftLogical">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpBitwiseOr">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpBitwiseXor">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpBitwiseAnd">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpNot">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpBitFieldInsert">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpBitFieldSExtract">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpBitFieldUExtract">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpBitReverse">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpBitCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpDPdx">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpDPdy">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFwidth">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpDPdxFine">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpDPdyFine">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFwidthFine">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpDPdxCoarse">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpDPdyCoarse">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFwidthCoarse">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpEmitVertex">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpEndPrimitive">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpEmitStreamVertex">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpEndStreamPrimitive">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpControlBarrier">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpMemoryBarrier">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicLoad">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicStore">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicExchange">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicCompareExchange">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicCompareExchangeWeak">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicIIncrement">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicIDecrement">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicIAdd">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicISub">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicSMin">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicUMin">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicSMax">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicUMax">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicAnd">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicOr">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicXor">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpPhi">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpLoopMerge">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSelectionMerge">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpLabel">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpBranch">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpBranchConditional">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSwitch">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpKill">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpReturn">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpReturnValue">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpUnreachable">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpLifetimeStart">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpLifetimeStop">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupAsyncCopy">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupWaitEvents">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupAll">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupAny">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupBroadcast">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupIAdd">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupFAdd">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupFMin">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupUMin">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupSMin">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupFMax">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupUMax">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupSMax">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpReadPipe">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpWritePipe">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpReservedReadPipe">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpReservedWritePipe">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpReserveReadPipePackets">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpReserveWritePipePackets">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpCommitReadPipe">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpCommitWritePipe">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpIsValidReserveId">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGetNumPipePackets">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGetMaxPipePackets">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupReserveReadPipePackets">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupReserveWritePipePackets">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupCommitReadPipe">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupCommitWritePipe">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpEnqueueMarker">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpEnqueueKernel">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGetKernelNDrangeSubGroupCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGetKernelNDrangeMaxSubGroupSize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGetKernelWorkGroupSize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGetKernelPreferredWorkGroupSizeMultiple">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpRetainEvent">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpReleaseEvent">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpCreateUserEvent">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpIsValidEvent">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSetUserEventStatus">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpCaptureEventProfilingInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGetDefaultQueue">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpBuildNDRange">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSparseSampleImplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSparseSampleExplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSparseSampleDrefImplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSparseSampleDrefExplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSparseSampleProjImplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSparseSampleProjExplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSparseSampleProjDrefImplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSparseSampleProjDrefExplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSparseFetch">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSparseGather">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSparseDrefGather">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSparseTexelsResident">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpNoLine">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicFlagTestAndSet">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicFlagClear">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSparseRead">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSizeOf">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypePipeStorage">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpConstantPipeStorage">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpCreatePipeFromPipeStorage">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGetKernelLocalSizeForSubgroupCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGetKernelMaxNumSubgroups">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeNamedBarrier">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpNamedBarrierInitialize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpMemoryNamedBarrier">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpModuleProcessed">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.Operand">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Spirv.Operand.Kind">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Spirv.Operand.Quantifier">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Spirv.Operand.Name">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.Quantifier">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Quantifier.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Quantifier.Optional">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Quantifier.Multiple">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.OperandKind">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.ImageOperands">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.FPFastMathMode">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.SelectionControl">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.LoopControl">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.FunctionControl">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.MemorySemantics">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.MemoryAccess">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.KernelProfilingInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.SourceLanguage">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.ExecutionModel">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.AddressingModel">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.MemoryModel">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.ExecutionMode">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.StorageClass">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.Dim">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.SamplerAddressingMode">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.SamplerFilterMode">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.ImageFormat">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.ImageChannelOrder">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.ImageChannelDataType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.FPRoundingMode">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.LinkageType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.AccessQualifier">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.FunctionParameterAttribute">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.Decoration">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.BuiltIn">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.Scope">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.GroupOperation">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.KernelEnqueueFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.Capability">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.IdResultType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.IdResult">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.IdMemorySemantics">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.IdScope">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.IdRef">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.LiteralInteger">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.LiteralString">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.LiteralContextDependentNumber">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.LiteralExtInstInteger">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.LiteralSpecConstantOpInteger">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.PairLiteralIntegerIdRef">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.PairIdRefLiteralInteger">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.PairIdRefIdRef">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.SourceLanguage">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SourceLanguage.Unknown">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SourceLanguage.ESSL">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SourceLanguage.GLSL">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SourceLanguage.OpenCL_C">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SourceLanguage.OpenCL_CPP">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.ExecutionModel">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionModel.Vertex">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionModel.TessellationControl">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionModel.TessellationEvaluation">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionModel.Geometry">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionModel.Fragment">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionModel.GLCompute">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionModel.Kernel">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.AddressingModel">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.AddressingModel.Logical">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.AddressingModel.Physical32">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.AddressingModel.Physical64">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.MemoryModel">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemoryModel.Simple">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemoryModel.GLSL450">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemoryModel.OpenCL">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.ExecutionMode">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.Invocations">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.SpacingEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.SpacingFractionalEven">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.SpacingFractionalOdd">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.VertexOrderCw">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.VertexOrderCcw">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.PixelCenterInteger">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.OriginUpperLeft">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.OriginLowerLeft">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.EarlyFragmentTests">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.PointMode">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.Xfb">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.DepthReplacing">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.DepthGreater">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.DepthLess">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.DepthUnchanged">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.LocalSize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.LocalSizeHint">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.InputPoints">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.InputLines">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.InputLinesAdjacency">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.Triangles">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.InputTrianglesAdjacency">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.Quads">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.Isolines">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.OutputVertices">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.OutputPoints">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.OutputLineStrip">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.OutputTriangleStrip">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.VecTypeHint">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.ContractionOff">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.Initializer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.Finalizer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.SubgroupSize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.SubgroupsPerWorkgroup">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.StorageClass">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.StorageClass.UniformConstant">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.StorageClass.Input">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.StorageClass.Uniform">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.StorageClass.Output">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.StorageClass.Workgroup">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.StorageClass.CrossWorkgroup">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.StorageClass.Private">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.StorageClass.Function">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.StorageClass.Generic">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.StorageClass.PushConstant">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.StorageClass.AtomicCounter">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.StorageClass.Image">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.Dim">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Dim.Dim1D">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Dim.Dim2D">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Dim.Dim3D">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Dim.Cube">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Dim.Rect">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Dim.Buffer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Dim.SubpassData">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.SamplerAddressingMode">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SamplerAddressingMode.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SamplerAddressingMode.ClampToEdge">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SamplerAddressingMode.Clamp">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SamplerAddressingMode.Repeat">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SamplerAddressingMode.RepeatMirrored">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.SamplerFilterMode">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SamplerFilterMode.Nearest">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SamplerFilterMode.Linear">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.ImageFormat">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Unknown">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rgba32f">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rgba16f">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.R32f">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rgba8">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rgba8Snorm">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rg32f">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rg16f">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.R11fG11fB10f">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.R16f">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rgba16">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rgb10A2">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rg16">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rg8">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.R16">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.R8">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rgba16Snorm">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rg16Snorm">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rg8Snorm">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.R16Snorm">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.R8Snorm">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rgba32i">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rgba16i">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rgba8i">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.R32i">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rg32i">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rg16i">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rg8i">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.R16i">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.R8i">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rgba32ui">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rgba16ui">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rgba8ui">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.R32ui">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rgb10a2ui">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rg32ui">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rg16ui">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rg8ui">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.R16ui">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.R8ui">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.ImageChannelOrder">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.R">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.A">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.RG">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.RA">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.RGB">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.RGBA">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.BGRA">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.ARGB">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.Intensity">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.Luminance">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.Rx">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.RGx">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.RGBx">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.Depth">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.DepthStencil">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.sRGB">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.sRGBx">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.sRGBA">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.sBGRA">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.ABGR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.ImageChannelDataType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.SnormInt8">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.SnormInt16">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.UnormInt8">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.UnormInt16">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.UnormShort565">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.UnormShort555">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.UnormInt101010">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.SignedInt8">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.SignedInt16">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.SignedInt32">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.UnsignedInt8">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.UnsignedInt16">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.UnsignedInt32">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.HalfFloat">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.Float">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.UnormInt24">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.UnormInt101010_2">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.ImageOperands">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageOperands.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageOperands.Bias">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageOperands.Lod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageOperands.Grad">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageOperands.ConstOffset">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageOperands.Offset">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageOperands.ConstOffsets">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageOperands.Sample">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageOperands.MinLod">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.FPFastMathMode">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FPFastMathMode.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FPFastMathMode.NotNaN">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FPFastMathMode.NotInf">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FPFastMathMode.NSZ">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FPFastMathMode.AllowRecip">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FPFastMathMode.Fast">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.FPRoundingMode">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FPRoundingMode.RTE">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FPRoundingMode.RTZ">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FPRoundingMode.RTP">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FPRoundingMode.RTN">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.LinkageType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.LinkageType.Export">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.LinkageType.Import">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.AccessQualifier">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.AccessQualifier.ReadOnly">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.AccessQualifier.WriteOnly">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.AccessQualifier.ReadWrite">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.FunctionParameterAttribute">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FunctionParameterAttribute.Zext">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FunctionParameterAttribute.Sext">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FunctionParameterAttribute.ByVal">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FunctionParameterAttribute.Sret">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FunctionParameterAttribute.NoAlias">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FunctionParameterAttribute.NoCapture">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FunctionParameterAttribute.NoWrite">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FunctionParameterAttribute.NoReadWrite">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.Decoration">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.RelaxedPrecision">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.SpecId">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Block">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.BufferBlock">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.RowMajor">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.ColMajor">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.ArrayStride">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.MatrixStride">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.GLSLShared">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.GLSLPacked">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.CPacked">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.BuiltIn">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.NoPerspective">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Flat">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Patch">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Centroid">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Sample">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Invariant">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Restrict">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Aliased">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Volatile">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Constant">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Coherent">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.NonWritable">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.NonReadable">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Uniform">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.SaturatedConversion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Stream">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Location">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Component">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Index">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Binding">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.DescriptorSet">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Offset">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.XfbBuffer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.XfbStride">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.FuncParamAttr">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.FPRoundingMode">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.FPFastMathMode">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.LinkageAttributes">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.NoContraction">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.InputAttachmentIndex">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Alignment">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.MaxByteOffset">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.BuiltIn">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.Position">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.PointSize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.ClipDistance">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.CullDistance">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.VertexId">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.InstanceId">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.PrimitiveId">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.InvocationId">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.Layer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.ViewportIndex">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.TessLevelOuter">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.TessLevelInner">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.TessCoord">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.PatchVertices">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.FragCoord">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.PointCoord">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.FrontFacing">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.SampleId">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.SamplePosition">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.SampleMask">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.FragDepth">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.HelperInvocation">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.NumWorkgroups">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.WorkgroupSize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.WorkgroupId">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.LocalInvocationId">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.GlobalInvocationId">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.LocalInvocationIndex">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.WorkDim">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.GlobalSize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.EnqueuedWorkgroupSize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.GlobalOffset">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.GlobalLinearId">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.SubgroupSize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.SubgroupMaxSize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.NumSubgroups">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.NumEnqueuedSubgroups">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.SubgroupId">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.SubgroupLocalInvocationId">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.VertexIndex">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.InstanceIndex">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.SelectionControl">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SelectionControl.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SelectionControl.Flatten">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SelectionControl.DontFlatten">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.LoopControl">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.LoopControl.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.LoopControl.Unroll">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.LoopControl.DontUnroll">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.LoopControl.DependencyInfinite">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.LoopControl.DependencyLength">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.FunctionControl">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FunctionControl.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FunctionControl.Inline">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FunctionControl.DontInline">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FunctionControl.Pure">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FunctionControl.Const">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.MemorySemantics">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemorySemantics.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemorySemantics.Acquire">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemorySemantics.Release">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemorySemantics.AcquireRelease">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemorySemantics.SequentiallyConsistent">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemorySemantics.UniformMemory">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemorySemantics.SubgroupMemory">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemorySemantics.WorkgroupMemory">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemorySemantics.CrossWorkgroupMemory">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemorySemantics.AtomicCounterMemory">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemorySemantics.ImageMemory">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.MemoryAccess">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemoryAccess.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemoryAccess.Volatile">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemoryAccess.Aligned">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemoryAccess.Nontemporal">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.Scope">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Scope.CrossDevice">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Scope.Device">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Scope.Workgroup">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Scope.Subgroup">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Scope.Invocation">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.GroupOperation">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.GroupOperation.Reduce">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.GroupOperation.InclusiveScan">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.GroupOperation.ExclusiveScan">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.KernelEnqueueFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.KernelEnqueueFlags.NoWait">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.KernelEnqueueFlags.WaitKernel">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.KernelEnqueueFlags.WaitWorkGroup">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.KernelProfilingInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.KernelProfilingInfo.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.KernelProfilingInfo.CmdExecTime">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.Capability">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Matrix">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Shader">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Geometry">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Tessellation">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Addresses">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Linkage">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Kernel">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Vector16">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Float16Buffer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Float16">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Float64">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Int64">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Int64Atomics">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.ImageBasic">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.ImageReadWrite">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.ImageMipmap">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Pipes">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Groups">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.DeviceEnqueue">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.LiteralSampler">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.AtomicStorage">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Int16">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.TessellationPointSize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.GeometryPointSize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.ImageGatherExtended">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.StorageImageMultisample">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.UniformBufferArrayDynamicIndexing">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.SampledImageArrayDynamicIndexing">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.StorageBufferArrayDynamicIndexing">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.StorageImageArrayDynamicIndexing">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.ClipDistance">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.CullDistance">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.ImageCubeArray">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.SampleRateShading">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.ImageRect">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.SampledRect">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.GenericPointer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Int8">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.InputAttachment">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.SparseResidency">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.MinLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Sampled1D">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Image1D">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.SampledCubeArray">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.SampledBuffer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.ImageBuffer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.ImageMSArray">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.StorageImageExtendedFormats">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.ImageQuery">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.DerivativeControl">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.InterpolationFunction">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.TransformFeedback">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.GeometryStreams">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.StorageImageReadWithoutFormat">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.StorageImageWriteWithoutFormat">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.MultiViewport">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.SubgroupDispatch">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.NamedBarrier">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.PipeStorage">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.Op">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpNop">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpUndef">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSourceContinued">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSource">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSourceExtension">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpName">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpMemberName">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpString">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpLine">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpExtension">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpExtInstImport">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpExtInst">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpMemoryModel">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpEntryPoint">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpExecutionMode">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpCapability">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeVoid">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeBool">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeInt">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeFloat">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeVector">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeMatrix">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeImage">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeSampler">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeSampledImage">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeArray">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeRuntimeArray">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeStruct">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeOpaque">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypePointer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeFunction">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeEvent">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeDeviceEvent">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeReserveId">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeQueue">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypePipe">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeForwardPointer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpConstantTrue">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpConstantFalse">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpConstant">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpConstantComposite">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpConstantSampler">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpConstantNull">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSpecConstantTrue">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSpecConstantFalse">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSpecConstant">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSpecConstantComposite">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSpecConstantOp">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFunction">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFunctionParameter">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFunctionEnd">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFunctionCall">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpVariable">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageTexelPointer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpLoad">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpStore">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpCopyMemory">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpCopyMemorySized">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAccessChain">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpInBoundsAccessChain">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpPtrAccessChain">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpArrayLength">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGenericPtrMemSemantics">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpInBoundsPtrAccessChain">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpDecorate">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpMemberDecorate">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpDecorationGroup">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupDecorate">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupMemberDecorate">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpVectorExtractDynamic">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpVectorInsertDynamic">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpVectorShuffle">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpCompositeConstruct">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpCompositeExtract">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpCompositeInsert">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpCopyObject">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTranspose">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSampledImage">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSampleImplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSampleExplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSampleDrefImplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSampleDrefExplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSampleProjImplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSampleProjExplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSampleProjDrefImplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSampleProjDrefExplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageFetch">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageGather">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageDrefGather">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageRead">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageWrite">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImage">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageQueryFormat">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageQueryOrder">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageQuerySizeLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageQuerySize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageQueryLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageQueryLevels">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageQuerySamples">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpConvertFToU">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpConvertFToS">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpConvertSToF">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpConvertUToF">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpUConvert">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSConvert">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFConvert">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpQuantizeToF16">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpConvertPtrToU">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSatConvertSToU">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSatConvertUToS">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpConvertUToPtr">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpPtrCastToGeneric">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGenericCastToPtr">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGenericCastToPtrExplicit">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpBitcast">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSNegate">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFNegate">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpIAdd">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFAdd">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpISub">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFSub">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpIMul">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFMul">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpUDiv">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSDiv">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFDiv">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpUMod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSRem">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSMod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFRem">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFMod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpVectorTimesScalar">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpMatrixTimesScalar">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpVectorTimesMatrix">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpMatrixTimesVector">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpMatrixTimesMatrix">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpOuterProduct">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpDot">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpIAddCarry">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpISubBorrow">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpUMulExtended">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSMulExtended">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAny">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAll">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpIsNan">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpIsInf">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpIsFinite">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpIsNormal">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSignBitSet">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpLessOrGreater">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpOrdered">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpUnordered">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpLogicalEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpLogicalNotEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpLogicalOr">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpLogicalAnd">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpLogicalNot">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSelect">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpIEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpINotEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpUGreaterThan">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSGreaterThan">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpUGreaterThanEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSGreaterThanEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpULessThan">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSLessThan">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpULessThanEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSLessThanEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFOrdEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFUnordEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFOrdNotEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFUnordNotEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFOrdLessThan">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFUnordLessThan">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFOrdGreaterThan">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFUnordGreaterThan">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFOrdLessThanEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFUnordLessThanEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFOrdGreaterThanEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFUnordGreaterThanEqual">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpShiftRightLogical">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpShiftRightArithmetic">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpShiftLeftLogical">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpBitwiseOr">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpBitwiseXor">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpBitwiseAnd">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpNot">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpBitFieldInsert">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpBitFieldSExtract">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpBitFieldUExtract">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpBitReverse">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpBitCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpDPdx">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpDPdy">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFwidth">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpDPdxFine">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpDPdyFine">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFwidthFine">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpDPdxCoarse">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpDPdyCoarse">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFwidthCoarse">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpEmitVertex">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpEndPrimitive">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpEmitStreamVertex">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpEndStreamPrimitive">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpControlBarrier">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpMemoryBarrier">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicLoad">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicStore">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicExchange">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicCompareExchange">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicCompareExchangeWeak">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicIIncrement">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicIDecrement">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicIAdd">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicISub">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicSMin">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicUMin">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicSMax">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicUMax">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicAnd">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicOr">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicXor">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpPhi">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpLoopMerge">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSelectionMerge">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpLabel">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpBranch">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpBranchConditional">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSwitch">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpKill">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpReturn">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpReturnValue">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpUnreachable">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpLifetimeStart">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpLifetimeStop">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupAsyncCopy">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupWaitEvents">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupAll">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupAny">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupBroadcast">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupIAdd">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupFAdd">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupFMin">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupUMin">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupSMin">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupFMax">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupUMax">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupSMax">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpReadPipe">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpWritePipe">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpReservedReadPipe">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpReservedWritePipe">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpReserveReadPipePackets">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpReserveWritePipePackets">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpCommitReadPipe">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpCommitWritePipe">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpIsValidReserveId">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGetNumPipePackets">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGetMaxPipePackets">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupReserveReadPipePackets">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupReserveWritePipePackets">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupCommitReadPipe">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupCommitWritePipe">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpEnqueueMarker">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpEnqueueKernel">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGetKernelNDrangeSubGroupCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGetKernelNDrangeMaxSubGroupSize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGetKernelWorkGroupSize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGetKernelPreferredWorkGroupSizeMultiple">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpRetainEvent">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpReleaseEvent">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpCreateUserEvent">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpIsValidEvent">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSetUserEventStatus">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpCaptureEventProfilingInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGetDefaultQueue">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpBuildNDRange">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSparseSampleImplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSparseSampleExplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSparseSampleDrefImplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSparseSampleDrefExplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSparseSampleProjImplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSparseSampleProjExplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSparseSampleProjDrefImplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSparseSampleProjDrefExplicitLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSparseFetch">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSparseGather">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSparseDrefGather">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSparseTexelsResident">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpNoLine">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicFlagTestAndSet">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicFlagClear">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSparseRead">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSizeOf">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypePipeStorage">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpConstantPipeStorage">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpCreatePipeFromPipeStorage">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGetKernelLocalSizeForSubgroupCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGetKernelMaxNumSubgroups">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeNamedBarrier">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpNamedBarrierInitialize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpMemoryNamedBarrier">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpModuleProcessed">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.ISpirvSink">
            <summary>
            Represents a target for outputing SPIR-V statements
            </summary>
        </member>
        <member name="M:SharpVk.Spirv.ISpirvSink.AddStatement(System.Nullable{SharpVk.Spirv.ResultId},SharpVk.Spirv.SpirvStatement)">
            <summary>
            Output the specified statement with an optional ResultID
            </summary>
            <param name="resultId">
            If not null; the ResultId representing the result of this
            statement.
            </param>
            <param name="statement">
            The SPIR-V statement to output to this sink instance.
            </param>
        </member>
        <member name="T:SharpVk.Spirv.SpirvSinkExtensions">
            <summary>
            Common overloads for ISpirvSink instances.
            </summary>
        </member>
        <member name="M:SharpVk.Spirv.SpirvSinkExtensions.AddStatement(SharpVk.Spirv.ISpirvSink,SharpVk.Spirv.SpirvStatement)">
            <summary>
            Output the specified statement
            </summary>
            <param name="sink">
            The sink to which to output the statement.
            </param>
            <param name="statement">
            The SPIR-V statement to output to this sink instance.
            </param>
        </member>
        <member name="M:SharpVk.Spirv.SpirvSinkExtensions.AddStatement(SharpVk.Spirv.ISpirvSink,SharpVk.Spirv.Op,System.Object[])">
            <summary>
            Output an SPIR-V statement with the specified opcode and operands
            arguments.
            </summary>
            <param name="sink">
            The sink to which to output the statement.
            </param>
            <param name="op">
            The opcode of the statement to output.
            </param>
            <param name="operands">
            A list of operand arguments to include in the output statement.
            </param>
        </member>
        <member name="M:SharpVk.Spirv.SpirvSinkExtensions.AddStatement(SharpVk.Spirv.ISpirvSink,SharpVk.Spirv.ResultId,SharpVk.Spirv.Op,System.Object[])">
            <summary>
            Output an SPIR-V statement with the specified opcode, ResultID and operands
            arguments.
            </summary>
            <param name="sink">
            The sink to which to output the statement.
            </param>
            <param name="resultId">
            A ResultId representing the result of this statement.
            </param>
            <param name="op">
            The opcode of the statement to output.
            </param>
            <param name="operands">
            A list of operand arguments to include in the output statement.
            </param>
        </member>
        <member name="T:SharpVk.Spirv.ResultId">
            <summary>
            Represents the unique ID value representing the result of an SPIR-V
            statement.
            </summary>
        </member>
        <member name="P:SharpVk.Spirv.ResultId.Id">
            <summary>
            The integer value of this ID value.
            </summary>
        </member>
        <member name="M:SharpVk.Spirv.ResultId.ToString">
            <summary>
            Returns a string value representing this ID value.
            </summary>
            <returns>
            A string value.
            </returns>
        </member>
        <member name="M:SharpVk.Spirv.ResultId.op_Implicit(System.Int32)~SharpVk.Spirv.ResultId">
            <summary>
            Implicit cast of an integer value to a ResultId.
            </summary>
            <param name="value">
            The unique integer value for this ID.
            </param>
        </member>
        <member name="T:SharpVk.Spirv.SpirvStatement">
            <summary>
            Represents a single line of a SPIR-V shader file.
            </summary>
        </member>
        <member name="M:SharpVk.Spirv.SpirvStatement.#ctor(SharpVk.Spirv.Op,System.Object[])">
            <summary>
            Create a new SPIR-V statement with the specified opcode &amp;
            operand arguments.
            </summary>
            <param name="op">
            The opcode for this statement.
            </param>
            <param name="operands">
            The arguments for any operands of the specified opcode.
            </param>
        </member>
        <member name="P:SharpVk.Spirv.SpirvStatement.Op">
            <summary>
            The Opcode for this statement.
            </summary>
        </member>
        <member name="P:SharpVk.Spirv.SpirvStatement.Operands">
            <summary>
            The operands arguments for this statement.
            </summary>
        </member>
        <member name="M:SharpVk.Spirv.SpirvStatement.ToString">
            <summary>
            Returns a string representation of this statement.
            </summary>
            <returns>
            A string representation of this statement.
            </returns>
        </member>
        <member name="M:SharpVk.Spirv.SpirvStatement.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal (by value) to this
            instance.
            </summary>
            <param name="obj">
            The object to which to compare.
            </param>
            <returns>
            True if the instances are equal by value; else false.
            </returns>
        </member>
        <member name="M:SharpVk.Spirv.SpirvStatement.GetHashCode">
            <summary>
            Returns a hashcode for the value of this instance.
            </summary>
            <returns>
            A 32-bit signed integer hash value.
            </returns>
        </member>
        <member name="M:SharpVk.Spirv.SpirvStatement.op_Equality(SharpVk.Spirv.SpirvStatement,SharpVk.Spirv.SpirvStatement)">
            <summary>
            Determines whether the specified objects are equal (by value).
            </summary>
            <param name="left">
            The first value to compare.
            </param>
            <param name="right">
            The second value to compare.
            </param>
            <returns>
            True if the instances are equal by value; else false.
            </returns>
        </member>
        <member name="M:SharpVk.Spirv.SpirvStatement.op_Inequality(SharpVk.Spirv.SpirvStatement,SharpVk.Spirv.SpirvStatement)">
            <summary>
            Determines whether the specified objects are not equal (by value).
            </summary>
            <param name="left">
            The first value to compare.
            </param>
            <param name="right">
            The second value to compare.
            </param>
            <returns>
            True if the instances are not equal by value; else false.
            </returns>
        </member>
        <member name="T:SharpVk.ClearColorValue">
            <summary>
            <para>
            Structure specifying a clear color value.
            </para>
            <para>
            The four array elements of the clear color map to R, G, B, and A components of image formats, in order.
            </para>
            <para>
            If the image has more than one sample, the same value is written to all samples for any pixels being cleared.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.ClearColorValue.op_Implicit(System.Single[])~SharpVk.ClearColorValue">
            <summary>
            Implicit conversion of float[] to ClearColorValue.
            </summary>
            <param name="float32">
            <para>
            pname:float32 are the color clear values when the format of the image or attachment is floating point, unorm, snorm, uscaled, packed float, or sRGB. Floating point values are automatically converted to the format of the image, with the clear value being treated as linear if the image is sRGB.
            </para>
            </param>
        </member>
        <member name="M:SharpVk.ClearColorValue.op_Implicit(System.Int32[])~SharpVk.ClearColorValue">
            <summary>
            Implicit conversion of int[] to ClearColorValue.
            </summary>
            <param name="int32">
            <para>
            pname:int32 are the color clear values when the format of the image or attachment is signed integer. Signed integer values are converted to the format of the image by casting to the smaller type (with negative 32-bit values mapping to negative values in the smaller type). If the integer clear value is not representable in the target type (e.g. would overflow in conversion to that type), the clear value is undefined.
            </para>
            </param>
        </member>
        <member name="M:SharpVk.ClearColorValue.op_Implicit(System.UInt32[])~SharpVk.ClearColorValue">
            <summary>
            Implicit conversion of uint[] to ClearColorValue.
            </summary>
            <param name="uInt32">
            <para>
            pname:uint32 are the color clear values when the format of the image or attachment is unsigned integer. Unsigned integer values are converted to the format of the image by casting to the integer type with fewer bits.
            </para>
            </param>
        </member>
        <member name="M:SharpVk.ClearColorValue.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.ClearColorValue.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.ClearColorValue.#ctor(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.ClearColorValue.op_Explicit(System.Numerics.Vector4)~SharpVk.ClearColorValue">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.ClearValue">
            <summary>
            <para>
            Structure specifying a clear value.
            </para>
            <para>
            This union is used where part of the API requires either color or depth/stencil clear values, depending on the attachment, and defines the initial clear values in the slink:VkRenderPassBeginInfo structure.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.ClearValue.op_Implicit(SharpVk.ClearColorValue)~SharpVk.ClearValue">
            <summary>
            Implicit converion of ClearColorValue to ClearValue.
            </summary>
        </member>
        <member name="M:SharpVk.ClearValue.op_Implicit(SharpVk.ClearDepthStencilValue)~SharpVk.ClearValue">
            <summary>
            Implicit converion of ClearDepthStencilValue to ClearValue.
            </summary>
        </member>
        <member name="T:SharpVk.SECURITY_ATTRIBUTES">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.SECURITY_ATTRIBUTES.nLength">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.SECURITY_ATTRIBUTES.lpSecurityDescriptor">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.SECURITY_ATTRIBUTES.bInheritHandle">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.SampleMask">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.SampleMask.op_Implicit(System.UInt32)~SharpVk.SampleMask">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.SampleMask.op_Implicit(SharpVk.SampleMask)~System.UInt32">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.SampleMask.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Bool32">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Bool32.#ctor(System.Boolean)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Bool32.op_Implicit(System.Boolean)~SharpVk.Bool32">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Bool32.op_Implicit(SharpVk.Bool32)~System.Boolean">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Bool32.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.DeviceSize">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.DeviceSize.op_Implicit(System.Int32)~SharpVk.DeviceSize">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.DeviceSize.op_Implicit(System.UInt64)~SharpVk.DeviceSize">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.DeviceSize.op_Implicit(SharpVk.DeviceSize)~System.UInt64">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.DeviceSize.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Size">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Size.op_Implicit(System.Int32)~SharpVk.Size">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Size.op_Implicit(System.UInt32)~SharpVk.Size">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Size.op_Implicit(System.UInt64)~SharpVk.Size">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Size.op_Explicit(SharpVk.Size)~System.UInt32">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Size.op_Explicit(SharpVk.Size)~System.UInt64">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Size.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ComponentMapping">
            <summary>
            <para>
            Structure specifying a color component mapping.
            </para>
            <para>
            Each of pname:r, pname:g, pname:b, and pname:a is one of the values:
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ComponentMapping.Identity">
            <summary>
            Returns a default ComponentMapping of Identity for all components.
            </summary>
        </member>
        <member name="F:SharpVk.ComponentMapping.R">
            <summary>
            <para>
            pname:r determines the component value placed in the R component of the output vector.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ComponentMapping.G">
            <summary>
            <para>
            pname:g determines the component value placed in the G component of the output vector.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ComponentMapping.B">
            <summary>
            <para>
            pname:b determines the component value placed in the B component of the output vector.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ComponentMapping.A">
            <summary>
            <para>
            pname:a determines the component value placed in the A component of the output vector.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.ComponentMapping.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.AttachmentDescription">
            <summary>
            <para>
            Structure specifying an attachment description.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentDescription.Flags">
            <summary>
            <para>
            pname:flags is a bitmask describing additional properties of the attachment. Bits which can: be set include: + --
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentDescription.Format">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentDescription.Samples">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentDescription.LoadOp">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentDescription.StoreOp">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentDescription.StencilLoadOp">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentDescription.StencilStoreOp">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentDescription.InitialLayout">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentDescription.FinalLayout">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.AttachmentDescription.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.AttachmentReference">
            <summary>
            <para>
            Structure specifying an attachment reference.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentReference.Attachment">
            <summary>
            <para>
            pname:attachment is the index of the attachment of the render pass, and corresponds to the index of the corresponding element in the pname:pAttachments array of the sname:VkRenderPassCreateInfo structure. If any color or depth/stencil attachments are ename:VK_ATTACHMENT_UNUSED, then no writes occur for those attachments.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentReference.Layout">
            <summary>
            <para>
            pname:layout is a elink:VkImageLayout value specifying the layout the attachment uses during the subpass. The implementation will automatically perform layout transitions as needed between subpasses to make each subpass use the requested layouts.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.AttachmentReference.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.BufferCopy">
            <summary>
            <para>
            Structure specifying a buffer copy operation.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BufferCopy.SourceOffset">
            <summary>
            <para>
            pname:srcOffset is the starting offset in bytes from the start of pname:srcBuffer.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BufferCopy.DestinationOffset">
            <summary>
            <para>
            pname:dstOffset is the starting offset in bytes from the start of pname:dstBuffer.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BufferCopy.Size">
            <summary>
            <para>
            pname:size is the number of bytes to copy.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.BufferCopy.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.BufferImageCopy">
            <summary>
            <para>
            Structure specifying a buffer image copy operation.
            </para>
            <para>
            When copying to or from a depth or stencil aspect, the data in buffer memory uses a layout that is a (mostly) tightly packed representation of the depth or stencil data. Specifically:
            </para>
            <para>
            * data copied to or from the stencil aspect of any depth/stencil format is tightly packed with one ename:VK_FORMAT_S8_UINT value per texel. * data copied to or from the depth aspect of a ename:VK_FORMAT_D16_UNORM or ename:VK_FORMAT_D16_UNORM_S8_UINT format is tightly packed with one ename:VK_FORMAT_D16_UNORM value per texel. * data copied to or from the depth aspect of a ename:VK_FORMAT_D32_SFLOAT or ename:VK_FORMAT_D32_SFLOAT_S8_UINT format is tightly packed with one ename:VK_FORMAT_D32_SFLOAT value per texel. * data copied to or from the depth aspect of a ename:VK_FORMAT_X8_D24_UNORM_PACK32 or ename:VK_FORMAT_D24_UNORM_S8_UINT format is packed with one 32-bit word per texel with the D24 value in the LSBs of the word, and undefined values in the eight MSBs.
            </para>
            <para>
            [NOTE] .Note ==== To copy both the depth and stencil aspects of a depth/stencil format, two entries in pname:pRegions can: be used, where one specifies the depth aspect in pname:imageSubresource, and the other specifies the stencil aspect. ====
            </para>
            <para>
            Because depth or stencil aspect buffer to image copies may: require format conversions on some implementations, they are not supported on queues that do not support graphics. When copying to a depth aspect, the data in buffer memory must: be in the the range latexmath:[$[0,1\]$] or undefined results occur.
            </para>
            <para>
            Copies are done layer by layer starting with image layer pname:baseArrayLayer member of pname:imageSubresource. pname:layerCount layers are copied from the source image or to the destination image.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BufferImageCopy.BufferOffset">
            <summary>
            <para>
            pname:bufferOffset is the offset in bytes from the start of the buffer object where the image data is copied from or to.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BufferImageCopy.BufferRowLength">
            <summary>
            <para>
            pname:bufferRowLength and pname:bufferImageHeight specify the data in buffer memory as a subregion of a larger two- or three-dimensional image, and control the addressing calculations of data in buffer memory. If either of these values is zero, that aspect of the buffer memory is considered to be tightly packed according to the pname:imageExtent.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BufferImageCopy.BufferImageHeight">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BufferImageCopy.ImageSubresource">
            <summary>
            <para>
            pname:imageSubresource is a slink:VkImageSubresourceLayers used to specify the specific image subresources of the image used for the source or destination image data.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BufferImageCopy.ImageOffset">
            <summary>
            <para>
            pname:imageOffset selects the initial x, y, z offsets in texels of the sub-region of the source or destination image data.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BufferImageCopy.ImageExtent">
            <summary>
            <para>
            pname:imageExtent is the size in texels of the image to copy in pname:width, pname:height and pname:depth. 1D images use only pname:x and pname:width. 2D images use pname:x, pname:y, pname:width and pname:height. 3D images use pname:x, pname:y, pname:z, pname:width, pname:height and pname:depth.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.BufferImageCopy.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ClearAttachment">
            <summary>
            <para>
            Structure specifying a clear attachment.
            </para>
            <para>
            No memory barriers are needed between fname:vkCmdClearAttachments and preceding or subsequent draw or attachment clear commands in the same subpass.
            </para>
            <para>
            The fname:vkCmdClearAttachments command is not affected by the bound pipeline state.
            </para>
            <para>
            Attachments can: also be cleared at the beginning of a render pass instance by setting pname:loadOp (or pname:stencilLoadOp) of slink:VkAttachmentDescription to ename:VK_ATTACHMENT_LOAD_OP_CLEAR, as described for flink:vkCreateRenderPass.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ClearAttachment.AspectMask">
            <summary>
            <para>
            pname:aspectMask is a mask selecting the color, depth and/or stencil aspects of the attachment to be cleared. pname:aspectMask can: include ename:VK_IMAGE_ASPECT_COLOR_BIT for color attachments, ename:VK_IMAGE_ASPECT_DEPTH_BIT for depth/stencil attachments with a depth component, and ename:VK_IMAGE_ASPECT_STENCIL_BIT for depth/stencil attachments with a stencil component. If the subpass's depth/stencil attachment is ename:VK_ATTACHMENT_UNUSED, then the clear has no effect.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ClearAttachment.ColorAttachment">
            <summary>
            <para>
            pname:colorAttachment is only meaningful if ename:VK_IMAGE_ASPECT_COLOR_BIT is set in pname:aspectMask, in which case it is an index to the pname:pColorAttachments array in the slink:VkSubpassDescription structure of the current subpass which selects the color attachment to clear. If pname:colorAttachment is ename:VK_ATTACHMENT_UNUSED then the clear has no effect.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ClearAttachment.ClearValue">
            <summary>
            <para>
            pname:clearValue is the color or depth/stencil value to clear the attachment to, as described in &lt;&lt;clears-values,Clear Values&gt;&gt; below.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.ClearAttachment.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ClearDepthStencilValue">
            <summary>
            <para>
            Structure specifying a clear depth stencil value.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ClearDepthStencilValue.Depth">
            <summary>
            <para>
            pname:depth is the clear value for the depth aspect of the depth/stencil attachment. It is a floating-point value which is automatically converted to the attachment's format.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ClearDepthStencilValue.Stencil">
            <summary>
            <para>
            pname:stencil is the clear value for the stencil aspect of the depth/stencil attachment. It is a 32-bit integer value which is converted to the attachment's format by taking the appropriate number of LSBs.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.ClearDepthStencilValue.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ClearRect">
            <summary>
            <para>
            Structure specifying a clear rectangle.
            </para>
            <para>
            The layers latexmath:[$[baseArrayLayer, baseArrayLayer+layerCount)$] counting from the base layer of the attachment image view are cleared.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ClearRect.Rect">
            <summary>
            <para>
            pname:rect is the two-dimensional region to be cleared.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ClearRect.BaseArrayLayer">
            <summary>
            <para>
            pname:baseArrayLayer is the first layer to be cleared.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ClearRect.LayerCount">
            <summary>
            <para>
            pname:layerCount is the number of layers to clear.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.ClearRect.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.DescriptorPoolSize">
            <summary>
            <para>
            Structure specifying descriptor pool size.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorPoolSize.Type">
            <summary>
            <para>
            pname:type is the type of descriptor.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorPoolSize.DescriptorCount">
            <summary>
            <para>
            pname:descriptorCount is the number of descriptors of that type to allocate.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.DescriptorPoolSize.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.DispatchIndirectCommand">
            <summary>
            <para>
            Structure specifying a dispatch indirect command.
            </para>
            <para>
            The members of sname:VkDispatchIndirectCommand structure have the same meaning as the similarly named parameters of flink:vkCmdDispatch.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DispatchIndirectCommand.X">
            <summary>
            <para>
            pname:x is the number of local workgroups to dispatch in the X dimension.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DispatchIndirectCommand.Y">
            <summary>
            <para>
            pname:y is the number of local workgroups to dispatch in the Y dimension.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DispatchIndirectCommand.Z">
            <summary>
            <para>
            pname:z is the number of local workgroups to dispatch in the Z dimension.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.DispatchIndirectCommand.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.DisplayModeParameters">
            <summary>
            <para>
            Structure describing display parameters associated with a display mode.
            </para>
            <para>
            [NOTE] .Note ==== For example, a 60Hz display mode would report a pname:refreshRate of 60,000. ====
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DisplayModeParameters.VisibleRegion">
            <summary>
            <para>
            pname:visibleRegion is the 2D extents of the visible region.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DisplayModeParameters.RefreshRate">
            <summary>
            <para>
            pname:refreshRate is a code:uint32_t that is the number of times the display is refreshed each second multiplied by 1000.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.DisplayModeParameters.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.DisplayPlaneCapabilities">
            <summary>
            <para>
            Structure describing capabilities of a mode and plane combination.
            </para>
            <para>
            The minimum and maximum position and extent fields describe the hardware limits, if any, as they apply to the specified display mode and plane. Vendors may: support displaying a subset of a swapchain's presentable images on the specified display plane. This is expressed by returning pname:minSrcPosition, pname:maxSrcPosition, pname:minSrcExtent, and pname:maxSrcExtent values that indicate a range of possible positions and sizes may: be used to specify the region within the presentable images that source pixels will be read from when creating a swapchain on the specified display mode and plane.
            </para>
            <para>
            Vendors may: also support mapping the presentable images' content to a subset or superset of the visible region in the specified display mode. This is expressed by returning pname:minDstPosition, pname:maxDstPosition, pname:minDstExtent and pname:maxDstExtent values that indicate a range of possible positions and sizes may: be used to describe the region within the display mode that the source pixels will be mapped to.
            </para>
            <para>
            Other vendors may: support only a 1-1 mapping between pixels in the presentable images and the display mode. This may: be indicated by returning (0,0) for pname:minSrcPosition, pname:maxSrcPosition, pname:minDstPosition, and pname:maxDstPosition, and (display mode width, display mode height) for pname:minSrcExtent, pname:maxSrcExtent, pname:minDstExtent, and pname:maxDstExtent.
            </para>
            <para>
            These values indicate the limits of the hardware's individual fields. Not all combinations of values within the offset and extent ranges returned in sname:VkDisplayPlaneCapabilitiesKHR are guaranteed to be supported. Vendors may: still fail presentation requests that specify unsupported combinations.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPlaneCapabilities.SupportedAlpha">
            <summary>
            <para>
            pname:supportedAlpha is a bitmask of elink:VkDisplayPlaneAlphaFlagBitsKHR describing the supported alpha blending modes.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPlaneCapabilities.MinSourcePosition">
            <summary>
            <para>
            pname:minSrcPosition is the minimum source rectangle offset supported by this plane using the specified mode.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPlaneCapabilities.MaxSourcePosition">
            <summary>
            <para>
            pname:maxSrcPosition is the maximum source rectangle offset supported by this plane using the specified mode. The pname:x and pname:y components of pname:maxSrcPosition must: each be greater than or equal to the pname:x and pname:y components of pname:minSrcPosition, respectively.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPlaneCapabilities.MinSourceExtent">
            <summary>
            <para>
            pname:minSrcExtent is the minimum source rectangle size supported by this plane using the specified mode.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPlaneCapabilities.MaxSourceExtent">
            <summary>
            <para>
            pname:maxSrcExtent is the maximum source rectangle size supported by this plane using the specified mode.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPlaneCapabilities.MinDestinationPosition">
            <summary>
            <para>
            pname:minDstPosition, pname:maxDstPosition, pname:minDstExtent, pname:maxDstExtent all have similar semantics to their corresponding "Src" equivalents, but apply to the output region within the mode rather than the input region within the source image. Unlike the "Src" offsets, pname:minDstPosition and pname:maxDstPosition may: contain negative values.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPlaneCapabilities.MaxDestinationPosition">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPlaneCapabilities.MinDestinationExtent">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPlaneCapabilities.MaxDestinationExtent">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.DisplayPlaneCapabilities.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.DrawIndexedIndirectCommand">
            <summary>
            <para>
            Structure specifying a draw indexed indirect command.
            </para>
            <para>
            The members of sname:VkDrawIndexedIndirectCommand have the same meaning as the similarly named parameters of flink:vkCmdDrawIndexed.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DrawIndexedIndirectCommand.IndexCount">
            <summary>
            <para>
            pname:indexCount is the number of vertices to draw.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DrawIndexedIndirectCommand.InstanceCount">
            <summary>
            <para>
            pname:instanceCount is the number of instances to draw.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DrawIndexedIndirectCommand.FirstIndex">
            <summary>
            <para>
            pname:firstIndex is the base index within the index buffer.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DrawIndexedIndirectCommand.VertexOffset">
            <summary>
            <para>
            pname:vertexOffset is the value added to the vertex index before indexing into the vertex buffer.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DrawIndexedIndirectCommand.FirstInstance">
            <summary>
            <para>
            pname:firstInstance is the instance ID of the first instance to draw.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.DrawIndexedIndirectCommand.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.DrawIndirectCommand">
            <summary>
            <para>
            Structure specifying a draw indirect command.
            </para>
            <para>
            The members of sname:VkDrawIndirectCommand have the same meaning as the similarly named parameters of flink:vkCmdDraw.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DrawIndirectCommand.VertexCount">
            <summary>
            <para>
            pname:vertexCount is the number of vertices to draw.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DrawIndirectCommand.InstanceCount">
            <summary>
            <para>
            pname:instanceCount is the number of instances to draw.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DrawIndirectCommand.FirstVertex">
            <summary>
            <para>
            pname:firstVertex is the index of the first vertex to draw.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DrawIndirectCommand.FirstInstance">
            <summary>
            <para>
            pname:firstInstance is the instance ID of the first instance to draw.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.DrawIndirectCommand.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Extent2D">
            <summary>
            <para>
            Structure specifying a two-dimensional extent.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Extent2D.Width">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Extent2D.Height">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Extent2D.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Extent3D">
            <summary>
            <para>
            Structure specifying a three-dimensional extent.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Extent3D.Width">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Extent3D.Height">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Extent3D.Depth">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Extent3D.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ExternalImageFormatProperties">
            <summary>
            <para>
            Structure specifying external image format properties.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ExternalImageFormatProperties.ImageFormatProperties">
            <summary>
            <para>
            pname:imageFormatProperties will be filled in as when calling flink:vkGetPhysicalDeviceImageFormatProperties, but the values returned may: vary depending on the external handle type requested.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ExternalImageFormatProperties.ExternalMemoryFeatures">
            <summary>
            <para>
            pname:externalMemoryFeatures is a bitmask of elink:VkExternalMemoryFeatureFlagBitsNV indicating properties of the external memory handle type (flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV::pname:externalHandleType) being queried, or 0 if the external memory handle type is 0.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ExternalImageFormatProperties.ExportFromImportedHandleTypes">
            <summary>
            <para>
            pname:exportFromImportedHandleTypes is a bitmask of elink:VkExternalMemoryHandleTypeFlagBitsNV containing a bit set for every external handle type that may: be used to create memory from which the handles of the type specified in flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV::pname:externalHandleType can: be exported, or 0 if the external memory handle type is 0.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ExternalImageFormatProperties.CompatibleHandleTypes">
            <summary>
            <para>
            pname:compatibleHandleTypes is a bitmask of elink:VkExternalMemoryHandleTypeFlagBitsNV containing a bit set for every external handle type that may: be specified simultaneously with the handle type specified by flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV::pname:externalHandleType when calling flink:vkAllocateMemory, or 0 if the external memory handle type is 0. pname:compatibleHandleTypes will always contain flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV::pname:externalHandleType
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.ExternalImageFormatProperties.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.FormatProperties">
            <summary>
            <para>
            Structure specifying image format properties.
            </para>
            <para>
            Supported features are described as a set of elink:VkFormatFeatureFlagBits:
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.FormatProperties.LinearTilingFeatures">
            <summary>
            <para>
            pname:linearTilingFeatures describes the features supported by ename:VK_IMAGE_TILING_LINEAR.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.FormatProperties.OptimalTilingFeatures">
            <summary>
            <para>
            pname:optimalTilingFeatures describes the features supported by ename:VK_IMAGE_TILING_OPTIMAL.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.FormatProperties.BufferFeatures">
            <summary>
            <para>
            pname:bufferFeatures describes the features supported by buffers.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.FormatProperties.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ImageCopy">
            <summary>
            <para>
            Structure specifying an image copy operation.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageCopy.SourceSubresource">
            <summary>
            <para>
            pname:srcSubresource and pname:dstSubresource are slink:VkImageSubresourceLayers structures specifying the image subresources of the images used for the source and destination image data, respectively.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageCopy.SourceOffset">
            <summary>
            <para>
            pname:srcOffset and pname:dstOffset select the initial x, y, and z offsets in texels of the sub-regions of the source and destination image data.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageCopy.DestinationSubresource">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageCopy.DestinationOffset">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageCopy.Extent">
            <summary>
            <para>
            pname:extent is the size in texels of the source image to copy in pname:width, pname:height and pname:depth. 1D images use only pname:x and pname:width. 2D images use pname:x, pname:y, pname:width and pname:height. 3D images use pname:x, pname:y, pname:z, pname:width, pname:height and pname:depth.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.ImageCopy.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ImageFormatProperties">
            <summary>
            <para>
            Structure specifying a image format properties.
            </para>
            <para>
            [NOTE] .Note ==== There is no mechanism to query the size of an image before creating it, to compare that size against pname:maxResourceSize. If an application attempts to create an image that exceeds this limit, the creation will fail or the image will be invalid. While the advertised limit must: be at least 2^31^, it may: not be possible to create an image that approaches that size, particularly for ename:VK_IMAGE_TYPE_1D. ====
            </para>
            <para>
            If the combination of parameters to fname:vkGetPhysicalDeviceImageFormatProperties is not supported by the implementation for use in flink:vkCreateImage, then all members of sname:VkImageFormatProperties will be filled with zero.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageFormatProperties.MaxExtent">
            <summary>
            <para>
            pname:maxExtent are the maximum image dimensions. See the &lt;&lt;features-extentperimagetype,Allowed Extent Values&gt;&gt; section below for how these values are constrained by pname:type.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageFormatProperties.MaxMipLevels">
            <summary>
            <para>
            pname:maxMipLevels is the maximum number of mipmap levels. pname:maxMipLevels must: either be equal to 1 (valid only if pname:tiling is ename:VK_IMAGE_TILING_LINEAR) or be equal to latexmath:[$\left\lceil\log_2(\max( \mathit{width},\mathit{height},\mathit{depth})) \right\rceil + 1$] where latexmath:[$\mathit{width}$], latexmath:[$\mathit{height}$], and latexmath:[$\mathit{depth}$] are taken from the corresponding members of pname:maxExtent.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageFormatProperties.MaxArrayLayers">
            <summary>
            <para>
            pname:maxArrayLayers is the maximum number of array layers. pname:maxArrayLayers must: either be equal to 1 or be greater than or equal to the pname:maxImageArrayLayers member of slink:VkPhysicalDeviceLimits. A value of 1 is valid only if pname:tiling is ename:VK_IMAGE_TILING_LINEAR or if pname:type is ename:VK_IMAGE_TYPE_3D.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageFormatProperties.SampleCounts">
            <summary>
            <para>
            pname:sampleCounts is a bitmask of elink:VkSampleCountFlagBits specifying all the supported sample counts for this image as described &lt;&lt;features-supported-sample-counts, below&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageFormatProperties.MaxResourceSize">
            <summary>
            <para>
            pname:maxResourceSize is an upper bound on the total image size in bytes, inclusive of all image subresources. Implementations may: have an address space limit on total size of a resource, which is advertised by this property. pname:maxResourceSize must: be at least 2^31^.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.ImageFormatProperties.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ImageResolve">
            <summary>
            <para>
            Structure specifying an image resolve operation.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageResolve.SourceSubresource">
            <summary>
            <para>
            pname:srcSubresource and pname:dstSubresource are slink:VkImageSubresourceLayers structures specifying the image subresources of the images used for the source and destination image data, respectively. Resolve of depth/stencil images is not supported.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageResolve.SourceOffset">
            <summary>
            <para>
            pname:srcOffset and pname:dstOffset select the initial x, y, and z offsets in texels of the sub-regions of the source and destination image data.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageResolve.DestinationSubresource">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageResolve.DestinationOffset">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageResolve.Extent">
            <summary>
            <para>
            pname:extent is the size in texels of the source image to resolve in pname:width, pname:height and pname:depth. 1D images use only pname:x and pname:width. 2D images use pname:x, pname:y, pname:width and pname:height. 3D images use pname:x, pname:y, pname:z, pname:width, pname:height and pname:depth.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.ImageResolve.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ImageSubresource">
            <summary>
            <para>
            Structure specifying a image subresource.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageSubresource.AspectMask">
            <summary>
            <para>
            pname:aspectMask is a elink:VkImageAspectFlags selecting the image _aspect_.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageSubresource.MipLevel">
            <summary>
            <para>
            pname:mipLevel selects the mipmap level.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageSubresource.ArrayLayer">
            <summary>
            <para>
            pname:arrayLayer selects the array layer.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.ImageSubresource.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ImageSubresourceLayers">
            <summary>
            <para>
            Structure specifying a image subresource layers.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageSubresourceLayers.AspectMask">
            <summary>
            <para>
            pname:aspectMask is a combination of elink:VkImageAspectFlagBits, selecting the color, depth and/or stencil aspects to be copied.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageSubresourceLayers.MipLevel">
            <summary>
            <para>
            pname:mipLevel is the mipmap level to copy from.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageSubresourceLayers.BaseArrayLayer">
            <summary>
            <para>
            pname:baseArrayLayer and pname:layerCount are the starting layer and number of layers to copy.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageSubresourceLayers.LayerCount">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.ImageSubresourceLayers.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ImageSubresourceRange">
            <summary>
            <para>
            Structure specifying a image subresource range.
            </para>
            <para>
            The number of mipmap levels and array layers must: be a subset of the image subresources in the image. If an application wants to use all mip levels or layers in an image after the pname:baseMipLevel or pname:baseArrayLayer, it can: set pname:levelCount and pname:layerCount to the special values ename:VK_REMAINING_MIP_LEVELS and ename:VK_REMAINING_ARRAY_LAYERS without knowing the exact number of mip levels or layers.
            </para>
            <para>
            For cube and cube array image views, the layers of the image view starting at pname:baseArrayLayer correspond to faces in the order +X, -X, +Y, -Y, +Z, -Z. For cube arrays, each set of six sequential layers is a single cube, so the number of cube maps in a cube map array view is _pname:layerCount / 6_, and image array layer _pname:baseArrayLayer + i_ is face index _i mod 6_ of cube _i / 6_. If the number of layers in the view, whether set explicitly in pname:layerCount or implied by ename:VK_REMAINING_ARRAY_LAYERS, is not a multiple of 6, behavior when indexing the last cube is undefined.
            </para>
            <para>
            pname:aspectMask is a bitmask indicating the format being used. Bits which may: be set include:
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageSubresourceRange.AspectMask">
            <summary>
            <para>
            pname:aspectMask is a bitmask indicating which aspect(s) of the image are included in the view. See elink:VkImageAspectFlagBits.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageSubresourceRange.BaseMipLevel">
            <summary>
            <para>
            pname:baseMipLevel is the first mipmap level accessible to the view.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageSubresourceRange.LevelCount">
            <summary>
            <para>
            pname:levelCount is the number of mipmap levels (starting from pname:baseMipLevel) accessible to the view.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageSubresourceRange.BaseArrayLayer">
            <summary>
            <para>
            pname:baseArrayLayer is the first array layer accessible to the view.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageSubresourceRange.LayerCount">
            <summary>
            <para>
            pname:layerCount is the number of array layers (starting from pname:baseArrayLayer) accessible to the view.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.ImageSubresourceRange.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.MemoryHeap">
            <summary>
            <para>
            Structure specifying a memory heap.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.MemoryHeap.Size">
            <summary>
            <para>
            pname:size is the total memory size in bytes in the heap.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.MemoryHeap.Flags">
            <summary>
            <para>
            pname:flags is a bitmask of attribute flags for the heap. The bits specified in pname:flags are: + --
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.MemoryHeap.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.MemoryRequirements">
            <summary>
            <para>
            Structure specifying memory requirements.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.MemoryRequirements.Size">
            <summary>
            <para>
            pname:size is the size, in bytes, of the memory allocation required: for the resource.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.MemoryRequirements.Alignment">
            <summary>
            <para>
            pname:alignment is the alignment, in bytes, of the offset within the allocation required: for the resource.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.MemoryRequirements.MemoryTypeBits">
            <summary>
            <para>
            pname:memoryTypeBits is a bitmask and contains one bit set for every supported memory type for the resource. Bit `i` is set if and only if the memory type `i` in the sname:VkPhysicalDeviceMemoryProperties structure for the physical device is supported for the resource.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.MemoryRequirements.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.MemoryType">
            <summary>
            <para>
            Structure specifying memory type.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.MemoryType.PropertyFlags">
            <summary>
            <para>
            pname:propertyFlags is a bitmask of properties for this memory type. The bits specified in pname:propertyFlags are: + --
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.MemoryType.HeapIndex">
            <summary>
            <para>
            pname:heapIndex describes which memory heap this memory type corresponds to, and must: be less than pname:memoryHeapCount from the sname:VkPhysicalDeviceMemoryProperties structure.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.MemoryType.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Offset2D">
            <summary>
            <para>
            Structure specifying a two-dimensional offset.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Offset2D.X">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Offset2D.Y">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Offset2D.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Offset3D">
            <summary>
            <para>
            Structure specifying a three-dimensional offset.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Offset3D.X">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Offset3D.Y">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Offset3D.Z">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Offset3D.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.PhysicalDeviceFeatures">
            <summary>
            <para>
            Structure describing the fine-grained features that can be supported by an implementation.
            </para>
            <para>
            The members of the sname:VkPhysicalDeviceFeatures structure describe the following features:
            </para>
            <para>
            *  pname:robustBufferAccess indicates that accesses to buffers are bounds-checked against the range of the buffer descriptor (as determined by sname:VkDescriptorBufferInfo::pname:range, sname:VkBufferViewCreateInfo::pname:range, or the size of the buffer). Out of bounds accesses must: not cause application termination, and the effects of shader loads, stores, and atomics must: conform to an implementation-dependent behavior as described below. ** A buffer access is considered to be out of bounds if any of the following are true: *** The pointer was formed by code:OpImageTexelPointer and the coordinate is less than zero or greater than or equal to the number of whole elements in the bound range. *** The pointer was not formed by code:OpImageTexelPointer and the object pointed to is not wholly contained within the bound range. + -- [NOTE] .Note ==== If a SPIR-V code:OpLoad instruction loads a structure and the tail end of the structure is out of bounds, then all members of the structure are considered out of bounds even if the members at the end are not statically used. ==== -- + *** If any buffer access in a given SPIR-V block is determined to be out of bounds, then any other access of the same type (load, store, or atomic) in the same SPIR-V block that accesses an address less than 16 bytes away from the out of bounds address may: also be considered out of bounds. ** Out-of-bounds buffer loads will return any of the following values: *** Values from anywhere within the memory range(s) bound to the buffer (possibly including bytes of memory past the end of the buffer, up to the end of the bound range). *** Zero values, or (0,0,0,x) vectors for vector reads where x is a valid value represented in the type of the vector components and may: be any of: **** 0, 1, or the maximum representable positive integer value, for signed or unsigned integer components **** 0.0 or 1.0, for floating-point components ** Out-of-bounds writes may: modify values within the memory range(s) bound to the buffer, but must: not modify any other memory. ** Out-of-bounds atomics may: modify values within the memory range(s) bound to the buffer, but must: not modify any other memory, and return an undefined value. ** Vertex input attributes are considered out of bounds if the address of the attribute plus the size of the attribute is greater than the size of the bound buffer. Further, if any vertex input attribute using a specific vertex input binding is out of bounds, then all vertex input attributes using that vertex input binding for that vertex shader invocation are considered out of bounds. *** If a vertex input attribute is out of bounds, it will be assigned one of the following values: **** Values from anywhere within the memory range(s) bound to the buffer, converted according to the format of the attribute. **** Zero values, format converted according to the format of the attribute. **** Zero values, or (0,0,0,x) vectors, as described above. ** If pname:robustBufferAccess is not enabled, out of bounds accesses may: corrupt any memory within the process and cause undefined behavior up to and including application termination. *  pname:fullDrawIndexUint32 indicates the full 32-bit range of indices is supported for indexed draw calls when using a elink:VkIndexType of ename:VK_INDEX_TYPE_UINT32. pname:maxDrawIndexedIndexValue is the maximum index value that may: be used (aside from the primitive restart index, which is always 2^32^-1 when the elink:VkIndexType is ename:VK_INDEX_TYPE_UINT32). If this feature is supported, pname:maxDrawIndexedIndexValue must: be 2^32^-1; otherwise it must: be no smaller than 2^24^-1. See &lt;&lt;features-limits-maxDrawIndexedIndexValue,maxDrawIndexedIndexValue&gt;&gt;. *  pname:imageCubeArray indicates whether image views with a elink:VkImageViewType of ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY can: be created, and that the corresponding code:SampledCubeArray and code:ImageCubeArray SPIR-V capabilities can: be used in shader code. *  pname:independentBlend indicates whether the sname:VkPipelineColorBlendAttachmentState settings are controlled independently per-attachment. If this feature is not enabled, the sname:VkPipelineColorBlendAttachmentState settings for all color attachments must: be identical. Otherwise, a different sname:VkPipelineColorBlendAttachmentState can: be provided for each bound color attachment. *  pname:geometryShader indicates whether geometry shaders are supported. If this feature is not enabled, the ename:VK_SHADER_STAGE_GEOMETRY_BIT and ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT enum values must: not be used. This also indicates whether shader modules can: declare the code:Geometry capability. *  pname:tessellationShader indicates whether tessellation control and evaluation shaders are supported. If this feature is not enabled, the ename:VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, ename:VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT, ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT, and ename:VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO enum values must: not be used. This also indicates whether shader modules can: declare the code:Tessellation capability. *  pname:sampleRateShading indicates whether per-sample shading and multisample interpolation are supported. If this feature is not enabled, the pname:sampleShadingEnable member of the sname:VkPipelineMultisampleStateCreateInfo structure must: be set to ename:VK_FALSE and the pname:minSampleShading member is ignored. This also indicates whether shader modules can: declare the code:SampleRateShading capability. *  pname:dualSrcBlend indicates whether blend operations which take two sources are supported. If this feature is not enabled, the ename:VK_BLEND_FACTOR_SRC1_COLOR, ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, ename:VK_BLEND_FACTOR_SRC1_ALPHA, and ename:VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA enum values must: not be used as source or destination blending factors. See &lt;&lt;framebuffer-dsb&gt;&gt;. *  pname:logicOp indicates whether logic operations are supported. If this feature is not enabled, the pname:logicOpEnable member of the sname:VkPipelineColorBlendStateCreateInfo structure must: be set to ename:VK_FALSE, and the pname:logicOp member is ignored. *  pname:multiDrawIndirect indicates whether multiple draw indirect is supported. If this feature is not enabled, the pname:drawCount parameter to the fname:vkCmdDrawIndirect and fname:vkCmdDrawIndexedIndirect commands must: be 0 or 1. The pname:maxDrawIndirectCount member of the sname:VkPhysicalDeviceLimits structure must: also be 1 if this feature is not supported. See &lt;&lt;features-limits-maxDrawIndirectCount,maxDrawIndirectCount&gt;&gt;. * pname:drawIndirectFirstInstance indicates whether indirect draw calls support the pname:firstInstance parameter. If this feature is not enabled, the pname:firstInstance member of all sname:VkDrawIndirectCommand and sname:VkDrawIndexedIndirectCommand structures that are provided to the fname:vkCmdDrawIndirect and fname:vkCmdDrawIndexedIndirect commands must: be 0. *  pname:depthClamp indicates whether depth clamping is supported. If this feature is not enabled, the pname:depthClampEnable member of the sname:VkPipelineRasterizationStateCreateInfo structure must: be set to ename:VK_FALSE. Otherwise, setting pname:depthClampEnable to ename:VK_TRUE will enable depth clamping. *  pname:depthBiasClamp indicates whether depth bias clamping is supported. If this feature is not enabled, the pname:depthBiasClamp member of the sname:VkPipelineRasterizationStateCreateInfo structure must: be set to 0.0 unless the ename:VK_DYNAMIC_STATE_DEPTH_BIAS dynamic state is enabled, and the pname:depthBiasClamp parameter to fname:vkCmdSetDepthBias must: be set to 0.0. *  pname:fillModeNonSolid indicates whether point and wireframe fill modes are supported. If this feature is not enabled, the ename:VK_POLYGON_MODE_POINT and ename:VK_POLYGON_MODE_LINE enum values must: not be used. *  pname:depthBounds indicates whether depth bounds tests are supported. If this feature is not enabled, the pname:depthBoundsTestEnable member of the sname:VkPipelineDepthStencilStateCreateInfo structure must: be set to ename:VK_FALSE. When pname:depthBoundsTestEnable is set to ename:VK_FALSE, the pname:minDepthBounds and pname:maxDepthBounds members of the sname:VkPipelineDepthStencilStateCreateInfo structure are ignored. *  pname:wideLines indicates whether lines with width other than 1.0 are supported. If this feature is not enabled, the pname:lineWidth member of the sname:VkPipelineRasterizationStateCreateInfo structure must: be set to 1.0 unless the ename:VK_DYNAMIC_STATE_LINE_WIDTH dynamic state is enabled, and the pname:lineWidth parameter to fname:vkCmdSetLineWidth must: be set to 1.0. When this feature is supported, the range and granularity of supported line widths are indicated by the pname:lineWidthRange and pname:lineWidthGranularity members of the sname:VkPhysicalDeviceLimits structure, respectively. *  pname:largePoints indicates whether points with size greater than 1.0 are supported. If this feature is not enabled, only a point size of 1.0 written by a shader is supported. The range and granularity of supported point sizes are indicated by the pname:pointSizeRange and pname:pointSizeGranularity members of the sname:VkPhysicalDeviceLimits structure, respectively. *  pname:alphaToOne indicates whether the implementation is able to replace the alpha value of the color fragment output from the fragment shader with the maximum representable alpha value for fixed-point colors or 1.0 for floating-point colors. If this feature is not enabled, then the pname:alphaToOneEnable member of the sname:VkPipelineMultisampleStateCreateInfo structure must: be set to ename:VK_FALSE. Otherwise setting pname:alphaToOneEnable to ename:VK_TRUE will enable alpha-to-one behavior. *  pname:multiViewport indicates whether more than one viewport is supported. If this feature is not enabled, the pname:viewportCount and pname:scissorCount members of the sname:VkPipelineViewportStateCreateInfo structure must: be set to 1. Similarly, the pname:viewportCount parameter to the fname:vkCmdSetViewport command and the pname:scissorCount parameter to the fname:vkCmdSetScissor command must: be 1, and the pname:firstViewport parameter to the fname:vkCmdSetViewport command and the pname:firstScissor parameter to the fname:vkCmdSetScissor command must: be 0. *  pname:samplerAnisotropy indicates whether anisotropic filtering is supported. If this feature is not enabled, the pname:maxAnisotropy member of the sname:VkSamplerCreateInfo structure must: be 1.0. * pname:textureCompressionETC2 indicates whether the ETC2 and EAC compressed texture formats are supported. If this feature is not enabled, the following formats must: not be used to create images: + -- * ename:VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK * ename:VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK * ename:VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK * ename:VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK * ename:VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK * ename:VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK * ename:VK_FORMAT_EAC_R11_UNORM_BLOCK * ename:VK_FORMAT_EAC_R11_SNORM_BLOCK * ename:VK_FORMAT_EAC_R11G11_UNORM_BLOCK * ename:VK_FORMAT_EAC_R11G11_SNORM_BLOCK -- + flink:vkGetPhysicalDeviceFormatProperties is used to check for the supported properties of individual formats. + * [[features-features-textureCompressionASTC_LDR]] pname:textureCompressionASTC_LDR indicates whether the ASTC LDR compressed texture formats are supported. If this feature is not enabled, the following formats must: not be used to create images: + -- * ename:VK_FORMAT_ASTC_4x4_UNORM_BLOCK * ename:VK_FORMAT_ASTC_4x4_SRGB_BLOCK * ename:VK_FORMAT_ASTC_5x4_UNORM_BLOCK * ename:VK_FORMAT_ASTC_5x4_SRGB_BLOCK * ename:VK_FORMAT_ASTC_5x5_UNORM_BLOCK * ename:VK_FORMAT_ASTC_5x5_SRGB_BLOCK * ename:VK_FORMAT_ASTC_6x5_UNORM_BLOCK * ename:VK_FORMAT_ASTC_6x5_SRGB_BLOCK * ename:VK_FORMAT_ASTC_6x6_UNORM_BLOCK * ename:VK_FORMAT_ASTC_6x6_SRGB_BLOCK * ename:VK_FORMAT_ASTC_8x5_UNORM_BLOCK * ename:VK_FORMAT_ASTC_8x5_SRGB_BLOCK * ename:VK_FORMAT_ASTC_8x6_UNORM_BLOCK * ename:VK_FORMAT_ASTC_8x6_SRGB_BLOCK * ename:VK_FORMAT_ASTC_8x8_UNORM_BLOCK * ename:VK_FORMAT_ASTC_8x8_SRGB_BLOCK * ename:VK_FORMAT_ASTC_10x5_UNORM_BLOCK * ename:VK_FORMAT_ASTC_10x5_SRGB_BLOCK * ename:VK_FORMAT_ASTC_10x6_UNORM_BLOCK * ename:VK_FORMAT_ASTC_10x6_SRGB_BLOCK * ename:VK_FORMAT_ASTC_10x8_UNORM_BLOCK * ename:VK_FORMAT_ASTC_10x8_SRGB_BLOCK * ename:VK_FORMAT_ASTC_10x10_UNORM_BLOCK * ename:VK_FORMAT_ASTC_10x10_SRGB_BLOCK * ename:VK_FORMAT_ASTC_12x10_UNORM_BLOCK * ename:VK_FORMAT_ASTC_12x10_SRGB_BLOCK * ename:VK_FORMAT_ASTC_12x12_UNORM_BLOCK * ename:VK_FORMAT_ASTC_12x12_SRGB_BLOCK -- + flink:vkGetPhysicalDeviceFormatProperties is used to check for the supported properties of individual formats. + *  pname:textureCompressionBC indicates whether the BC compressed texture formats are supported. If this feature is not enabled, the following formats must: not be used to create images: + -- * ename:VK_FORMAT_BC1_RGB_UNORM_BLOCK * ename:VK_FORMAT_BC1_RGB_SRGB_BLOCK * ename:VK_FORMAT_BC1_RGBA_UNORM_BLOCK * ename:VK_FORMAT_BC1_RGBA_SRGB_BLOCK * ename:VK_FORMAT_BC2_UNORM_BLOCK * ename:VK_FORMAT_BC2_SRGB_BLOCK * ename:VK_FORMAT_BC3_UNORM_BLOCK * ename:VK_FORMAT_BC3_SRGB_BLOCK * ename:VK_FORMAT_BC4_UNORM_BLOCK * ename:VK_FORMAT_BC4_SNORM_BLOCK * ename:VK_FORMAT_BC5_UNORM_BLOCK * ename:VK_FORMAT_BC5_SNORM_BLOCK * ename:VK_FORMAT_BC6H_UFLOAT_BLOCK * ename:VK_FORMAT_BC6H_SFLOAT_BLOCK * ename:VK_FORMAT_BC7_UNORM_BLOCK * ename:VK_FORMAT_BC7_SRGB_BLOCK -- + flink:vkGetPhysicalDeviceFormatProperties is used to check for the supported properties of individual formats. + *  pname:occlusionQueryPrecise indicates whether occlusion queries returning actual sample counts are supported. Occlusion queries are created in a sname:VkQueryPool by specifying the pname:queryType of ename:VK_QUERY_TYPE_OCCLUSION in the sname:VkQueryPoolCreateInfo structure which is passed to fname:vkCreateQueryPool. If this feature is enabled, queries of this type can: enable ename:VK_QUERY_CONTROL_PRECISE_BIT in the pname:flags parameter to fname:vkCmdBeginQuery. If this feature is not supported, the implementation supports only boolean occlusion queries. When any samples are passed, boolean queries will return a non-zero result value, otherwise a result value of zero is returned. When this feature is enabled and ename:VK_QUERY_CONTROL_PRECISE_BIT is set, occlusion queries will report the actual number of samples passed. * pname:pipelineStatisticsQuery indicates whether the pipeline statistics queries are supported. If this feature is not enabled, queries of type ename:VK_QUERY_TYPE_PIPELINE_STATISTICS cannot: be created, and none of the elink:VkQueryPipelineStatisticFlagBits bits can: be set in the pname:pipelineStatistics member of the sname:VkQueryPoolCreateInfo structure. * pname:vertexPipelineStoresAndAtomics indicates whether storage buffers and images support stores and atomic operations in the vertex, tessellation, and geometry shader stages. If this feature is not enabled, all storage image, storage texel buffers, and storage buffer variables used by these stages in shader modules must: be decorated with the code:NonWriteable decoration (or the code:readonly memory qualifier in GLSL). * pname:fragmentStoresAndAtomics indicates whether storage buffers and images support stores and atomic operations in the fragment shader stage. If this feature is not enabled, all storage image, storage texel buffers, and storage buffer variables used by the fragment stage in shader modules must: be decorated with the code:NonWriteable decoration (or the code:readonly memory qualifier in GLSL). * pname:shaderTessellationAndGeometryPointSize indicates whether the code:PointSize built-in decoration is available in the tessellation control, tessellation evaluation, and geometry shader stages. If this feature is not enabled, members decorated with the code:PointSize built-in decoration must: not be read from or written to and all points written from a tessellation or geometry shader will have a size of 1.0. This also indicates whether shader modules can: declare the code:TessellationPointSize capability for tessellation control and evaluation shaders, or if the shader modules can: declare the code:GeometryPointSize capability for geometry shaders. An implementation supporting this feature must: also support one or both of the &lt;&lt;features-features-tessellationShader,pname:tessellationShader&gt;&gt; or &lt;&lt;features-features-geometryShader,pname:geometryShader&gt;&gt; features. * pname:shaderImageGatherExtended indicates whether the extended set of image gather instructions are available in shader code. If this feature is not enabled, the code:OpImage*code:Gather instructions do not support the code:Offset and code:ConstOffsets operands. This also indicates whether shader modules can: declare the code:ImageGatherExtended capability. * pname:shaderStorageImageExtendedFormats indicates whether the extended storage image formats are available in shader code. If this feature is not enabled, the formats requiring the code:StorageImageExtendedFormats capability are not supported for storage images. This also indicates whether shader modules can: declare the code:StorageImageExtendedFormats capability. * pname:shaderStorageImageMultisample indicates whether multisampled storage images are supported. If this feature is not enabled, images that are created with a pname:usage that includes ename:VK_IMAGE_USAGE_STORAGE_BIT must: be created with pname:samples equal to ename:VK_SAMPLE_COUNT_1_BIT. This also indicates whether shader modules can: declare the code:StorageImageMultisample capability. * pname:shaderStorageImageReadWithoutFormat indicates whether storage images require a format qualifier to be specified when reading from storage images. If this feature is not enabled, the code:OpImageRead instruction must: not have an code:OpTypeImage of code:Unknown. This also indicates whether shader modules can: declare the code:StorageImageReadWithoutFormat capability. * pname:shaderStorageImageWriteWithoutFormat indicates whether storage images require a format qualifier to be specified when writing to storage images. If this feature is not enabled, the code:OpImageWrite instruction must: not have an code:OpTypeImage of code:Unknown. This also indicates whether shader modules can: declare the code:StorageImageWriteWithoutFormat capability. * pname:shaderUniformBufferArrayDynamicIndexing indicates whether arrays of uniform buffers can: be indexed by dynamically uniform integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC must: be indexed only by constant integral expressions when aggregated into arrays in shader code. This also indicates whether shader modules can: declare the code:UniformBufferArrayDynamicIndexing capability. * pname:shaderSampledImageArrayDynamicIndexing indicates whether arrays of samplers or sampled images can: be indexed by dynamically uniform integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of ename:VK_DESCRIPTOR_TYPE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, or ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE must: be indexed only by constant integral expressions when aggregated into arrays in shader code. This also indicates whether shader modules can: declare the code:SampledImageArrayDynamicIndexing capability. * pname:shaderStorageBufferArrayDynamicIndexing indicates whether arrays of storage buffers can: be indexed by dynamically uniform integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC must: be indexed only by constant integral expressions when aggregated into arrays in shader code. This also indicates whether shader modules can: declare the code:StorageBufferArrayDynamicIndexing capability. * pname:shaderStorageImageArrayDynamicIndexing indicates whether arrays of storage images can: be indexed by dynamically uniform integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE must: be indexed only by constant integral expressions when aggregated into arrays in shader code. This also indicates whether shader modules can: declare the code:StorageImageArrayDynamicIndexing capability. *  pname:shaderClipDistance indicates whether clip distances are supported in shader code. If this feature is not enabled, any members decorated with the code:ClipDistance built-in decoration must: not be read from or written to in shader modules. This also indicates whether shader modules can: declare the code:ClipDistance capability. *  pname:shaderCullDistance indicates whether cull distances are supported in shader code. If this feature is not enabled, any members decorated with the code:CullDistance built-in decoration must: not be read from or written to in shader modules. This also indicates whether shader modules can: declare the code:CullDistance capability. *  pname:shaderFloat64 indicates whether 64-bit floats (doubles) are supported in shader code. If this feature is not enabled, 64-bit floating-point types must: not be used in shader code. This also indicates whether shader modules can: declare the code:Float64 capability. *  pname:shaderInt64 indicates whether 64-bit integers (signed and unsigned) are supported in shader code. If this feature is not enabled, 64-bit integer types must: not be used in shader code. This also indicates whether shader modules can: declare the code:Int64 capability. *  pname:shaderInt16 indicates whether 16-bit integers (signed and unsigned) are supported in shader code. If this feature is not enabled, 16-bit integer types must: not be used in shader code. This also indicates whether shader modules can: declare the code:Int16 capability. * pname:shaderResourceResidency indicates whether image operations that return resource residency information are supported in shader code. If this feature is not enabled, the code:OpImageSparse* instructions must: not be used in shader code. This also indicates whether shader modules can: declare the code:SparseResidency capability. The feature requires at least one of the ptext:sparseResidency* features to be supported. *  pname:shaderResourceMinLod indicates whether image operations that specify the minimum resource level-of-detail (LOD) are supported in shader code. If this feature is not enabled, the code:MinLod image operand must: not be used in shader code. This also indicates whether shader modules can: declare the code:MinLod capability. *  pname:sparseBinding indicates whether resource memory can: be managed at opaque sparse block level instead of at the object level. If this feature is not enabled, resource memory must: be bound only on a per-object basis using the fname:vkBindBufferMemory and fname:vkBindImageMemory commands. In this case, buffers and images must: not be created with ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT and ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT set in the pname:flags member of the sname:VkBufferCreateInfo and sname:VkImageCreateInfo structures, respectively. Otherwise resource memory can: be managed as described in &lt;&lt;sparsememory-sparseresourcefeatures,Sparse Resource Features&gt;&gt;. *  pname:sparseResidencyBuffer indicates whether the device can: access partially resident buffers. If this feature is not enabled, buffers must: not be created with ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member of the sname:VkBufferCreateInfo structure. * pname:sparseResidencyImage2D indicates whether the device can: access partially resident 2D images with 1 sample per pixel. If this feature is not enabled, images with an pname:imageType of ename:VK_IMAGE_TYPE_2D and pname:samples set to ename:VK_SAMPLE_COUNT_1_BIT must: not be created with ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member of the sname:VkImageCreateInfo structure. * pname:sparseResidencyImage3D indicates whether the device can: access partially resident 3D images. If this feature is not enabled, images with an pname:imageType of ename:VK_IMAGE_TYPE_3D must: not be created with ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member of the sname:VkImageCreateInfo structure. * pname:sparseResidency2Samples indicates whether the physical device can: access partially resident 2D images with 2 samples per pixel. If this feature is not enabled, images with an pname:imageType of ename:VK_IMAGE_TYPE_2D and pname:samples set to ename:VK_SAMPLE_COUNT_2_BIT must: not be created with ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member of the sname:VkImageCreateInfo structure. * pname:sparseResidency4Samples indicates whether the physical device can: access partially resident 2D images with 4 samples per pixel. If this feature is not enabled, images with an pname:imageType of ename:VK_IMAGE_TYPE_2D and pname:samples set to ename:VK_SAMPLE_COUNT_4_BIT must: not be created with ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member of the sname:VkImageCreateInfo structure. * pname:sparseResidency8Samples indicates whether the physical device can: access partially resident 2D images with 8 samples per pixel. If this feature is not enabled, images with an pname:imageType of ename:VK_IMAGE_TYPE_2D and pname:samples set to ename:VK_SAMPLE_COUNT_8_BIT must: not be created with ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member of the sname:VkImageCreateInfo structure. * pname:sparseResidency16Samples indicates whether the physical device can: access partially resident 2D images with 16 samples per pixel. If this feature is not enabled, images with an pname:imageType of ename:VK_IMAGE_TYPE_2D and pname:samples set to ename:VK_SAMPLE_COUNT_16_BIT must: not be created with ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the pname:flags member of the sname:VkImageCreateInfo structure. * pname:sparseResidencyAliased indicates whether the physical device can: correctly access data aliased into multiple locations. If this feature is not enabled, the ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT and ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT enum values must: not be used in pname:flags members of the sname:VkBufferCreateInfo and sname:VkImageCreateInfo structures, respectively. * pname:variableMultisampleRate indicates whether all pipelines that will be bound to a command buffer during a subpass with no attachments must: have the same value for sname:VkPipelineMultisampleStateCreateInfo::pname:rasterizationSamples. If set to ename:VK_TRUE, the implementation supports variable multisample rates in a subpass with no attachments. If set to ename:VK_FALSE, then all pipelines bound in such a subpass must: have the same multisample rate. This has no effect in situations where a subpass uses any attachments. *  pname:inheritedQueries indicates whether a secondary command buffer may: be executed while a query is active.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.RobustBufferAccess">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.FullDrawIndexUInt32">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ImageCubeArray">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.IndependentBlend">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.GeometryShader">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.TessellationShader">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.SampleRateShading">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.DualSourceBlend">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.LogicOp">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.MultiDrawIndirect">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.DrawIndirectFirstInstance">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.DepthClamp">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.DepthBiasClamp">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.FillModeNonSolid">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.DepthBounds">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.WideLines">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.LargePoints">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.AlphaToOne">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.MultiViewport">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.SamplerAnisotropy">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.TextureCompressionETC2">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.TextureCompressionASTC_LDR">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.TextureCompressionBC">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.OcclusionQueryPrecise">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.PipelineStatisticsQuery">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.VertexPipelineStoresAndAtomics">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.FragmentStoresAndAtomics">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderTessellationAndGeometryPointSize">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderImageGatherExtended">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderStorageImageExtendedFormats">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderStorageImageMultisample">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderStorageImageReadWithoutFormat">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderStorageImageWriteWithoutFormat">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderUniformBufferArrayDynamicIndexing">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderSampledImageArrayDynamicIndexing">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderStorageBufferArrayDynamicIndexing">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderStorageImageArrayDynamicIndexing">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderClipDistance">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderCullDistance">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderFloat64">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderInt64">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderInt16">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderResourceResidency">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderResourceMinLod">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.SparseBinding">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.SparseResidencyBuffer">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.SparseResidencyImage2D">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.SparseResidencyImage3D">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.SparseResidency2Samples">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.SparseResidency4Samples">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.SparseResidency8Samples">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.SparseResidency16Samples">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.SparseResidencyAliased">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.VariableMultisampleRate">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.InheritedQueries">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDeviceFeatures.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.PhysicalDeviceSparseProperties">
            <summary>
            <para>
            Structure specifying physical device sparse memory properties.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceSparseProperties.ResidencyStandard2DBlockShape">
            <summary>
            <para>
            pname:residencyStandard2DBlockShape is ename:VK_TRUE if the physical device will access all single-sample 2D sparse resources using the standard sparse image block shapes (based on image format), as described in the &lt;&lt;sparsememory-sparseblockshapessingle,Standard Sparse Image Block Shapes (Single Sample)&gt;&gt; table. If this property is not supported the value returned in the pname:imageGranularity member of the sname:VkSparseImageFormatProperties structure for single-sample 2D images is not required: to match the standard sparse image block dimensions listed in the table.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceSparseProperties.ResidencyStandard2DMultisampleBlockShape">
            <summary>
            <para>
            pname:residencyStandard2DMultisampleBlockShape is ename:VK_TRUE if the physical device will access all multisample 2D sparse resources using the standard sparse image block shapes (based on image format), as described in the &lt;&lt;sparsememory-sparseblockshapesmsaa,Standard Sparse Image Block Shapes (MSAA)&gt;&gt; table. If this property is not supported, the value returned in the pname:imageGranularity member of the sname:VkSparseImageFormatProperties structure for multisample 2D images is not required: to match the standard sparse image block dimensions listed in the table.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceSparseProperties.ResidencyStandard3DBlockShape">
            <summary>
            <para>
            pname:residencyStandard3DBlockShape is ename:VK_TRUE if the physical device will access all 3D sparse resources using the standard sparse image block shapes (based on image format), as described in the &lt;&lt;sparsememory-sparseblockshapessingle,Standard Sparse Image Block Shapes (Single Sample)&gt;&gt; table. If this property is not supported, the value returned in the pname:imageGranularity member of the sname:VkSparseImageFormatProperties structure for 3D images is not required: to match the standard sparse image block dimensions listed in the table.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceSparseProperties.ResidencyAlignedMipSize">
            <summary>
            <para>
            pname:residencyAlignedMipSize is ename:VK_TRUE if images with mip level dimensions that are not integer multiples of the corresponding dimensions of the sparse image block may: be placed in the mip tail. If this property is not reported, only mip levels with dimensions smaller than the pname:imageGranularity member of the sname:VkSparseImageFormatProperties structure will be placed in the mip tail. If this property is reported the implementation is allowed to return ename:VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT in the pname:flags member of sname:VkSparseImageFormatProperties, indicating that mip level dimensions that are not integer multiples of the corresponding dimensions of the sparse image block will be placed in the mip tail.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceSparseProperties.ResidencyNonResidentStrict">
            <summary>
            <para>
            pname:residencyNonResidentStrict specifies whether the physical device can: consistently access non-resident regions of a resource. If this property is ename:VK_TRUE, access to non-resident regions of resources will be guaranteed to return values as if the resource were populated with 0; writes to non-resident regions will be discarded.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDeviceSparseProperties.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.PipelineColorBlendAttachmentState">
            <summary>
            <para>
            Structure specifying a pipeline color blend attachment state.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineColorBlendAttachmentState.BlendEnable">
            <summary>
            <para>
            pname:blendEnable controls whether blending is enabled for the corresponding color attachment. If blending is not enabled, the source fragment's color for that attachment is passed through unmodified.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineColorBlendAttachmentState.SourceColorBlendFactor">
            <summary>
            <para>
            pname:srcColorBlendFactor selects which blend factor is used to determine the source factors latexmath:[$S_r,S_g,S_b$].
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineColorBlendAttachmentState.DestinationColorBlendFactor">
            <summary>
            <para>
            pname:dstColorBlendFactor selects which blend factor is used to determine the destination factors latexmath:[$D_r,D_g,D_b$].
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineColorBlendAttachmentState.ColorBlendOp">
            <summary>
            <para>
            pname:colorBlendOp selects which blend operation is used to calculate the RGB values to write to the color attachment.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineColorBlendAttachmentState.SourceAlphaBlendFactor">
            <summary>
            <para>
            pname:srcAlphaBlendFactor selects which blend factor is used to determine the source factor latexmath:[$S_a$].
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineColorBlendAttachmentState.DestinationAlphaBlendFactor">
            <summary>
            <para>
            pname:dstAlphaBlendFactor selects which blend factor is used to determine the destination factor latexmath:[$D_a$].
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineColorBlendAttachmentState.AlphaBlendOp">
            <summary>
            <para>
            pname:alphaBlendOp selects which blend operation is use to calculate the alpha values to write to the color attachment.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineColorBlendAttachmentState.ColorWriteMask">
            <summary>
            <para>
            pname:colorWriteMask is a bitmask selecting which of the R, G, B, and/or A components are enabled for writing, as described later in this chapter.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PipelineColorBlendAttachmentState.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.PushConstantRange">
            <summary>
            <para>
            Structure specifying a push constant range.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PushConstantRange.StageFlags">
            <summary>
            <para>
            pname:stageFlags is a set of stage flags describing the shader stages that will access a range of push constants. If a particular stage is not included in the range, then accessing members of that range of push constants from the corresponding shader stage will result in undefined data being read.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PushConstantRange.Offset">
            <summary>
            <para>
            pname:offset and pname:size are the start offset and size, respectively, consumed by the range. Both pname:offset and pname:size are in units of bytes and must: be a multiple of 4. The layout of the push constant variables is specified in the shader.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PushConstantRange.Size">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PushConstantRange.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.QueueFamilyProperties">
            <summary>
            <para>
            Structure providing information about a queue family.
            </para>
            <para>
            The bits specified in pname:queueFlags are:
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueueFamilyProperties.QueueFlags">
            <summary>
            <para>
            pname:queueFlags contains flags indicating the capabilities of the queues in this queue family.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueueFamilyProperties.QueueCount">
            <summary>
            <para>
            pname:queueCount is the unsigned integer count of queues in this queue family.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueueFamilyProperties.TimestampValidBits">
            <summary>
            <para>
            pname:timestampValidBits is the unsigned integer count of meaningful bits in the timestamps written via fname:vkCmdWriteTimestamp. The valid range for the count is 36..64 bits, or a value of 0, indicating no support for timestamps. Bits outside the valid range are guaranteed to be zeros.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueueFamilyProperties.MinImageTransferGranularity">
            <summary>
            <para>
            pname:minImageTransferGranularity is the minimum granularity supported for image transfer operations on the queues in this queue family.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.QueueFamilyProperties.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Rect2D">
            <summary>
            <para>
            Structure specifying a two-dimensional subregion.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Rect2D.Offset">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Rect2D.Extent">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Rect2D.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.SparseImageFormatProperties">
            <summary>
            <para>
            Structure specifying sparse image format properties.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SparseImageFormatProperties.AspectMask">
            <summary>
            <para>
            pname:aspectMask is a bitmask of elink:VkImageAspectFlagBits specifying which aspects of the image the properties apply to.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SparseImageFormatProperties.ImageGranularity">
            <summary>
            <para>
            pname:imageGranularity is the width, height, and depth of the sparse image block in texels or compressed texel blocks.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SparseImageFormatProperties.Flags">
            <summary>
            <para>
            pname:flags is a bitmask specifying additional information about the sparse resource. Bits which can: be set include: + --
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.SparseImageFormatProperties.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.SparseImageMemoryRequirements">
            <summary>
            <para>
            Structure specifying sparse image memory requirements.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SparseImageMemoryRequirements.FormatProperties">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SparseImageMemoryRequirements.ImageMipTailFirstLod">
            <summary>
            <para>
            pname:imageMipTailFirstLod is the first mip level at which image subresources are included in the mip tail region.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SparseImageMemoryRequirements.ImageMipTailSize">
            <summary>
            <para>
            pname:imageMipTailSize is the memory size (in bytes) of the mip tail region. If pname:formatProperties.flags contains ename:VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT, this is the size of the whole mip tail, otherwise this is the size of the mip tail of a single array layer. This value is guaranteed to be a multiple of the sparse block size in bytes.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SparseImageMemoryRequirements.ImageMipTailOffset">
            <summary>
            <para>
            pname:imageMipTailOffset is the opaque memory offset used with slink:VkSparseImageOpaqueMemoryBindInfo to bind the mip tail region(s).
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SparseImageMemoryRequirements.ImageMipTailStride">
            <summary>
            <para>
            pname:imageMipTailStride is the offset stride between each array-layer's mip tail, if pname:formatProperties.flags does not contain ename:VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT (otherwise the value is undefined).
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.SparseImageMemoryRequirements.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.SpecializationMapEntry">
            <summary>
            <para>
            Structure specifying a specialization map entry.
            </para>
            <para>
            If a pname:constantID value is not a specialization constant ID used in the shader, that map entry does not affect the behavior of the pipeline.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SpecializationMapEntry.ConstantID">
            <summary>
            <para>
            pname:constantID is the ID of the specialization constant in SPIR-V.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SpecializationMapEntry.Offset">
            <summary>
            <para>
            pname:offset is the byte offset of the specialization constant value within the supplied data buffer.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SpecializationMapEntry.Size">
            <summary>
            <para>
            pname:size is the byte size of the specialization constant value within the supplied data buffer.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.SpecializationMapEntry.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.StencilOpState">
            <summary>
            <para>
            Structure specifying stencil operation state.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StencilOpState.FailOp">
            <summary>
            <para>
            pname:failOp is the action performed on samples that fail the stencil test.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StencilOpState.PassOp">
            <summary>
            <para>
            pname:passOp is the action performed on samples that pass both the depth and stencil tests.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StencilOpState.DepthFailOp">
            <summary>
            <para>
            pname:depthFailOp is the action performed on samples that pass the stencil test and fail the depth test.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StencilOpState.CompareOp">
            <summary>
            <para>
            pname:compareOp is the comparison operator used in the stencil test.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StencilOpState.CompareMask">
            <summary>
            <para>
            pname:compareMask selects the bits of the unsigned integer stencil values participating in the stencil test.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StencilOpState.WriteMask">
            <summary>
            <para>
            pname:writeMask selects the bits of the unsigned integer stencil values updated by the stencil test in the stencil framebuffer attachment.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StencilOpState.Reference">
            <summary>
            <para>
            pname:reference is an integer reference value that is used in the unsigned stencil comparison.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.StencilOpState.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.SubpassDependency">
            <summary>
            <para>
            Structure specifying a subpass dependency.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SubpassDependency.SourceSubpass">
            <summary>
            <para>
            pname:srcSubpass and pname:dstSubpass are the subpass indices of the producer and consumer subpasses, respectively. pname:srcSubpass and pname:dstSubpass can: also have the special value ename:VK_SUBPASS_EXTERNAL. The source subpass must: always be a lower numbered subpass than the destination subpass (excluding external subpasses and &lt;&lt;synchronization-pipeline-barriers-subpass-self-dependencies, self-dependencies&gt;&gt;), so that the order of subpass descriptions is a valid execution ordering, avoiding cycles in the dependency graph.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SubpassDependency.DestinationSubpass">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SubpassDependency.SourceStageMask">
            <summary>
            <para>
            pname:srcStageMask, pname:dstStageMask, pname:srcAccessMask, pname:dstAccessMask, and pname:dependencyFlags describe an &lt;&lt;synchronization-execution-and-memory-dependencies,execution and memory dependency&gt;&gt; between subpasses. The bits that can: be included in pname:dependencyFlags are: + --
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SubpassDependency.DestinationStageMask">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SubpassDependency.SourceAccessMask">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SubpassDependency.DestinationAccessMask">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SubpassDependency.DependencyFlags">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.SubpassDependency.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.SubresourceLayout">
            <summary>
            <para>
            Structure specifying subresource layout.
            </para>
            <para>
            For images created with linear tiling, pname:rowPitch, pname:arrayPitch and pname:depthPitch describe the layout of the image subresource in linear memory. For uncompressed formats, pname:rowPitch is the number of bytes between texels with the same x coordinate in adjacent rows (y coordinates differ by one). pname:arrayPitch is the number of bytes between texels with the same x and y coordinate in adjacent array layers of the image (array layer values differ by one). pname:depthPitch is the number of bytes between texels with the same x and y coordinate in adjacent slices of a 3D image (z coordinates differ by one). Expressed as an addressing formula, the starting byte of a texel in the image subresource has address:
            </para>
            <para>
            [source,c] --------------------------------------------------- // (x,y,z,layer) are in texel coordinates address(x,y,z,layer) = layer*arrayPitch + z*depthPitch + y*rowPitch + x*texelSize + offset ---------------------------------------------------
            </para>
            <para>
            For compressed formats, the pname:rowPitch is the number of bytes between compressed texel blocks in adjacent rows. pname:arrayPitch is the number of bytes between compressed texel blocks in adjacent array layers. pname:depthPitch is the number of bytes between compressed texel blocks in adjacent slices of a 3D image.
            </para>
            <para>
            [source,c] --------------------------------------------------- // (x,y,z,layer) are in compressed texel block coordinates address(x,y,z,layer) = layer*arrayPitch + z*depthPitch + y*rowPitch + x*compressedTexelBlockByteSize + offset; ---------------------------------------------------
            </para>
            <para>
            pname:arrayPitch is undefined for images that were not created as arrays. pname:depthPitch is defined only for 3D images.
            </para>
            <para>
            For color formats, the pname:aspectMask member of sname:VkImageSubresource must: be ename:VK_IMAGE_ASPECT_COLOR_BIT. For depth/stencil formats, pname:aspectMask must: be either ename:VK_IMAGE_ASPECT_DEPTH_BIT or ename:VK_IMAGE_ASPECT_STENCIL_BIT. On implementations that store depth and stencil aspects separately, querying each of these image subresource layouts will return a different pname:offset and pname:size representing the region of memory used for that aspect. On implementations that store depth and stencil aspects interleaved, the same pname:offset and pname:size are returned and represent the interleaved memory allocation.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SubresourceLayout.Offset">
            <summary>
            <para>
            pname:offset is the byte offset from the start of the image where the image subresource begins.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SubresourceLayout.Size">
            <summary>
            <para>
            pname:size is the size in bytes of the image subresource. pname:size includes any extra memory that is required based on pname:rowPitch.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SubresourceLayout.RowPitch">
            <summary>
            <para>
            pname:rowPitch describes the number of bytes between each row of texels in an image.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SubresourceLayout.ArrayPitch">
            <summary>
            <para>
            pname:arrayPitch describes the number of bytes between each array layer of an image.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SubresourceLayout.DepthPitch">
            <summary>
            <para>
            pname:depthPitch describes the number of bytes between each slice of 3D image.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.SubresourceLayout.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.SurfaceCapabilities">
            <summary>
            <para>
            Structure describing capabilities of a surface.
            </para>
            <para>
            [NOTE] .Note ==== Formulas such as latexmath:[$\min(N,maxImageCount)$] are not correct, since pname:maxImageCount may: be zero. ====
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceCapabilities.MinImageCount">
            <summary>
            <para>
            pname:minImageCount is the minimum number of images the specified device supports for a swapchain created for the surface.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceCapabilities.MaxImageCount">
            <summary>
            <para>
            pname:maxImageCount is the maximum number of images the specified device supports for a swapchain created for the surface. A value of 0 means that there is no limit on the number of images, though there may: be limits related to the total amount of memory used by swapchain images.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceCapabilities.CurrentExtent">
            <summary>
            <para>
            pname:currentExtent is the current width and height of the surface, or the special value latexmath:[$(0xFFFFFFFF, 0xFFFFFFFF)$] indicating that the surface size will be determined by the extent of a swapchain targeting the surface.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceCapabilities.MinImageExtent">
            <summary>
            <para>
            pname:minImageExtent contains the smallest valid swapchain extent for the surface on the specified device.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceCapabilities.MaxImageExtent">
            <summary>
            <para>
            pname:maxImageExtent contains the largest valid swapchain extent for the surface on the specified device.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceCapabilities.MaxImageArrayLayers">
            <summary>
            <para>
            pname:maxImageArrayLayers is the maximum number of layers swapchain images can: have for a swapchain created for this device and surface.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceCapabilities.SupportedTransforms">
            <summary>
            <para>
            pname:supportedTransforms is a bitmask of elink:VkSurfaceTransformFlagBitsKHR, describing the presentation transforms supported for the surface on the specified device.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceCapabilities.CurrentTransform">
            <summary>
            <para>
            pname:currentTransform is a bitmask of elink:VkSurfaceTransformFlagBitsKHR, describing the surface's current transform relative to the presentation engine's natural orientation.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceCapabilities.SupportedCompositeAlpha">
            <summary>
            <para>
            pname:supportedCompositeAlpha is a bitmask of elink:VkCompositeAlphaFlagBitsKHR, representing the alpha compositing modes supported by the presentation engine for the surface on the specified device. Opaque composition can: be achieved in any alpha compositing mode by either using a swapchain image format that has no alpha component, or by ensuring that all pixels in the swapchain images have an alpha value of 1.0.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceCapabilities.SupportedUsageFlags">
            <summary>
            <para>
            pname:supportedUsageFlags is a bitmask of elink:VkImageUsageFlagBits representing the ways the application can: use the presentable images of a swapchain created for the surface on the specified device. ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT must: be included in the set but implementations may: support additional usages.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.SurfaceCapabilities.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.SurfaceFormat">
            <summary>
            <para>
            Structure describing a supported swapchain format-color space pair.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceFormat.Format">
            <summary>
            <para>
            pname:format is a ename:VkFormat that is compatible with the specified surface.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceFormat.ColorSpace">
            <summary>
            <para>
            pname:colorSpace is a presentation ename:VkColorSpaceKHR that is compatible with the surface.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.SurfaceFormat.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.VertexInputAttributeDescription">
            <summary>
            <para>
            Structure specifying vertex input attribute description.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.VertexInputAttributeDescription.Location">
            <summary>
            <para>
            pname:location is the shader binding location number for this attribute.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.VertexInputAttributeDescription.Binding">
            <summary>
            <para>
            pname:binding is the binding number which this attribute takes its data from.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.VertexInputAttributeDescription.Format">
            <summary>
            <para>
            pname:format is the size and type of the vertex attribute data.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.VertexInputAttributeDescription.Offset">
            <summary>
            <para>
            pname:offset is a byte offset of this attribute relative to the start of an element in the vertex input binding.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.VertexInputAttributeDescription.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.VertexInputBindingDescription">
            <summary>
            <para>
            Structure specifying vertex input binding description.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.VertexInputBindingDescription.Binding">
            <summary>
            <para>
            pname:binding is the binding number that this structure describes.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.VertexInputBindingDescription.Stride">
            <summary>
            <para>
            pname:stride is the distance in bytes between two consecutive elements within the buffer.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.VertexInputBindingDescription.InputRate">
            <summary>
            <para>
            pname:inputRate specifies whether vertex attribute addressing is a function of the vertex index or of the instance index. Possible values include: + --
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.VertexInputBindingDescription.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Viewport">
            <summary>
            <para>
            Structure specifying a viewport.
            </para>
            <para>
            The framebuffer depth coordinate latexmath:[$z_f$] may: be represented using either a fixed-point or floating-point representation. However, a floating-point representation must: be used if the depth/stencil attachment has a floating-point depth component. If an latexmath:[$m$]-bit fixed-point representation is used, we assume that it represents each value latexmath:[$\frac{k}{2^m - 1}$], where latexmath:[$k \in \{ 0,1, \ldots, 2^m-1 \}$], as latexmath:[$k$] (e.g. 1.0 is represented in binary as a string of all ones).
            </para>
            <para>
            The viewport parameters shown in the above equations are found from these values as
            </para>
            <para>
            [latexmath] ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ \begin{align*} o_x &amp; = x + \frac{width}{2} \\ o_y &amp; = y + \frac{height}{2} \\ o_z &amp; = minDepth \\ p_x &amp; = width \\ p_y &amp; = height \\ p_z &amp; = maxDepth - minDepth. \end{align*} ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            </para>
            <para>
            The width and height of the &lt;&lt;features-limits-maxViewportDimensions, implementation-dependent maximum viewport dimensions&gt;&gt; must: be greater than or equal to the width and height of the largest image which can: be created and attached to a framebuffer.
            </para>
            <para>
            The floating-point viewport bounds are represented with an &lt;&lt;features-limits-viewportSubPixelBits,implementation-dependent precision&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Viewport.X">
            <summary>
            <para>
            pname:x and pname:y are the viewport's upper left corner latexmath:[$(x,y)$].
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Viewport.Y">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Viewport.Width">
            <summary>
            <para>
            pname:width and pname:height are the viewport's width and height, respectively.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Viewport.Height">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Viewport.MinDepth">
            <summary>
            <para>
            pname:minDepth and pname:maxDepth are the depth range for the viewport. It is valid for pname:minDepth to be greater than or equal to pname:maxDepth.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Viewport.MaxDepth">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Viewport.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.AllocationCallbacks">
            <summary>
            <para>
            Structure containing callback function pointers for memory allocation.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.AllocationCallbacks.UserData">
            <summary>
            <para>
            pname:pUserData is a value to be interpreted by the implementation of the callbacks. When any of the callbacks in sname:VkAllocationCallbacks are called, the Vulkan implementation will pass this value as the first parameter to the callback. This value can: vary each time an allocator is passed into a command, even when the same object takes an allocator in multiple commands.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.AllocationCallbacks.PfnAllocation">
            <summary>
            <para>
            pname:pfnAllocation is a pointer to an application-defined memory allocation function of type tlink:PFN_vkAllocationFunction.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.AllocationCallbacks.PfnReallocation">
            <summary>
            <para>
            pname:pfnReallocation is a pointer to an application-defined memory reallocation function of type tlink:PFN_vkReallocationFunction.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.AllocationCallbacks.PfnFree">
            <summary>
            <para>
            pname:pfnFree is a pointer to an application-defined memory free function of type tlink:PFN_vkFreeFunction.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.AllocationCallbacks.PfnInternalAllocation">
            <summary>
            <para>
            pname:pfnInternalAllocation is a pointer to an application-defined function that is called by the implementation when the implementation makes internal allocations, and it is of type tlink:PFN_vkInternalAllocationNotification.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.AllocationCallbacks.PfnInternalFree">
            <summary>
            <para>
            pname:pfnInternalFree is a pointer to an application-defined function that is called by the implementation when the implementation frees internal allocations, and it is of type tlink:PFN_vkInternalFreeNotification.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.AndroidSurfaceCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created Android surface object.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.AndroidSurfaceCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.AndroidSurfaceCreateInfo.Window">
            <summary>
            <para>
            pname:window is a pointer to the code:ANativeWindow to associate the surface with.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.ApplicationInfo">
            <summary>
            <para>
            Structure specifying application info.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ApplicationInfo.ApplicationName">
            <summary>
            <para>
            pname:pApplicationName is a pointer to a null-terminated UTF-8 string containing the name of the application.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ApplicationInfo.ApplicationVersion">
            <summary>
            <para>
            pname:applicationVersion is an unsigned integer variable containing the developer-supplied version number of the application.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ApplicationInfo.EngineName">
            <summary>
            <para>
            pname:pEngineName is a pointer to a null-terminated UTF-8 string containing the name of the engine (if any) used to create the application.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ApplicationInfo.EngineVersion">
            <summary>
            <para>
            pname:engineVersion is an unsigned integer variable containing the developer-supplied version number of the engine used to create the application.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ApplicationInfo.ApiVersion">
            <summary>
            <para>
            pname:apiVersion is the version of the Vulkan API against which the application expects to run, encoded as described in the &lt;&lt;fundamentals-versionnum,API Version Numbers and Semantics&gt;&gt; section. If pname:apiVersion is 0 the implementation must: ignore it, otherwise if the implementation does not support the requested pname:apiVersion it must: return ename:VK_ERROR_INCOMPATIBLE_DRIVER. The patch version number specified in pname:apiVersion is ignored when creating an instance object. Only the major and minor versions of the instance must: match those requested in pname:apiVersion.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.BindSparseInfo">
            <summary>
            <para>
            Structure specifying a sparse binding operation.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.BindSparseInfo.WaitSemaphores">
            <summary>
            <para>
            pname:pWaitSemaphores is a pointer to an array of semaphores upon which to wait on before the sparse binding operations for this batch begin execution. If semaphores to wait on are provided, they define a &lt;&lt;synchronization-semaphores-waiting, semaphore wait operation&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.BindSparseInfo.BufferBinds">
            <summary>
            <para>
            pname:pBufferBinds is a pointer to an array of slink:VkSparseBufferMemoryBindInfo structures.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.BindSparseInfo.ImageOpaqueBinds">
            <summary>
            <para>
            pname:pImageOpaqueBinds is a pointer to an array of slink:VkSparseImageOpaqueMemoryBindInfo structures, indicating opaque sparse image bindings to perform.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.BindSparseInfo.ImageBinds">
            <summary>
            <para>
            pname:pImageBinds is a pointer to an array of slink:VkSparseImageMemoryBindInfo structures, indicating sparse image bindings to perform.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.BindSparseInfo.SignalSemaphores">
            <summary>
            <para>
            pname:pSignalSemaphores is a pointer to an array of semaphores which will be signaled when the sparse binding operations for this batch have completed execution. If semaphores to be signaled are provided, they define a &lt;&lt;synchronization-semaphores-signaling, semaphore signal operation&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.BufferCreateInfo">
            <summary>
            <para>
            Structure specifying the parameters of a newly created buffer object.
            </para>
            <para>
            Bits which can: be set in pname:usage are:
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.BufferCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is a bitmask describing additional parameters of the buffer. See elink:VkBufferCreateFlagBits below for a description of the supported bits.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.BufferCreateInfo.Size">
            <summary>
            <para>
            pname:size is the size in bytes of the buffer to be created.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.BufferCreateInfo.Usage">
            <summary>
            <para>
            pname:usage is a bitmask describing the allowed usages of the buffer. See elink:VkBufferUsageFlagBits below for a description of the supported bits.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.BufferCreateInfo.SharingMode">
            <summary>
            <para>
            pname:sharingMode is the sharing mode of the buffer when it will be accessed by multiple queue families, see elink:VkSharingMode in the &lt;&lt;resources-sharing,Resource Sharing&gt;&gt; section below for supported values.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.BufferCreateInfo.QueueFamilyIndices">
            <summary>
            <para>
            pname:pQueueFamilyIndices is a list of queue families that will access this buffer (ignored if pname:sharingMode is not ename:VK_SHARING_MODE_CONCURRENT).
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.BufferMemoryBarrier">
            <summary>
            <para>
            Structure specifying the parameters of a buffer memory barrier.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.BufferMemoryBarrier.SourceAccessMask">
            <summary>
            <para>
            pname:srcAccessMask is a bitmask of the classes of memory accesses performed by the first set of commands that will participate in the dependency.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.BufferMemoryBarrier.DestinationAccessMask">
            <summary>
            <para>
            pname:dstAccessMask is a bitmask of the classes of memory accesses performed by the second set of commands that will participate in the dependency.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.BufferMemoryBarrier.SourceQueueFamilyIndex">
            <summary>
            <para>
            pname:srcQueueFamilyIndex is the queue family that is relinquishing ownership of the range of pname:buffer to another queue, or ename:VK_QUEUE_FAMILY_IGNORED if there is no transfer of ownership.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.BufferMemoryBarrier.DestinationQueueFamilyIndex">
            <summary>
            <para>
            pname:dstQueueFamilyIndex is the queue family that is acquiring ownership of the range of pname:buffer from another queue, or ename:VK_QUEUE_FAMILY_IGNORED if there is no transfer of ownership.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.BufferMemoryBarrier.Buffer">
            <summary>
            <para>
            pname:buffer is a handle to the buffer whose backing memory is affected by the barrier.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.BufferMemoryBarrier.Offset">
            <summary>
            <para>
            pname:offset is an offset in bytes into the backing memory for pname:buffer; this is relative to the base offset as bound to the buffer (see flink:vkBindBufferMemory).
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.BufferMemoryBarrier.Size">
            <summary>
            <para>
            pname:size is a size in bytes of the affected area of backing memory for pname:buffer, or ename:VK_WHOLE_SIZE to use the range from pname:offset to the end of the buffer.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.BufferViewCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created buffer view.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.BufferViewCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.BufferViewCreateInfo.Buffer">
            <summary>
            <para>
            pname:buffer is a sname:VkBuffer on which the view will be created.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.BufferViewCreateInfo.Format">
            <summary>
            <para>
            pname:format is a elink:VkFormat describing the format of the data elements in the buffer.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.BufferViewCreateInfo.Offset">
            <summary>
            <para>
            pname:offset is an offset in bytes from the base address of the buffer. Accesses to the buffer view from shaders use addressing that is relative to this starting offset.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.BufferViewCreateInfo.Range">
            <summary>
            <para>
            pname:range is a size in bytes of the buffer view. If pname:range is equal to ename:VK_WHOLE_SIZE, the range from pname:offset to the end of the buffer is used. If ename:VK_WHOLE_SIZE is used and the remaining size of the buffer is not a multiple of the element size of pname:format, then the nearest smaller multiple is used.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.CommandBufferAllocateInfo">
            <summary>
            <para>
            Structure specifying the allocation parameters for command buffer object.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.CommandBufferAllocateInfo.CommandPool">
            <summary>
            <para>
            pname:commandPool is the name of the command pool that the command buffers allocate their memory from.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.CommandBufferAllocateInfo.Level">
            <summary>
            <para>
            pname:level determines whether the command buffers are primary or secondary command buffers. Possible values include: + --
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.CommandBufferAllocateInfo.CommandBufferCount">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.CommandBufferBeginInfo">
            <summary>
            <para>
            Structure specifying a command buffer begin operation.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.CommandBufferBeginInfo.Flags">
            <summary>
            <para>
            pname:flags is a bitmask indicating usage behavior for the command buffer. Bits which can: be set include: + --
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.CommandBufferBeginInfo.InheritanceInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.CommandBufferInheritanceInfo">
            <summary>
            <para>
            Structure specifying command buffer inheritance info.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.CommandBufferInheritanceInfo.RenderPass">
            <summary>
            <para>
            pname:renderPass is a sname:VkRenderPass object defining which render passes the sname:VkCommandBuffer will be &lt;&lt;renderpass-compatibility, compatible&gt;&gt; with and can: be executed within. If the sname:VkCommandBuffer will not be executed within a render pass instance, pname:renderPass is ignored.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.CommandBufferInheritanceInfo.Subpass">
            <summary>
            <para>
            pname:subpass is the index of the subpass within pname:renderPass that the sname:VkCommandBuffer will be executed within. If the sname:VkCommandBuffer will not be executed within a render pass instance, pname:subpass is ignored.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.CommandBufferInheritanceInfo.Framebuffer">
            <summary>
            <para>
            pname:framebuffer optionally refers to the sname:VkFramebuffer object that the sname:VkCommandBuffer will be rendering to if it is executed within a render pass instance. It can: be dlink:VK_NULL_HANDLE if the framebuffer is not known, or if the sname:VkCommandBuffer will not be executed within a render pass instance. + [NOTE] .Note ==== Specifying the exact framebuffer that the secondary command buffer will be executed with may: result in better performance at command buffer execution time. ====
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.CommandBufferInheritanceInfo.OcclusionQueryEnable">
            <summary>
            <para>
            pname:occlusionQueryEnable indicates whether the command buffer can: be executed while an occlusion query is active in the primary command buffer. If this is ename:VK_TRUE, then this command buffer can: be executed whether the primary command buffer has an occlusion query active or not. If this is ename:VK_FALSE, then the primary command buffer must: not have an occlusion query active.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.CommandBufferInheritanceInfo.QueryFlags">
            <summary>
            <para>
            pname:queryFlags indicates the query flags that can: be used by an active occlusion query in the primary command buffer when this secondary command buffer is executed. If this value includes the ename:VK_QUERY_CONTROL_PRECISE_BIT bit, then the active query can: return boolean results or actual sample counts. If this bit is not set, then the active query must: not use the ename:VK_QUERY_CONTROL_PRECISE_BIT bit. If this is a primary command buffer, then this value is ignored.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.CommandBufferInheritanceInfo.PipelineStatistics">
            <summary>
            <para>
            pname:pipelineStatistics indicates the set of pipeline statistics that can: be counted by an active query in the primary command buffer when this secondary command buffer is executed. If this value includes a given bit, then this command buffer can: be executed whether the primary command buffer has a pipeline statistics query active that includes this bit or not. If this value excludes a given bit, then the active pipeline statistics query must: not be from a query pool that counts that statistic.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.CommandPoolCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created command pool.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.CommandPoolCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is a bitmask indicating usage behavior for the pool and command buffers allocated from it. Bits which can: be set include: + --
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.CommandPoolCreateInfo.QueueFamilyIndex">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.ComputePipelineCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created compute pipeline.
            </para>
            <para>
            The parameters pname:basePipelineHandle and pname:basePipelineIndex are described in more detail in &lt;&lt;pipelines-pipeline-derivatives,Pipeline Derivatives&gt;&gt;.
            </para>
            <para>
            pname:stage points to a structure of type sname:VkPipelineShaderStageCreateInfo.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ComputePipelineCreateInfo.Flags">
            <summary>
            <para>
            pname:flags provides options for pipeline creation, and is of type elink:VkPipelineCreateFlagBits.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ComputePipelineCreateInfo.Stage">
            <summary>
            <para>
            pname:stage is a slink:VkPipelineShaderStageCreateInfo describing the compute shader.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ComputePipelineCreateInfo.Layout">
            <summary>
            <para>
            pname:layout is the description of binding locations used by both the pipeline and descriptor sets used with the pipeline.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ComputePipelineCreateInfo.BasePipelineHandle">
            <summary>
            <para>
            pname:basePipelineHandle is a pipeline to derive from
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ComputePipelineCreateInfo.BasePipelineIndex">
            <summary>
            <para>
            pname:basePipelineIndex is an index into the pname:pCreateInfos parameter to use as a pipeline to derive from
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.CopyDescriptorSet">
            <summary>
            <para>
            Structure specifying a copy descriptor set operation.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.CopyDescriptorSet.SourceSet">
            <summary>
            <para>
            pname:srcSet, pname:srcBinding, and pname:srcArrayElement are the source set, binding, and array element, respectively.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.CopyDescriptorSet.SourceBinding">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.CopyDescriptorSet.SourceArrayElement">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.CopyDescriptorSet.DestinationSet">
            <summary>
            <para>
            pname:dstSet, pname:dstBinding, and pname:dstArrayElement are the destination set, binding, and array element, respectively.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.CopyDescriptorSet.DestinationBinding">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.CopyDescriptorSet.DestinationArrayElement">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.CopyDescriptorSet.DescriptorCount">
            <summary>
            <para>
            pname:descriptorCount is the number of descriptors to copy from the source to destination. If pname:descriptorCount is greater than the number of remaining array elements in the source or destination binding, those affect consecutive bindings in a manner similar to slink:VkWriteDescriptorSet above.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DebugMarkerMarkerInfo">
            <summary>
            <para>
            Specify parameters of a command buffer marker region.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DebugMarkerMarkerInfo.MarkerName">
            <summary>
            <para>
            pname:pMarkerName is a pointer to a null-terminated UTF-8 string that contains the name of the marker.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DebugMarkerMarkerInfo.Color">
            <summary>
            <para>
            pname:color is an optional RGBA color value that can be associated with the marker. A particular implementation may: choose to ignore this color value. The values contain RGBA values in order, in the range 0.0 to 1.0. If all elements in pname:color are set to 0.0 then it is ignored.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DebugMarkerObjectNameInfo">
            <summary>
            <para>
            Specify parameters of a name to give to an object.
            </para>
            <para>
            Applications may: change the name associated with an object simply by calling fname:vkDebugMarkerSetObjectNameEXT again with a new string. To remove a previously set name, pname:pName should: be set to an empty string.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DebugMarkerObjectNameInfo.ObjectType">
            <summary>
            <para>
            pname:objectType is a elink:VkDebugReportObjectTypeEXT specifying the type of the object to be named.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DebugMarkerObjectNameInfo.Object">
            <summary>
            <para>
            pname:object is the object to be named.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DebugMarkerObjectNameInfo.ObjectName">
            <summary>
            <para>
            pname:pObjectName is a null-terminated UTF-8 string specifying the name to apply to pname:object.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DebugMarkerObjectTagInfo">
            <summary>
            <para>
            Specify parameters of a tag to attach to an object.
            </para>
            <para>
            The pname:tagName parameter gives a name or identifier to the type of data being tagged. This can be used by debugging layers to easily filter for only data that can be used by that implementation.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DebugMarkerObjectTagInfo.ObjectType">
            <summary>
            <para>
            pname:objectType is a elink:VkDebugReportObjectTypeEXT specifying the type of the object to be named.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DebugMarkerObjectTagInfo.Object">
            <summary>
            <para>
            pname:object is the object to be tagged.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DebugMarkerObjectTagInfo.TagName">
            <summary>
            <para>
            pname:tagName is a numerical identifier of the tag.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DebugMarkerObjectTagInfo.Tag">
            <summary>
            <para>
            pname:pTag is an array of pname:tagSize bytes containing the data to be associated with the object.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DebugReportCallbackCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created debug report callback.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DebugReportCallbackCreateInfo.Flags">
            <summary>
            <para>
            pname:flags indicate which event(s) will cause this callback to be called. Flags are interpreted as bitmasks and multiple may be set. Bits which can: be set include: + --
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DebugReportCallbackCreateInfo.PfnCallback">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DebugReportCallbackCreateInfo.UserData">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DedicatedAllocationBufferCreateInfo">
            <summary>
            <para>
            Specify that a buffer is bound to a dedicated memory resource.
            </para>
            <para>
            If the pname:pNext list includes a sname:VkDedicatedAllocationBufferCreateInfoNV structure, then that structure includes an enable controlling whether the buffer will have a dedicated memory allocation bound to it.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DedicatedAllocationBufferCreateInfo.DedicatedAllocation">
            <summary>
            <para>
            pname:dedicatedAllocation indicates whether the buffer will have a dedicated allocation bound to it.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DedicatedAllocationImageCreateInfo">
            <summary>
            <para>
            Specify that an image is bound to a dedicated memory resource.
            </para>
            <para>
            If the pname:pNext list includes a sname:VkDedicatedAllocationImageCreateInfoNV structure, then that structure includes an enable controlling whether the image will have a dedicated memory allocation bound to it.
            </para>
            <para>
            [NOTE] .Note ==== Using a dedicated allocation for color and depth/stencil attachments or other large images may: improve performance on some devices. ====
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DedicatedAllocationImageCreateInfo.DedicatedAllocation">
            <summary>
            <para>
            pname:dedicatedAllocation indicates whether the image will have a dedicated allocation bound to it.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DedicatedAllocationMemoryAllocateInfo">
            <summary>
            <para>
            Specify a dedicated memory allocation resource.
            </para>
            <para>
            If the pname:pNext list includes a sname:VkDedicatedAllocationMemoryAllocateInfoNV structure, then that structure includes a handle of the sole buffer or image resource that the memory can: be bound to.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DedicatedAllocationMemoryAllocateInfo.Image">
            <summary>
            <para>
            pname:image is sname:VK_NULL_HANDLE or a handle of an image which this memory will be bound to.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DedicatedAllocationMemoryAllocateInfo.Buffer">
            <summary>
            <para>
            pname:buffer is sname:VK_NULL_HANDLE or a handle of a buffer which this memory will be bound to.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DescriptorBufferInfo">
            <summary>
            <para>
            Structure specifying descriptor buffer info.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorBufferInfo.Buffer">
            <summary>
            <para>
            pname:buffer is the buffer resource.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorBufferInfo.Offset">
            <summary>
            <para>
            pname:offset is the offset in bytes from the start of pname:buffer. Access to buffer memory via this descriptor uses addressing that is relative to this starting offset.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorBufferInfo.Range">
            <summary>
            <para>
            pname:range is the size in bytes that is used for this descriptor update, or ename:VK_WHOLE_SIZE to use the range from pname:offset to the end of the buffer. + -- [NOTE] .Note ==== When using ename:VK_WHOLE_SIZE, the effective range must: not be larger than the maximum range for the descriptor type (&lt;&lt;features-limits-maxUniformBufferRange, maxUniformBufferRange&gt;&gt; or &lt;&lt;features-limits-maxStorageBufferRange, maxStorageBufferRange&gt;&gt;). This means that ename:VK_WHOLE_SIZE is not typically useful in the common case where uniform buffer descriptors are suballocated from a buffer that is much larger than pname:maxUniformBufferRange. ==== -- + For ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC and ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC descriptor types, pname:offset is the base offset from which the dynamic offset is applied and pname:range is the static size used for all dynamic offsets.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DescriptorImageInfo">
            <summary>
            <para>
            Structure specifying descriptor image info.
            </para>
            <para>
            Members of sname:VkDescriptorImageInfo that are not used in an update (as described above) are ignored.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorImageInfo.Sampler">
            <summary>
            <para>
            pname:sampler is a sampler handle, and is used in descriptor updates for types ename:VK_DESCRIPTOR_TYPE_SAMPLER and ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER if the binding being updated does not use immutable samplers.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorImageInfo.ImageView">
            <summary>
            <para>
            pname:imageView is an image view handle, and is used in descriptor updates for types ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorImageInfo.ImageLayout">
            <summary>
            <para>
            pname:imageLayout is the layout that the image will be in at the time this descriptor is accessed. pname:imageLayout is used in descriptor updates for types ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DescriptorPoolCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created descriptor pool.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorPoolCreateInfo.Flags">
            <summary>
            <para>
            pname:flags specifies certain supported operations on the pool. Bits which can: be set include: + --
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorPoolCreateInfo.MaxSets">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorPoolCreateInfo.PoolSizes">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DescriptorSetAllocateInfo">
            <summary>
            <para>
            Structure specifying the allocation parameters for descriptor sets.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorSetAllocateInfo.DescriptorPool">
            <summary>
            <para>
            pname:descriptorPool is the pool which the sets will be allocated from.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorSetAllocateInfo.SetLayouts">
            <summary>
            <para>
            pname:pSetLayouts is an array of descriptor set layouts, with each member specifying how the corresponding descriptor set is allocated.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DescriptorSetLayoutBinding">
            <summary>
            <para>
            Structure specifying a descriptor set layout binding.
            </para>
            <para>
            The above layout definition allows the descriptor bindings to be specified sparsely such that not all binding numbers between 0 and the maximum binding number need to be specified in the pname:pBindings array. However, all binding numbers between 0 and the maximum binding number may: consume memory in the descriptor set layout even if not all descriptor bindings are used, though it should: not consume additional memory from the descriptor pool.
            </para>
            <para>
            [NOTE] .Note ==== The maximum binding number specified should: be as compact as possible to avoid wasted memory. ====
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorSetLayoutBinding.Binding">
            <summary>
            <para>
            pname:binding is the binding number of this entry and corresponds to a resource of the same binding number in the shader stages.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorSetLayoutBinding.DescriptorType">
            <summary>
            <para>
            pname:descriptorType is a elink:VkDescriptorType specifying which type of resource descriptors are used for this binding.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorSetLayoutBinding.DescriptorCount">
            <summary>
            <para>
            pname:descriptorCount is the number of descriptors contained in the binding, accessed in a shader as an array. If pname:descriptorCount is zero this binding entry is reserved and the resource must: not be accessed from any stage via this binding within any pipeline using the set layout.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorSetLayoutBinding.StageFlags">
            <summary>
            <para>
            pname:stageFlags member is a bitmask of elink:VkShaderStageFlagBits specifying which pipeline shader stages can: access a resource for this binding. ename:VK_SHADER_STAGE_ALL is a shorthand specifying that all defined shader stages, including any additional stages defined by extensions, can: access the resource. + -- If a shader stage is not included in pname:stageFlags, then a resource must: not be accessed from that stage via this binding within any pipeline using the set layout. There are no limitations on what combinations of stages can: be used by a descriptor binding, and in particular a binding can: be used by both graphics stages and the compute stage. --
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorSetLayoutBinding.ImmutableSamplers">
            <summary>
            <para>
            pname:pImmutableSamplers affects initialization of samplers. If pname:descriptorType specifies a ename:VK_DESCRIPTOR_TYPE_SAMPLER or ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER type descriptor, then pname:pImmutableSamplers can: be used to initialize a set of _immutable samplers_. Immutable samplers are permanently bound into the set layout; later binding a sampler into an immutable sampler slot in a descriptor set is not allowed. If pname:pImmutableSamplers is not `NULL`, then it is considered to be a pointer to an array of sampler handles that will be consumed by the set layout and used for the corresponding binding. If pname:pImmutableSamplers is `NULL`, then the sampler slots are dynamic and sampler handles must: be bound into descriptor sets using this layout. If pname:descriptorType is not one of these descriptor types, then pname:pImmutableSamplers is ignored.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DescriptorSetLayoutCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created descriptor set layout.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorSetLayoutCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorSetLayoutCreateInfo.Bindings">
            <summary>
            <para>
            pname:pBindings is a pointer to an array of slink:VkDescriptorSetLayoutBinding structures.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DeviceCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created device.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DeviceCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DeviceCreateInfo.QueueCreateInfos">
            <summary>
            <para>
            pname:pQueueCreateInfos is a pointer to an array of slink:VkDeviceQueueCreateInfo structures describing the queues that are requested to be created along with the logical device. Refer to the &lt;&lt;devsandqueues-queue-creation,Queue Creation&gt;&gt; section below for further details.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DeviceCreateInfo.EnabledLayerNames">
            <summary>
            <para>
            pname:ppEnabledLayerNames is deprecated and ignored. See &lt;&lt;extended-functionality-device-layer-deprecation,Device Layer Deprecation&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DeviceCreateInfo.EnabledExtensionNames">
            <summary>
            <para>
            pname:ppEnabledExtensionNames is a pointer to an array of pname:enabledExtensionCount null-terminated UTF-8 strings containing the names of extensions to enable for the created device. See the &lt;&lt;extended-functionality-extensions,Extensions&gt;&gt; section for further details.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DeviceCreateInfo.EnabledFeatures">
            <summary>
            <para>
            pname:pEnabledFeatures is `NULL` or a pointer to a slink:VkPhysicalDeviceFeatures structure that contains boolean indicators of all the features to be enabled. Refer to the &lt;&lt;features-features,Features&gt;&gt; section for further details.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DeviceQueueCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created device queue.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DeviceQueueCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DeviceQueueCreateInfo.QueueFamilyIndex">
            <summary>
            <para>
            pname:queueFamilyIndex is an unsigned integer indicating the index of the queue family to create on this device. This index corresponds to the index of an element of the pname:pQueueFamilyProperties array that was returned by fname:vkGetPhysicalDeviceQueueFamilyProperties.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DeviceQueueCreateInfo.QueuePriorities">
            <summary>
            <para>
            pname:pQueuePriorities is an array of pname:queueCount normalized floating point values, specifying priorities of work that will be submitted to each created queue. See &lt;&lt;devsandqueues-priority,Queue Priority&gt;&gt; for more information.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DisplayModeCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created display mode object.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DisplayModeCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use, and must: be zero.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DisplayModeCreateInfo.Parameters">
            <summary>
            <para>
            pname:parameters is a sname:VkDisplayModeParametersKHR structure describing the display parameters to use in creating the new mode. If the parameters are not compatible with the specified display, the implementation must: return ename:VK_ERROR_INITIALIZATION_FAILED.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DisplayModeProperties">
            <summary>
            <para>
            Structure describing display mode properties.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DisplayModeProperties.DisplayMode">
            <summary>
            <para>
            pname:displayMode is a handle to the display mode described in this structure. This handle will be valid for the lifetime of the Vulkan instance.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DisplayModeProperties.Parameters">
            <summary>
            <para>
            pname:parameters is a sname:VkDisplayModeParametersKHR structure describing the display parameters associated with pname:displayMode.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DisplayPlaneProperties">
            <summary>
            <para>
            Structure describing display plane properties.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DisplayPlaneProperties.CurrentDisplay">
            <summary>
            <para>
            pname:currentDisplay is the handle of the display the plane is currently associated with. If the plane is not currently attached to any displays, this will be sname:VK_NULL_HANDLE.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DisplayPlaneProperties.CurrentStackIndex">
            <summary>
            <para>
            pname:currentStackIndex is the current z-order of the plane. This will be between 0 and the value returned by fname:vkGetPhysicalDeviceDisplayPlanePropertiesKHR() in pname:pPropertyCount.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DisplayPresentInfo">
            <summary>
            <para>
            Structure describing parameters of a queue presentation to a swapchain.
            </para>
            <para>
            If the extent of the pname:srcRect and pname:dstRect are not equal, the presented pixels will be scaled accordingly.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DisplayPresentInfo.SourceRect">
            <summary>
            <para>
            pname:srcRect is a rectangular region of pixels to present. It must: be a subset of the image being presented. If sname:VkDisplayPresentInfoKHR is not specified, this region will be assumed to be the entire presentable image.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DisplayPresentInfo.DestinationRect">
            <summary>
            <para>
            pname:dstRect is a rectangular region within the visible region of the swapchain's display mode. If sname:VkDisplayPresentInfoKHR is not specified, this region will be assumed to be the entire visible region of the visible region of the swapchain's mode. If the specified rectangle is a subset of the display mode's visible region, content from display planes below the swapchain's plane will be visible outside the rectangle. If there are no planes below the swapchain's, the area outside the specified rectangle will be black. If portions of the specified rectangle are outside of the display's visible region, pixels mapping only to those portions of the rectangle will be discarded.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DisplayPresentInfo.Persistent">
            <summary>
            <para>
            pname:persistent: If this is ename:VK_TRUE, the display engine will enable buffered mode on displays that support it. This allows the display engine to stop sending content to the display until a new image is presented. The display will instead maintain a copy of the last presented image. This allows less power to be used, but may: increase presentation latency. If sname:VkDisplayPresentInfoKHR is not specified, persistent mode will not be used.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DisplayProperties">
            <summary>
            <para>
            Structure describing an available display device.
            </para>
            <para>
            [NOTE] .Note ==== For devices which have no natural value to return here, implementations should: return the maximum resolution supported. ====
            </para>
            <para>
            * pname:supportedTransforms tells which transforms are supported by this display. This will contain one or more of the bits from sname:VkSurfaceTransformFlagsKHR. * pname:planeReorderPossible tells whether the planes on this display can: have their z order changed. If this is ename:VK_TRUE, the application can: re-arrange the planes on this display in any order relative to each other. * pname:persistentContent tells whether the display supports self-refresh/internal buffering. If this is true, the application can: submit persistent present operations on swapchains created against this display.
            </para>
            <para>
            [NOTE] .Note ==== Persistent presents may: have higher latency, and may: use less power when the screen content is updated infrequently, or when only a portion of the screen needs to be updated in most frames. ====
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DisplayProperties.Display">
            <summary>
            <para>
            pname:display is a handle that is used to refer to the display described here. This handle will be valid for the lifetime of the Vulkan instance.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DisplayProperties.DisplayName">
            <summary>
            <para>
            pname:displayName is a pointer to a NULL-terminated string containing the name of the display. Generally, this will be the name provided by the display's EDID. It can: be `NULL` if no suitable name is available.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DisplayProperties.PhysicalDimensions">
            <summary>
            <para>
            pname:physicalDimensions describes the physical width and height of the visible portion of the display, in millimeters.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DisplayProperties.PhysicalResolution">
            <summary>
            <para>
            pname:physicalResolution describes the physical, native, or preferred resolution of the display.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DisplayProperties.SupportedTransforms">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DisplayProperties.PlaneReorderPossible">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DisplayProperties.PersistentContent">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DisplaySurfaceCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created display plane surface object.
            </para>
            <para>
            [NOTE] .Note ==== Creating a display surface must: not modify the state of the displays, planes, or other resources it names. For example, it must: not apply the specified mode to be set on the associated display. Application of display configuration occurs as a side effect of presenting to a display surface. ====
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DisplaySurfaceCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use, and must: be zero.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DisplaySurfaceCreateInfo.DisplayMode">
            <summary>
            <para>
            pname:displayMode is the mode to use when displaying this surface.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DisplaySurfaceCreateInfo.PlaneIndex">
            <summary>
            <para>
            pname:planeIndex is the plane on which this surface appears.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DisplaySurfaceCreateInfo.PlaneStackIndex">
            <summary>
            <para>
            pname:planeStackIndex is the z-order of the plane.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DisplaySurfaceCreateInfo.Transform">
            <summary>
            <para>
            pname:transform is the transform to apply to the images as part of the scanout operation.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DisplaySurfaceCreateInfo.GlobalAlpha">
            <summary>
            <para>
            pname:globalAlpha is the global alpha value. This value is ignored if pname:alphaMode is not ename:VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DisplaySurfaceCreateInfo.AlphaMode">
            <summary>
            <para>
            pname:alphaMode is the type of alpha blending to use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DisplaySurfaceCreateInfo.ImageExtent">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.EventCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created event.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.EventCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.ExportMemoryAllocateInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ExportMemoryAllocateInfo.HandleTypes">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.ExportMemoryWin32HandleInfo">
            <summary>
            <para>
            Specify security attributes and access rights for Win32 memory handles.
            </para>
            <para>
            When slink:VkExportMemoryAllocateInfoNV::pname:handleTypes includes ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV, add a sname:VkExportMemoryWin32HandleInfoNV to the pname:pNext chain of the slink:VkExportMemoryAllocateInfoNV structure to specify security attributes and access rights for the memory object's external handle.
            </para>
            <para>
            If this structure is not present, or if pname:pAttributes is set to `NULL`, default security descriptor values will be used, and child processes created by the application will not inherit the handle, as described in the MSDN documentation for ``Synchronization Object Security and Access Rights''[1]. Further, if the structure is not present, the access rights will be
            </para>
            <para>
            code:DXGI_SHARED_RESOURCE_READ | code:DXGI_SHARED_RESOURCE_WRITE
            </para>
            <para>
            [1] https://msdn.microsoft.com/en-us/library/windows/desktop/ms686670.aspx
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ExportMemoryWin32HandleInfo.Attributes">
            <summary>
            <para>
            pname:pAttributes is a pointer to a Windows code:SECURITY_ATTRIBUTES structure specifying security attributes of the handle.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ExportMemoryWin32HandleInfo.DwAccess">
            <summary>
            <para>
            pname:dwAccess is a code:DWORD specifying access rights of the handle.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.ExtensionProperties">
            <summary>
            <para>
            Structure specifying a extension properties.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ExtensionProperties.ExtensionName">
            <summary>
            <para>
            pname:extensionName is a null-terminated string specifying the name of the extension.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ExtensionProperties.SpecVersion">
            <summary>
            <para>
            pname:specVersion is the version of this extension. It is an integer, incremented with backward compatible changes.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.ExternalMemoryImageCreateInfo">
            <summary>
            <para>
            Specify that an image may be backed by external memory.
            </para>
            <para>
            If the pname:pNext list includes a sname:VkExternalMemoryImageCreateInfoNV structure, then that structure defines a set of external memory handle types that may: be used as backing store for the image.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ExternalMemoryImageCreateInfo.HandleTypes">
            <summary>
            <para>
            pname:handleTypes is a bitmask of elink:VkExternalMemoryHandleTypeFlagBitsNV specifying one or more external memory handle types. The types must: all be compatible with each other and the other image creation parameters, as reported by flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.FenceCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created fence.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.FenceCreateInfo.Flags">
            <summary>
            <para>
            pname:flags defines the initial state and behavior of the fence. Bits which can: be set include: + --
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.FramebufferCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created framebuffer.
            </para>
            <para>
            Image subresources used as attachments must: not be used via any non-attachment usage for the duration of a render pass instance.
            </para>
            <para>
            [NOTE] .Note ==== This restriction means that the render pass has full knowledge of all uses of all of the attachments, so that the implementation is able to make correct decisions about when and how to perform layout transitions, when to overlap execution of subpasses, etc. ====
            </para>
            <para>
            It is legal for a subpass to use no color or depth/stencil attachments, and rather use shader side effects such as image stores and atomics to produce an output. In this case, the subpass continues to use the pname:width, pname:height, and pname:layers of the framebuffer to define the dimensions of the rendering area, and the pname:rasterizationSamples from each pipeline's slink:VkPipelineMultisampleStateCreateInfo to define the number of samples used in rasterization; however, if slink:VkPhysicalDeviceFeatures::pname:variableMultisampleRate is code:VK_FALSE, then all pipelines to be bound with a given zero-attachment subpass must: have the same value for slink:VkPipelineMultisampleStateCreateInfo::pname:rasterizationSamples.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.FramebufferCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.FramebufferCreateInfo.RenderPass">
            <summary>
            <para>
            pname:renderPass is a render pass that defines what render passes the framebuffer will be compatible with. See &lt;&lt;renderpass-compatibility,Render Pass Compatibility&gt;&gt; for details.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.FramebufferCreateInfo.Attachments">
            <summary>
            <para>
            pname:pAttachments is an array of sname:VkImageView handles, each of which will be used as the corresponding attachment in a render pass instance.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.FramebufferCreateInfo.Width">
            <summary>
            <para>
            pname:width, pname:height and pname:layers define the dimensions of the framebuffer.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.FramebufferCreateInfo.Height">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.FramebufferCreateInfo.Layers">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.GraphicsPipelineCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created graphics pipeline.
            </para>
            <para>
            The parameters pname:basePipelineHandle and pname:basePipelineIndex are described in more detail in &lt;&lt;pipelines-pipeline-derivatives,Pipeline Derivatives&gt;&gt;.
            </para>
            <para>
            pname:pStages points to an array of slink:VkPipelineShaderStageCreateInfo structures, which were previously described in &lt;&lt;pipelines-compute,Compute Pipelines&gt;&gt;.
            </para>
            <para>
            Bits which can: be set in pname:flags are:
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is a bitmask of elink:VkPipelineCreateFlagBits controlling how the pipeline will be generated, as described below.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.Stages">
            <summary>
            <para>
            pname:pStages is an array of size pname:stageCount structures of type slink:VkPipelineShaderStageCreateInfo describing the set of the shader stages to be included in the graphics pipeline.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.VertexInputState">
            <summary>
            <para>
            pname:pVertexInputState is a pointer to an instance of the slink:VkPipelineVertexInputStateCreateInfo structure.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.InputAssemblyState">
            <summary>
            <para>
            pname:pInputAssemblyState is a pointer to an instance of the slink:VkPipelineInputAssemblyStateCreateInfo structure which determines input assembly behavior, as described in &lt;&lt;drawing, Drawing Commands&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.TessellationState">
            <summary>
            <para>
            pname:pTessellationState is a pointer to an instance of the slink:VkPipelineTessellationStateCreateInfo structure, or `NULL` if the pipeline does not include a tessellation control shader stage and tessellation evaluation shader stage.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.ViewportState">
            <summary>
            <para>
            pname:pViewportState is a pointer to an instance of the slink:VkPipelineViewportStateCreateInfo structure, or `NULL` if the pipeline has rasterization disabled.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.RasterizationState">
            <summary>
            <para>
            pname:pRasterizationState is a pointer to an instance of the slink:VkPipelineRasterizationStateCreateInfo structure.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.MultisampleState">
            <summary>
            <para>
            pname:pMultisampleState is a pointer to an instance of the slink:VkPipelineMultisampleStateCreateInfo, or `NULL` if the pipeline has rasterization disabled.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.DepthStencilState">
            <summary>
            <para>
            pname:pDepthStencilState is a pointer to an instance of the slink:VkPipelineDepthStencilStateCreateInfo structure, or `NULL` if the pipeline has rasterization disabled or if the subpass of the render pass the pipeline is created against does not use a depth/stencil attachment.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.ColorBlendState">
            <summary>
            <para>
            pname:pColorBlendState is a pointer to an instance of the slink:VkPipelineColorBlendStateCreateInfo structure, or `NULL` if the pipeline has rasterization disabled or if the subpass of the render pass the pipeline is created against does not use any color attachments.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.DynamicState">
            <summary>
            <para>
            pname:pDynamicState is a pointer to slink:VkPipelineDynamicStateCreateInfo and is used to indicate which properties of the pipeline state object are dynamic and can: be changed independently of the pipeline state. This can: be `NULL`, which means no state in the pipeline is considered dynamic.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.Layout">
            <summary>
            <para>
            pname:layout is the description of binding locations used by both the pipeline and descriptor sets used with the pipeline.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.RenderPass">
            <summary>
            <para>
            pname:renderPass is a handle to a render pass object describing the environment in which the pipeline will be used; the pipeline can: be used with an instance of any render pass compatible with the one provided. See &lt;&lt;renderpass-compatibility,Render Pass Compatibility&gt;&gt; for more information.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.Subpass">
            <summary>
            <para>
            pname:subpass is the index of the subpass in pname:renderPass where this pipeline will be used.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.BasePipelineHandle">
            <summary>
            <para>
            pname:basePipelineHandle is a pipeline to derive from.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.BasePipelineIndex">
            <summary>
            <para>
            pname:basePipelineIndex is an index into the pname:pCreateInfos parameter to use as a pipeline to derive from.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.ImageBlit">
            <summary>
            <para>
            Structure specifying an image blit operation.
            </para>
            <para>
            For each element of the pname:pRegions array, a blit operation is performed the specified source and destination regions.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageBlit.SourceSubresource">
            <summary>
            <para>
            pname:srcSubresource is the subresource to blit from.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageBlit.SourceOffsets">
            <summary>
            <para>
            pname:srcOffsets is an array of two slink:VkOffset3D structures specifying the bounds of the source region within pname:srcSubresource.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageBlit.DestinationSubresource">
            <summary>
            <para>
            pname:dstSubresource is the subresource to blit into.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageBlit.DestinationOffsets">
            <summary>
            <para>
            pname:dstOffsets is an array of two slink:VkOffset3D structures specifying the bounds of the destination region within pname:dstSubresource.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.ImageCreateInfo">
            <summary>
            <para>
            Structure specifying the parameters of a newly created image object.
            </para>
            <para>
            Valid limits for the image pname:extent, pname:mipLevels, pname:arrayLayers and pname:samples members are queried with the flink:vkGetPhysicalDeviceImageFormatProperties command.
            </para>
            <para>
            Images created with pname:tiling equal to ename:VK_IMAGE_TILING_LINEAR have further restrictions on their limits and capabilities compared to images created with pname:tiling equal to ename:VK_IMAGE_TILING_OPTIMAL. Creation of images with tiling ename:VK_IMAGE_TILING_LINEAR may: not be supported unless other parameters meet all of the constraints:
            </para>
            <para>
            * pname:imageType is ename:VK_IMAGE_TYPE_2D * pname:format is not a depth/stencil format * pname:mipLevels is 1 * pname:arrayLayers is 1 * pname:samples is ename:VK_SAMPLE_COUNT_1_BIT * pname:usage only includes ename:VK_IMAGE_USAGE_TRANSFER_SRC_BIT and/or ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT
            </para>
            <para>
            Implementations may: support additional limits and capabilities beyond those listed above. To determine the specific capabilities of an implementation, query the valid pname:usage bits by calling flink:vkGetPhysicalDeviceFormatProperties and the valid limits for pname:mipLevels and pname:arrayLayers by calling flink:vkGetPhysicalDeviceImageFormatProperties.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is a bitmask describing additional parameters of the image. See elink:VkImageCreateFlagBits below for a description of the supported bits.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageCreateInfo.ImageType">
            <summary>
            <para>
            pname:imageType is a elink:VkImageType specifying the basic dimensionality of the image, as described below. Layers in array textures do not count as a dimension for the purposes of the image type.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageCreateInfo.Format">
            <summary>
            <para>
            pname:format is a elink:VkFormat describing the format and type of the data elements that will be contained in the image.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageCreateInfo.Extent">
            <summary>
            <para>
            pname:extent is a slink:VkExtent3D describing the number of data elements in each dimension of the base level.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageCreateInfo.MipLevels">
            <summary>
            <para>
            pname:mipLevels describes the number of levels of detail available for minified sampling of the image.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageCreateInfo.ArrayLayers">
            <summary>
            <para>
            pname:arrayLayers is the number of layers in the image.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageCreateInfo.Samples">
            <summary>
            <para>
            pname:samples is the number of sub-data element samples in the image as defined in elink:VkSampleCountFlagBits. See &lt;&lt;primsrast-multisampling,Multisampling&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageCreateInfo.Tiling">
            <summary>
            <para>
            pname:tiling is a elink:VkImageTiling specifying the tiling arrangement of the data elements in memory, as described below.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageCreateInfo.Usage">
            <summary>
            <para>
            pname:usage is a bitmask describing the intended usage of the image. See elink:VkImageUsageFlagBits below for a description of the supported bits.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageCreateInfo.SharingMode">
            <summary>
            <para>
            pname:sharingMode is the sharing mode of the image when it will be accessed by multiple queue families, and must: be one of the values described for elink:VkSharingMode in the &lt;&lt;resources-sharing,Resource Sharing&gt;&gt; section below.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageCreateInfo.QueueFamilyIndices">
            <summary>
            <para>
            pname:pQueueFamilyIndices is a list of queue families that will access this image (ignored if pname:sharingMode is not ename:VK_SHARING_MODE_CONCURRENT).
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageCreateInfo.InitialLayout">
            <summary>
            <para>
            pname:initialLayout selects the initial elink:VkImageLayout state of all image subresources of the image. See &lt;&lt;resources-image-layouts,Image Layouts&gt;&gt;. pname:initialLayout must: be ename:VK_IMAGE_LAYOUT_UNDEFINED or ename:VK_IMAGE_LAYOUT_PREINITIALIZED.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.ImageMemoryBarrier">
            <summary>
            <para>
            Structure specifying the parameters of an image memory barrier.
            </para>
            <para>
            If pname:oldLayout differs from pname:newLayout, a layout transition occurs as part of the image memory barrier, affecting the data contained in the region of the image defined by the pname:subresourceRange. If pname:oldLayout is ename:VK_IMAGE_LAYOUT_UNDEFINED, then the data is undefined after the layout transition. This may: allow a more efficient transition, since the data may: be discarded. The layout transition must: occur after all operations using the old layout are completed and before all operations using the new layout are started. This is achieved by ensuring that there is a memory dependency between previous accesses and the layout transition, as well as between the layout transition and subsequent accesses, where the layout transition occurs between the two halves of a memory dependency in an image memory barrier.
            </para>
            <para>
            Layout transitions that are performed via image memory barriers are automatically ordered against other layout transitions, including those that occur as part of a render pass instance.
            </para>
            <para>
            [NOTE] .Note ==== See &lt;&lt;resources-image-layouts&gt;&gt; for details on available image layouts and their usages. ====
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageMemoryBarrier.SourceAccessMask">
            <summary>
            <para>
            pname:srcAccessMask is a bitmask of the classes of memory accesses performed by the first set of commands that will participate in the dependency.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageMemoryBarrier.DestinationAccessMask">
            <summary>
            <para>
            pname:dstAccessMask is a bitmask of the classes of memory accesses performed by the second set of commands that will participate in the dependency.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageMemoryBarrier.OldLayout">
            <summary>
            <para>
            pname:oldLayout describes the current layout of the image subresource(s).
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageMemoryBarrier.NewLayout">
            <summary>
            <para>
            pname:newLayout describes the new layout of the image subresource(s).
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageMemoryBarrier.SourceQueueFamilyIndex">
            <summary>
            <para>
            pname:srcQueueFamilyIndex is the queue family that is relinquishing ownership of the image subresource(s) to another queue, or ename:VK_QUEUE_FAMILY_IGNORED if there is no transfer of ownership).
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageMemoryBarrier.DestinationQueueFamilyIndex">
            <summary>
            <para>
            pname:dstQueueFamilyIndex is the queue family that is acquiring ownership of the image subresource(s) from another queue, or ename:VK_QUEUE_FAMILY_IGNORED if there is no transfer of ownership).
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageMemoryBarrier.Image">
            <summary>
            <para>
            pname:image is a handle to the image whose backing memory is affected by the barrier.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageMemoryBarrier.SubresourceRange">
            <summary>
            <para>
            pname:subresourceRange describes an area of the backing memory for pname:image (see &lt;&lt;resources-image-views&gt;&gt; for the description of sname:VkImageSubresourceRange), as well as the set of image subresources whose image layouts are modified.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.ImageViewCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created image view.
            </para>
            <para>
            If pname:image was created with the ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, pname:format can: be different from the image's format, but if they are not equal they must: be _compatible_. Image format compatibility is defined in the &lt;&lt;features-formats-compatibility-classes,Format Compatibility Classes&gt;&gt; section.
            </para>
            <para>
            .Image and image view parameter compatibility requirements [cols="15%h,35%,50%",options="header"] |==== | Dim, Arrayed, MS | Image parameters | View parameters | | pname:imageType = ci.pname:imageType + pname:width = ci.pname:extent.width + pname:height = ci.pname:extent.height + pname:depth = ci.pname:extent.depth + pname:arrayLayers = ci.pname:arrayLayers + pname:samples = ci.pname:samples + where ci is the slink:VkImageCreateInfo used to create pname:image. | pname:baseArrayLayer and pname:layerCount are members of the pname:subresourceRange member. | 1D, 0, 0 | pname:imageType = ename:VK_IMAGE_TYPE_1D + pname:width {geq} 1 + pname:height = 1 + pname:depth = 1 + pname:arrayLayers {geq} 1 + pname:samples = 1 | pname:viewType = ename:VK_VIEW_TYPE_1D + pname:baseArrayLayer {geq} 0 + pname:layerCount = 1 | 1D, 1, 0 | pname:imageType = ename:VK_IMAGE_TYPE_1D + pname:width {geq} 1 + pname:height = 1 + pname:depth = 1 + pname:arrayLayers {geq} 1 + pname:samples = 1 | pname:viewType = ename:VK_VIEW_TYPE_1D_ARRAY + pname:baseArrayLayer {geq} 0 + pname:layerCount {geq} 1 | 2D, 0, 0 | pname:imageType = ename:VK_IMAGE_TYPE_2D + pname:width {geq} 1 + pname:height {geq} 1 + pname:depth = 1 + pname:arrayLayers {geq} 1 + pname:samples = 1 | pname:viewType = ename:VK_VIEW_TYPE_2D + pname:baseArrayLayer {geq} 0 + pname:layerCount = 1 | 2D, 1, 0 | pname:imageType = ename:VK_IMAGE_TYPE_2D + pname:width {geq} 1 + pname:height {geq} 1 + pname:depth = 1 + pname:arrayLayers {geq} 1 + pname:samples = 1 | pname:viewType = ename:VK_VIEW_TYPE_2D_ARRAY + pname:baseArrayLayer {geq} 0 + pname:layerCount {geq} 1 | 2D, 0, 1 | pname:imageType = ename:VK_IMAGE_TYPE_2D + pname:width {geq} 1 + pname:height {geq} 1 + pname:depth = 1 + pname:arrayLayers {geq} 1 + pname:samples &gt; 1 | pname:viewType = ename:VK_VIEW_TYPE_2D + pname:baseArrayLayer {geq} 0 + pname:layerCount = 1 | 2D, 1, 1 | pname:imageType = ename:VK_IMAGE_TYPE_2D + pname:width {geq} 1 + pname:height {geq} 1 + pname:depth = 1 + pname:arrayLayers {geq} 1 + pname:samples &gt; 1 | pname:viewType = ename:VK_VIEW_TYPE_2D_ARRAY + pname:baseArrayLayer {geq} 0 + pname:layerCount {geq} 1 | CUBE, 0, 0 | pname:imageType = ename:VK_IMAGE_TYPE_2D + pname:width {geq} 1 + pname:height = pname:width + pname:depth = 1 + pname:arrayLayers {geq} 6 + pname:samples = 1 + pname:flags includes ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT | pname:viewType = ename:VK_VIEW_TYPE_CUBE + pname:baseArrayLayer {geq} 0 + pname:layerCount = 6 | CUBE, 1, 0 | pname:imageType = ename:VK_IMAGE_TYPE_2D + pname:width {geq} 1 + pname:height = width + pname:depth = 1 + _N_ {geq} 1 + pname:arrayLayers {geq} 6 {times} _N_ + pname:samples = 1 + pname:flags includes ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT | pname:viewType = ename:VK_VIEW_TYPE_CUBE_ARRAY + pname:baseArrayLayer {geq} 0 + pname:layerCount = 6 {times} _N_, _N_ {geq} 1 | 3D, 0, 0 | pname:imageType = ename:VK_IMAGE_TYPE_3D + pname:width {geq} 1 + pname:height {geq} 1 + pname:depth {geq} 1 + pname:arrayLayers = 1 + pname:samples = 1 | pname:viewType = ename:VK_VIEW_TYPE_3D + pname:baseArrayLayer = 0 + pname:layerCount = 1 |====
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageViewCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageViewCreateInfo.Image">
            <summary>
            <para>
            pname:image is a sname:VkImage on which the view will be created.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageViewCreateInfo.ViewType">
            <summary>
            <para>
            pname:viewType is the type of the image view.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageViewCreateInfo.Format">
            <summary>
            <para>
            pname:format is a elink:VkFormat describing the format and type used to interpret data elements in the image.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageViewCreateInfo.Components">
            <summary>
            <para>
            pname:components specifies a remapping of color components (or of depth or stencil components after they have been converted into color components). See slink:VkComponentMapping.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageViewCreateInfo.SubresourceRange">
            <summary>
            <para>
            pname:subresourceRange is a slink:VkImageSubresourceRange selecting the set of mipmap levels and array layers to be accessible to the view.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.ImportMemoryWin32HandleInfo">
            <summary>
            <para>
            Import Win32 memory created on the same physical device.
            </para>
            <para>
            To import memory created on the same physical device but outside of the current Vulkan instance, add a slink:VkImportMemoryWin32HandleInfoNV structure to the pname:pNext chain of the slink:VkMemoryAllocateInfo structure, specifying a handle to and the type of the memory.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImportMemoryWin32HandleInfo.HandleType">
            <summary>
            <para>
            pname:handleType is 0 or a flag specifying the type of memory handle in pname:handle. Flags which may: be specified are: + --
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImportMemoryWin32HandleInfo.Handle">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.InstanceCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created instance.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.InstanceCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.InstanceCreateInfo.ApplicationInfo">
            <summary>
            <para>
            pname:pApplicationInfo is `NULL` or a pointer to an instance of sname:VkApplicationInfo. If not `NULL`, this information helps implementations recognize behavior inherent to classes of applications. slink:VkApplicationInfo is defined in detail below.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.InstanceCreateInfo.EnabledLayerNames">
            <summary>
            <para>
            pname:ppEnabledLayerNames is a pointer to an array of pname:enabledLayerCount null-terminated UTF-8 strings containing the names of layers to enable for the created instance. See the &lt;&lt;extended-functionality-layers,Layers&gt;&gt; section for further details.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.InstanceCreateInfo.EnabledExtensionNames">
            <summary>
            <para>
            pname:ppEnabledExtensionNames is a pointer to an array of pname:enabledExtensionCount null-terminated UTF-8 strings containing the names of extensions to enable.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.LayerProperties">
            <summary>
            <para>
            Structure specifying layer properties.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.LayerProperties.LayerName">
            <summary>
            <para>
            pname:layerName is a null-terminated UTF-8 string specifying the name of the layer. Use this name in the pname:ppEnabledLayerNames array passed in the slink:VkInstanceCreateInfo structure to enable this layer for an instance.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.LayerProperties.SpecVersion">
            <summary>
            <para>
            pname:specVersion is the Vulkan version the layer was written to, encoded as described in the &lt;&lt;fundamentals-versionnum,API Version Numbers and Semantics&gt;&gt; section.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.LayerProperties.ImplementationVersion">
            <summary>
            <para>
            pname:implementationVersion is the version of this layer. It is an integer, increasing with backward compatible changes.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.LayerProperties.Description">
            <summary>
            <para>
            pname:description is a null-terminated UTF-8 string providing additional details that can: be used by the application to identify the layer.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.MappedMemoryRange">
            <summary>
            <para>
            Structure specifying a mapped memory range.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.MappedMemoryRange.Memory">
            <summary>
            <para>
            pname:memory is the memory object to which this range belongs.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.MappedMemoryRange.Offset">
            <summary>
            <para>
            pname:offset is the zero-based byte offset from the beginning of the memory object.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.MappedMemoryRange.Size">
            <summary>
            <para>
            pname:size is either the size of range, or ename:VK_WHOLE_SIZE to affect the range from pname:offset to the end of the current mapping of the allocation.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.MemoryAllocateInfo">
            <summary>
            <para>
            Structure containing parameters of a memory allocation.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.MemoryAllocateInfo.AllocationSize">
            <summary>
            <para>
            pname:allocationSize is the size of the allocation in bytes
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.MemoryAllocateInfo.MemoryTypeIndex">
            <summary>
            <para>
            pname:memoryTypeIndex is the memory type index, which selects the properties of the memory to be allocated, as well as the heap the memory will come from.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.MemoryBarrier">
            <summary>
            <para>
            Structure specifying a memory barrier.
            </para>
            <para>
            pname:srcAccessMask and pname:dstAccessMask, along with pname:srcStageMask and pname:dstStageMask from flink:vkCmdPipelineBarrier, define the two halves of a memory dependency and an execution dependency. Memory accesses using the set of access types in pname:srcAccessMask performed in pipeline stages in pname:srcStageMask by the first set of commands must: complete and be available to later commands. The side effects of the first set of commands will be visible to memory accesses using the set of access types in pname:dstAccessMask performed in pipeline stages in pname:dstStageMask by the second set of commands. If the barrier is by-region, these requirements only apply to invocations within the same framebuffer-space region, for pipeline stages that perform framebuffer-space work. The execution dependency guarantees that execution of work by the destination stages of the second set of commands will not begin until execution of work by the source stages of the first set of commands has completed.
            </para>
            <para>
            A common type of memory dependency is to avoid a read-after-write hazard. In this case, the source access mask and stages will include writes from a particular stage, and the destination access mask and stages will indicate how those writes will be read in subsequent commands. However, barriers can: also express write-after-read dependencies and write-after-write dependencies, and are even useful to express read-after-read dependencies across an image layout change.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.MemoryBarrier.SourceAccessMask">
            <summary>
            <para>
            pname:srcAccessMask is a bitmask of the classes of memory accesses performed by the first set of commands that will participate in the dependency.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.MemoryBarrier.DestinationAccessMask">
            <summary>
            <para>
            pname:dstAccessMask is a bitmask of the classes of memory accesses performed by the second set of commands that will participate in the dependency.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.MirSurfaceCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created Mir surface object.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.MirSurfaceCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.MirSurfaceCreateInfo.Connection">
            <summary>
            <para>
            pname:connection and pname:surface are pointers to the code:MirConnection and code:MirSurface for the window to associate the surface with.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.MirSurfaceCreateInfo.MirSurface">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PhysicalDeviceLimits">
            <summary>
            <para>
            Structure reporting implementation-dependent physical device limits.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxImageDimension1D">
            <summary>
            <para>
            pname:maxImageDimension1D is the maximum dimension (pname:width) of an image created with an pname:imageType of ename:VK_IMAGE_TYPE_1D.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxImageDimension2D">
            <summary>
            <para>
            pname:maxImageDimension2D is the maximum dimension (pname:width or pname:height) of an image created with an pname:imageType of ename:VK_IMAGE_TYPE_2D and without ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT set in pname:flags.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxImageDimension3D">
            <summary>
            <para>
            pname:maxImageDimension3D is the maximum dimension (pname:width, pname:height, or pname:depth) of an image created with an pname:imageType of ename:VK_IMAGE_TYPE_3D.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxImageDimensionCube">
            <summary>
            <para>
            pname:maxImageDimensionCube is the maximum dimension (pname:width or pname:height) of an image created with an pname:imageType of ename:VK_IMAGE_TYPE_2D and with ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT set in pname:flags.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxImageArrayLayers">
            <summary>
            <para>
            pname:maxImageArrayLayers is the maximum number of layers (pname:arrayLayers) for an image.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxTexelBufferElements">
            <summary>
            <para>
            pname:maxTexelBufferElements is the maximum number of addressable texels for a buffer view created on a buffer which was created with the ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT set in the pname:usage member of the sname:VkBufferCreateInfo structure.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxUniformBufferRange">
            <summary>
            <para>
            pname:maxUniformBufferRange is the maximum value that can: be specified in the pname:range member of any slink:VkDescriptorBufferInfo structures passed to a call to flink:vkUpdateDescriptorSets for descriptors of type ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxStorageBufferRange">
            <summary>
            <para>
            pname:maxStorageBufferRange is the maximum value that can: be specified in the pname:range member of any slink:VkDescriptorBufferInfo structures passed to a call to flink:vkUpdateDescriptorSets for descriptors of type ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxPushConstantsSize">
            <summary>
            <para>
            pname:maxPushConstantsSize is the maximum size, in bytes, of the pool of push constant memory. For each of the push constant ranges indicated by the pname:pPushConstantRanges member of the sname:VkPipelineLayoutCreateInfo structure, pname:offset + pname:size must: be less than or equal to this limit.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxMemoryAllocationCount">
            <summary>
            <para>
             pname:maxMemoryAllocationCount is the maximum number of device memory allocations, as created by flink:vkAllocateMemory, which can: simultaneously exist.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxSamplerAllocationCount">
            <summary>
            <para>
             pname:maxSamplerAllocationCount is the maximum number of sampler objects, as created by flink:vkCreateSampler, which can: simultaneously exist on a device.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.BufferImageGranularity">
            <summary>
            <para>
            pname:bufferImageGranularity is the granularity, in bytes, at which buffer or linear image resources, and optimal image resources can: be bound to adjacent offsets in the same sname:VkDeviceMemory object without aliasing. See &lt;&lt;resources-bufferimagegranularity,Buffer-Image Granularity&gt;&gt; for more details.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.SparseAddressSpaceSize">
            <summary>
            <para>
            pname:sparseAddressSpaceSize is the total amount of address space available, in bytes, for sparse memory resources. This is an upper bound on the sum of the size of all sparse resources, regardless of whether any memory is bound to them.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxBoundDescriptorSets">
            <summary>
            <para>
            pname:maxBoundDescriptorSets is the maximum number of descriptor sets that can: be simultaneously used by a pipeline. All code:DescriptorSet decorations in shader modules must: have a value less than pname:maxBoundDescriptorSets. See &lt;&lt;descriptorsets-sets&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxPerStageDescriptorSamplers">
            <summary>
            <para>
             pname:maxPerStageDescriptorSamplers is the maximum number of samplers that can: be accessible to a single shader stage in a pipeline layout. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_SAMPLER or ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER count against this limit. A descriptor is accessible to a shader stage when the pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. See &lt;&lt;descriptorsets-sampler&gt;&gt; and &lt;&lt;descriptorsets-combinedimagesampler&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxPerStageDescriptorUniformBuffers">
            <summary>
            <para>
             pname:maxPerStageDescriptorUniformBuffers is the maximum number of uniform buffers that can: be accessible to a single shader stage in a pipeline layout. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this limit. A descriptor is accessible to a shader stage when the pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. See &lt;&lt;descriptorsets-uniformbuffer&gt;&gt; and &lt;&lt;descriptorsets-uniformbufferdynamic&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxPerStageDescriptorStorageBuffers">
            <summary>
            <para>
             pname:maxPerStageDescriptorStorageBuffers is the maximum number of storage buffers that can: be accessible to a single shader stage in a pipeline layout. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this limit. A descriptor is accessible to a pipeline shader stage when the pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. See &lt;&lt;descriptorsets-storagebuffer&gt;&gt; and &lt;&lt;descriptorsets-storagebufferdynamic&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxPerStageDescriptorSampledImages">
            <summary>
            <para>
             pname:maxPerStageDescriptorSampledImages is the maximum number of sampled images that can: be accessible to a single shader stage in a pipeline layout. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, or ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER count against this limit. A descriptor is accessible to a pipeline shader stage when the pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. See &lt;&lt;descriptorsets-combinedimagesampler&gt;&gt;, &lt;&lt;descriptorsets-sampledimage&gt;&gt;, and &lt;&lt;descriptorsets-uniformtexelbuffer&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxPerStageDescriptorStorageImages">
            <summary>
            <para>
             pname:maxPerStageDescriptorStorageImages is the maximum number of storage images that can: be accessible to a single shader stage in a pipeline layout. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER count against this limit. A descriptor is accessible to a pipeline shader stage when the pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. See &lt;&lt;descriptorsets-storageimage&gt;&gt;, and &lt;&lt;descriptorsets-storagetexelbuffer&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxPerStageDescriptorInputAttachments">
            <summary>
            <para>
             pname:maxPerStageDescriptorInputAttachments is the maximum number of input attachments that can: be accessible to a single shader stage in a pipeline layout. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT count against this limit. A descriptor is accessible to a pipeline shader stage when the pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. These are only supported for the fragment stage. See &lt;&lt;descriptorsets-inputattachment&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxPerStageResources">
            <summary>
            <para>
            pname:maxPerStageResources is the maximum number of resources that can: be accessible to a single shader stage in a pipeline layout. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, or ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT count against this limit. For the fragment shader stage the framebuffer color attachments also count against this limit.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxDescriptorSetSamplers">
            <summary>
            <para>
             pname:maxDescriptorSetSamplers is the maximum number of samplers that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_SAMPLER or ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER count against this limit. See &lt;&lt;descriptorsets-sampler&gt;&gt; and &lt;&lt;descriptorsets-combinedimagesampler&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxDescriptorSetUniformBuffers">
            <summary>
            <para>
             pname:maxDescriptorSetUniformBuffers is the maximum number of uniform buffers that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this limit. See &lt;&lt;descriptorsets-uniformbuffer&gt;&gt; and &lt;&lt;descriptorsets-uniformbufferdynamic&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxDescriptorSetUniformBuffersDynamic">
            <summary>
            <para>
             pname:maxDescriptorSetUniformBuffersDynamic is the maximum number of dynamic uniform buffers that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this limit. See &lt;&lt;descriptorsets-uniformbufferdynamic&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxDescriptorSetStorageBuffers">
            <summary>
            <para>
             pname:maxDescriptorSetStorageBuffers is the maximum number of storage buffers that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this limit. See &lt;&lt;descriptorsets-storagebuffer&gt;&gt; and &lt;&lt;descriptorsets-storagebufferdynamic&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxDescriptorSetStorageBuffersDynamic">
            <summary>
            <para>
             pname:maxDescriptorSetStorageBuffersDynamic is the maximum number of dynamic storage buffers that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this limit. See &lt;&lt;descriptorsets-storagebufferdynamic&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxDescriptorSetSampledImages">
            <summary>
            <para>
             pname:maxDescriptorSetSampledImages is the maximum number of sampled images that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, or ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER count against this limit. See &lt;&lt;descriptorsets-combinedimagesampler&gt;&gt;, &lt;&lt;descriptorsets-sampledimage&gt;&gt;, and &lt;&lt;descriptorsets-uniformtexelbuffer&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxDescriptorSetStorageImages">
            <summary>
            <para>
             pname:maxDescriptorSetStorageImages is the maximum number of storage images that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER count against this limit. See &lt;&lt;descriptorsets-storageimage&gt;&gt;, and &lt;&lt;descriptorsets-storagetexelbuffer&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxDescriptorSetInputAttachments">
            <summary>
            <para>
             pname:maxDescriptorSetInputAttachments is the maximum number of input attachments that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT count against this limit. See &lt;&lt;descriptorsets-inputattachment&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxVertexInputAttributes">
            <summary>
            <para>
             pname:maxVertexInputAttributes is the maximum number of vertex input attributes that can: be specified for a graphics pipeline. These are described in the array of sname:VkVertexInputAttributeDescription structures that are provided at graphics pipeline creation time via the pname:pVertexAttributeDescriptions member of the sname:VkPipelineVertexInputStateCreateInfo structure. See &lt;&lt;fxvertex-attrib&gt;&gt; and &lt;&lt;fxvertex-input&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxVertexInputBindings">
            <summary>
            <para>
            pname:maxVertexInputBindings is the maximum number of vertex buffers that can: be specified for providing vertex attributes to a graphics pipeline. These are described in the array of sname:VkVertexInputBindingDescription structures that are provided at graphics pipeline creation time via the pname:pVertexBindingDescriptions member of the sname:VkPipelineVertexInputStateCreateInfo structure. The pname:binding member of sname:VkVertexInputBindingDescription must: be less than this limit. See &lt;&lt;fxvertex-input&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxVertexInputAttributeOffset">
            <summary>
            <para>
             pname:maxVertexInputAttributeOffset is the maximum vertex input attribute offset that can: be added to the vertex input binding stride. The pname:offset member of the sname:VkVertexInputAttributeDescription structure must: be less than or equal to this limit. See &lt;&lt;fxvertex-input&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxVertexInputBindingStride">
            <summary>
            <para>
             pname:maxVertexInputBindingStride is the maximum vertex input binding stride that can: be specified in a vertex input binding. The pname:stride member of the sname:VkVertexInputBindingDescription structure must: be less than or equal to this limit. See &lt;&lt;fxvertex-input&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxVertexOutputComponents">
            <summary>
            <para>
             pname:maxVertexOutputComponents is the maximum number of components of output variables which can: be output by a vertex shader. See &lt;&lt;shaders-vertex&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxTessellationGenerationLevel">
            <summary>
            <para>
             pname:maxTessellationGenerationLevel is the maximum tessellation generation level supported by the fixed-function tessellation primitive generator. See &lt;&lt;tessellation&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxTessellationPatchSize">
            <summary>
            <para>
             pname:maxTessellationPatchSize is the maximum patch size, in vertices, of patches that can: be processed by the tessellation control shader and tessellation primitive generator. The pname:patchControlPoints member of the sname:VkPipelineTessellationStateCreateInfo structure specified at pipeline creation time and the value provided in the code:OutputVertices execution mode of shader modules must: be less than or equal to this limit. See &lt;&lt;tessellation&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxTessellationControlPerVertexInputComponents">
            <summary>
            <para>
             pname:maxTessellationControlPerVertexInputComponents is the maximum number of components of input variables which can: be provided as per-vertex inputs to the tessellation control shader stage.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxTessellationControlPerVertexOutputComponents">
            <summary>
            <para>
             pname:maxTessellationControlPerVertexOutputComponents is the maximum number of components of per-vertex output variables which can: be output from the tessellation control shader stage.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxTessellationControlPerPatchOutputComponents">
            <summary>
            <para>
             pname:maxTessellationControlPerPatchOutputComponents is the maximum number of components of per-patch output variables which can: be output from the tessellation control shader stage.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxTessellationControlTotalOutputComponents">
            <summary>
            <para>
             pname:maxTessellationControlTotalOutputComponents is the maximum total number of components of per-vertex and per-patch output variables which can: be output from the tessellation control shader stage.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxTessellationEvaluationInputComponents">
            <summary>
            <para>
             pname:maxTessellationEvaluationInputComponents is the maximum number of components of input variables which can: be provided as per-vertex inputs to the tessellation evaluation shader stage.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxTessellationEvaluationOutputComponents">
            <summary>
            <para>
             pname:maxTessellationEvaluationOutputComponents is the maximum number of components of per-vertex output variables which can: be output from the tessellation evaluation shader stage.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxGeometryShaderInvocations">
            <summary>
            <para>
             pname:maxGeometryShaderInvocations is the maximum invocation count supported for instanced geometry shaders. The value provided in the code:Invocations execution mode of shader modules must: be less than or equal to this limit. See &lt;&lt;geometry&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxGeometryInputComponents">
            <summary>
            <para>
             pname:maxGeometryInputComponents is the maximum number of components of input variables which can: be provided as inputs to the geometry shader stage.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxGeometryOutputComponents">
            <summary>
            <para>
             pname:maxGeometryOutputComponents is the maximum number of components of output variables which can: be output from the geometry shader stage.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxGeometryOutputVertices">
            <summary>
            <para>
             pname:maxGeometryOutputVertices is the maximum number of vertices which can: be emitted by any geometry shader.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxGeometryTotalOutputComponents">
            <summary>
            <para>
             pname:maxGeometryTotalOutputComponents is the maximum total number of components of output, across all emitted vertices, which can: be output from the geometry shader stage.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxFragmentInputComponents">
            <summary>
            <para>
             pname:maxFragmentInputComponents is the maximum number of components of input variables which can: be provided as inputs to the fragment shader stage.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxFragmentOutputAttachments">
            <summary>
            <para>
             pname:maxFragmentOutputAttachments is the maximum number of output attachments which can: be written to by the fragment shader stage.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxFragmentDualSourceAttachments">
            <summary>
            <para>
             pname:maxFragmentDualSrcAttachments is the maximum number of output attachments which can: be written to by the fragment shader stage when blending is enabled and one of the dual source blend modes is in use. See &lt;&lt;framebuffer-dsb&gt;&gt; and &lt;&lt;features-features-dualSrcBlend,dualSrcBlend&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxFragmentCombinedOutputResources">
            <summary>
            <para>
             pname:maxFragmentCombinedOutputResources is the total number of storage buffers, storage images, and output buffers which can: be used in the fragment shader stage.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxComputeSharedMemorySize">
            <summary>
            <para>
             pname:maxComputeSharedMemorySize is the maximum total storage size, in bytes, of all variables declared with the code:WorkgroupLocal storage class in shader modules (or with the code:shared storage qualifier in GLSL) in the compute shader stage.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxComputeWorkGroupCount">
            <summary>
            <para>
             pname:maxComputeWorkGroupCount[3] is the maximum number of local workgroups that can: be dispatched by a single dispatch command. These three values represent the maximum number of local workgroups for the X, Y, and Z dimensions, respectively. The pname:x, pname:y, and pname:z parameters to the flink:vkCmdDispatch command, or members of the slink:VkDispatchIndirectCommand structure must: be less than or equal to the corresponding limit. See &lt;&lt;dispatch&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxComputeWorkGroupInvocations">
            <summary>
            <para>
             pname:maxComputeWorkGroupInvocations is the maximum total number of compute shader invocations in a single local workgroup. The product of the X, Y, and Z sizes as specified by the code:LocalSize execution mode in shader modules and by the object decorated by the code:WorkgroupSize decoration must: be less than or equal to this limit.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxComputeWorkGroupSize">
            <summary>
            <para>
             pname:maxComputeWorkGroupSize[3] is the maximum size of a local compute workgroup, per dimension. These three values represent the maximum local workgroup size in the X, Y, and Z dimensions, respectively. The pname:x, pname:y, and pname:z sizes specified by the code:LocalSize execution mode and by the object decorated by the code:WorkgroupSize decoration in shader modules must: be less than or equal to the corresponding limit.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.SubPixelPrecisionBits">
            <summary>
            <para>
            pname:subPixelPrecisionBits is the number of bits of subpixel precision in framebuffer coordinates latexmath:[$x_f$] and latexmath:[$y_f$]. See &lt;&lt;primsrast&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.SubTexelPrecisionBits">
            <summary>
            <para>
            pname:subTexelPrecisionBits is the number of bits of precision in the division along an axis of an image used for minification and magnification filters. latexmath:[$2^\mathit{subTexelPrecisionBits}$] is the actual number of divisions along each axis of the image represented. The filtering hardware will snap to these locations when computing the filtered results.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MipmapPrecisionBits">
            <summary>
            <para>
            pname:mipmapPrecisionBits is the number of bits of division that the LOD calculation for mipmap fetching get snapped to when determining the contribution from each mip level to the mip filtered results. latexmath:[$2^\mathit{mipmapPrecisionBits}$] is the actual number of divisions. + -- [NOTE] .Note ==== For example, if this value is 2 bits then when linearly filtering between two levels, each level could: contribute: 0%, 33%, 66%, or 100% (this is just an example and the amount of contribution should: be covered by different equations in the spec). ==== -- +
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxDrawIndexedIndexValue">
            <summary>
            <para>
             pname:maxDrawIndexedIndexValue is the maximum index value that can: be used for indexed draw calls when using 32-bit indices. This excludes the primitive restart index value of 0xFFFFFFFF. See &lt;&lt;features-features-fullDrawIndexUint32,fullDrawIndexUint32&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxDrawIndirectCount">
            <summary>
            <para>
            pname:maxDrawIndirectCount is the maximum draw count that is supported for indirect draw calls. See &lt;&lt;features-features-multiDrawIndirect,multiDrawIndirect&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxSamplerLodBias">
            <summary>
            <para>
            pname:maxSamplerLodBias is the maximum absolute sampler level of detail bias. The sum of the pname:mipLodBias member of the sname:VkSamplerCreateInfo structure and the code:Bias operand of image sampling operations in shader modules (or 0 if no code:Bias operand is provided to an image sampling operation) are clamped to the range latexmath:[$[-\mathit{maxSamplerLodBias},+\mathit{maxSamplerLodBias}\]$]. See &lt;&lt;samplers-mipLodBias&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxSamplerAnisotropy">
            <summary>
            <para>
            pname:maxSamplerAnisotropy is the maximum degree of sampler anisotropy. The maximum degree of anisotropic filtering used for an image sampling operation is the minimum of the pname:maxAnisotropy member of the sname:VkSamplerCreateInfo structure and this limit. See &lt;&lt;samplers-maxAnisotropy&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxViewports">
            <summary>
            <para>
            pname:maxViewports is the maximum number of active viewports. The pname:viewportCount member of the sname:VkPipelineViewportStateCreateInfo structure that is provided at pipeline creation must: be less than or equal to this limit.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxViewportDimensions">
            <summary>
            <para>
            pname:maxViewportDimensions[2] are the maximum viewport dimensions in the X (width) and Y (height) dimensions, respectively. The maximum viewport dimensions must: be greater than or equal to the largest image which can: be created and used as a framebuffer attachment. See &lt;&lt;vertexpostproc-viewport,Controlling the Viewport&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.ViewportBoundsRange">
            <summary>
            <para>
            pname:viewportBoundsRange[2] is the latexmath:[$[\mathit{minimum},\mathit{maximum}\]$] range that the corners of a viewport must: be contained in. This range must: be at least + -- latexmath:[$[-2 \times \mathit{size}, 2 \times \mathit{size} - 1\]$], where latexmath:[$\mathit{size} = \max(\mathit{maxViewportDimensions}[0\], \mathit{maxViewportDimensions}[1\]) $]. See &lt;&lt;vertexpostproc-viewport,Controlling the Viewport&gt;&gt;.  [NOTE] .Note ==== The intent of the pname:viewportBoundsRange limit is to allow a maximum sized viewport to be arbitrarily shifted relative to the output target as long as at least some portion intersects. This would give a bounds limit of latexmath:[$[-\mathit{size}+1, 2 \times \mathit{size} - 1\]$] which would allow all possible non-empty-set intersections of the output target and the viewport. Since these numbers are typically powers of two, picking the signed number range using the smallest possible number of bits ends up with the specified range. ==== --
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.ViewportSubPixelBits">
            <summary>
            <para>
            pname:viewportSubPixelBits is the number of bits of subpixel precision for viewport bounds. The subpixel precision that floating-point viewport bounds are interpreted at is given by this limit.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MinMemoryMapAlignment">
            <summary>
            <para>
            pname:minMemoryMapAlignment is the minimum required: alignment, in bytes, of host visible memory allocations within the host address space. When mapping a memory allocation with flink:vkMapMemory, subtracting pname:offset bytes from the returned pointer will always produce an integer multiple of this limit. See &lt;&lt;memory-device-hostaccess&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MinTexelBufferOffsetAlignment">
            <summary>
            <para>
             pname:minTexelBufferOffsetAlignment is the minimum required: alignment, in bytes, for the pname:offset member of the sname:VkBufferViewCreateInfo structure for texel buffers. When a buffer view is created for a buffer which was created with ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT set in the pname:usage member of the sname:VkBufferCreateInfo structure, the pname:offset must: be an integer multiple of this limit.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MinUniformBufferOffsetAlignment">
            <summary>
            <para>
             pname:minUniformBufferOffsetAlignment is the minimum required: alignment, in bytes, for the pname:offset member of the sname:VkDescriptorBufferInfo structure for uniform buffers. When a descriptor of type ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC is updated, the pname:offset must: be an integer multiple of this limit. Similarly, dynamic offsets for uniform buffers must: be multiples of this limit.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MinStorageBufferOffsetAlignment">
            <summary>
            <para>
             pname:minStorageBufferOffsetAlignment is the minimum required: alignment, in bytes, for the pname:offset member of the sname:VkDescriptorBufferInfo structure for storage buffers. When a descriptor of type ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC is updated, the pname:offset must: be an integer multiple of this limit. Similarly, dynamic offsets for storage buffers must: be multiples of this limit.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MinTexelOffset">
            <summary>
            <para>
            pname:minTexelOffset is the minimum offset value for the code:ConstOffset image operand of any of the code:OpImageSample* or code:OpImageFetch* image instructions.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxTexelOffset">
            <summary>
            <para>
            pname:maxTexelOffset is the maximum offset value for the code:ConstOffset image operand of any of the code:OpImageSample* or code:OpImageFetch* image instructions.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MinTexelGatherOffset">
            <summary>
            <para>
            pname:minTexelGatherOffset is the minimum offset value for the code:Offset or code:ConstOffsets image operands of any of the code:OpImage*code:Gather image instructions.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxTexelGatherOffset">
            <summary>
            <para>
            pname:maxTexelGatherOffset is the maximum offset value for the code:Offset or code:ConstOffsets image operands of any of the code:OpImage*code:Gather image instructions.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MinInterpolationOffset">
            <summary>
            <para>
            pname:minInterpolationOffset is the minimum negative offset value for the code:offset operand of the code:InterpolateAtOffset extended instruction.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxInterpolationOffset">
            <summary>
            <para>
            pname:maxInterpolationOffset is the maximum positive offset value for the code:offset operand of the code:InterpolateAtOffset extended instruction.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.SubPixelInterpolationOffsetBits">
            <summary>
            <para>
             pname:subPixelInterpolationOffsetBits is the number of subpixel fractional bits that the code:x and code:y offsets to the code:InterpolateAtOffset extended instruction may: be rounded to as fixed-point values.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxFramebufferWidth">
            <summary>
            <para>
            pname:maxFramebufferWidth is the maximum width for a framebuffer. The pname:width member of the sname:VkFramebufferCreateInfo structure must: be less than or equal to this limit.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxFramebufferHeight">
            <summary>
            <para>
            pname:maxFramebufferHeight is the maximum height for a framebuffer. The pname:height member of the sname:VkFramebufferCreateInfo structure must: be less than or equal to this limit.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxFramebufferLayers">
            <summary>
            <para>
            pname:maxFramebufferLayers is the maximum layer count for a layered framebuffer. The pname:layers member of the sname:VkFramebufferCreateInfo structure must: be less than or equal to this limit.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.FramebufferColorSampleCounts">
            <summary>
            <para>
             pname:framebufferColorSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the color sample counts that are supported for all framebuffer color attachments.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.FramebufferDepthSampleCounts">
            <summary>
            <para>
             pname:framebufferDepthSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the supported depth sample counts for all framebuffer depth/stencil attachments, when the format includes a depth component.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.FramebufferStencilSampleCounts">
            <summary>
            <para>
            pname:framebufferStencilSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the supported stencil sample counts for all framebuffer depth/stencil attachments, when the format includes a stencil component.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.FramebufferNoAttachmentsSampleCounts">
            <summary>
            <para>
            pname:framebufferNoAttachmentsSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the supported sample counts for a framebuffer with no attachments.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxColorAttachments">
            <summary>
            <para>
            pname:maxColorAttachments is the maximum number of color attachments that can: be used by a subpass in a render pass. The pname:colorAttachmentCount member of the sname:VkSubpassDescription structure must: be less than or equal to this limit.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.SampledImageColorSampleCounts">
            <summary>
            <para>
             pname:sampledImageColorSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the sample counts supported for all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, pname:usage containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, and a non-integer color format.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.SampledImageIntegerSampleCounts">
            <summary>
            <para>
             pname:sampledImageIntegerSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the sample counts supported for all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, pname:usage containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, and an integer color format.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.SampledImageDepthSampleCounts">
            <summary>
            <para>
             pname:sampledImageDepthSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the sample counts supported for all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, pname:usage containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, and a depth format.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.SampledImageStencilSampleCounts">
            <summary>
            <para>
             pname:sampledImageStencilSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the sample supported for all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, pname:usage containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, and a stencil format.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.StorageImageSampleCounts">
            <summary>
            <para>
             pname:storageImageSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the sample counts supported for all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, and pname:usage containing ename:VK_IMAGE_USAGE_STORAGE_BIT.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxSampleMaskWords">
            <summary>
            <para>
            pname:maxSampleMaskWords is the maximum number of array elements of a variable decorated with the code:SampleMask built-in decoration.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.TimestampComputeAndGraphics">
            <summary>
            <para>
             pname:timestampComputeAndGraphics indicates support for timestamps on all graphics and compute queues. If this limit is set to ename:VK_TRUE, all queues that advertise the ename:VK_QUEUE_GRAPHICS_BIT or ename:VK_QUEUE_COMPUTE_BIT in the sname:VkQueueFamilyProperties::pname:queueFlags support sname:VkQueueFamilyProperties::pname:timestampValidBits of at least 36. See &lt;&lt;queries-timestamps, Timestamp Queries&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.TimestampPeriod">
            <summary>
            <para>
            pname:timestampPeriod is the number of nanoseconds required: for a timestamp query to be incremented by 1. See &lt;&lt;queries-timestamps, Timestamp Queries&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxClipDistances">
            <summary>
            <para>
            pname:maxClipDistances is the maximum number of clip distances that can: be used in a single shader stage. The size of any array declared with the code:ClipDistance built-in decoration in a shader module must: be less than or equal to this limit.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxCullDistances">
            <summary>
            <para>
            pname:maxCullDistances is the maximum number of cull distances that can: be used in a single shader stage. The size of any array declared with the code:CullDistance built-in decoration in a shader module must: be less than or equal to this limit.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxCombinedClipAndCullDistances">
            <summary>
            <para>
             pname:maxCombinedClipAndCullDistances is the maximum combined number of clip and cull distances that can: be used in a single shader stage. The sum of the sizes of any pair of arrays declared with the code:ClipDistance and code:CullDistance built-in decoration used by a single shader stage in a shader module must: be less than or equal to this limit.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.DiscreteQueuePriorities">
            <summary>
            <para>
             pname:discreteQueuePriorities is the number of discrete priorities that can: be assigned to a queue based on the value of each member of sname:VkDeviceQueueCreateInfo::pname:pQueuePriorities. This must: be at least 2, and levels must: be spread evenly over the range, with at least one level at 1.0, and another at 0.0. See &lt;&lt;devsandqueues-priority&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.PointSizeRange">
            <summary>
            <para>
            pname:pointSizeRange[2] is the range latexmath:[$[\mathit{minimum},\mathit{maximum}\]$] of supported sizes for points. Values written to variables decorated with the code:PointSize built-in decoration are clamped to this range.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.LineWidthRange">
            <summary>
            <para>
            pname:lineWidthRange[2] is the range latexmath:[$[\mathit{minimum},\mathit{maximum}\]$] of supported widths for lines. Values specified by the pname:lineWidth member of the sname:VkPipelineRasterizationStateCreateInfo or the pname:lineWidth parameter to fname:vkCmdSetLineWidth are clamped to this range.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.PointSizeGranularity">
            <summary>
            <para>
            pname:pointSizeGranularity is the granularity of supported point sizes. Not all point sizes in the range defined by pname:pointSizeRange are supported. This limit specifies the granularity (or increment) between successive supported point sizes.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.LineWidthGranularity">
            <summary>
            <para>
            pname:lineWidthGranularity is the granularity of supported line widths. Not all line widths in the range defined by pname:lineWidthRange are supported. This limit specifies the granularity (or increment) between successive supported line widths.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.StrictLines">
            <summary>
            <para>
            pname:strictLines indicates whether lines are rasterized according to the preferred method of rasterization. If set to ename:VK_FALSE, lines may: be rasterized under a relaxed set of rules. If set to ename:VK_TRUE, lines are rasterized as per the strict definition. See &lt;&lt;primsrast-lines-basic,Basic Line Segment Rasterization&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.StandardSampleLocations">
            <summary>
            <para>
             pname:standardSampleLocations indicates whether rasterization uses the standard sample locations as documented in &lt;&lt;primsrast-multisampling,Multisampling&gt;&gt;. If set to ename:VK_TRUE, the implementation uses the documented sample locations. If set to ename:VK_FALSE, the implementation may: use different sample locations.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.OptimalBufferCopyOffsetAlignment">
            <summary>
            <para>
             pname:optimalBufferCopyOffsetAlignment is the optimal buffer offset alignment in bytes for fname:vkCmdCopyBufferToImage and fname:vkCmdCopyImageToBuffer. The per texel alignment requirements are still enforced, this is just an additional alignment recommendation for optimal performance and power.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.OptimalBufferCopyRowPitchAlignment">
            <summary>
            <para>
             pname:optimalBufferCopyRowPitchAlignment is the optimal buffer row pitch alignment in bytes for fname:vkCmdCopyBufferToImage and fname:vkCmdCopyImageToBuffer. Row pitch is the number of bytes between texels with the same X coordinate in adjacent rows (Y coordinates differ by one). The per texel alignment requirements are still enforced, this is just an additional alignment recommendation for optimal performance and power.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.NonCoherentAtomSize">
            <summary>
            <para>
            pname:nonCoherentAtomSize is the size and alignment in bytes that bounds concurrent access to &lt;&lt;memory-device-hostaccess, host-mapped device memory&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PhysicalDeviceMemoryProperties">
            <summary>
            <para>
            Structure specifying physical device memory properties.
            </para>
            <para>
            The sname:VkPhysicalDeviceMemoryProperties structure describes a number of _memory heaps_ as well as a number of _memory types_ that can: be used to access memory allocated in those heaps. Each heap describes a memory resource of a particular size, and each memory type describes a set of memory properties (e.g. host cached vs uncached) that can: be used with a given memory heap. Allocations using a particular memory type will consume resources from the heap indicated by that memory type's heap index. More than one memory type may: share each heap, and the heaps and memory types provide a mechanism to advertise an accurate size of the physical memory resources while allowing the memory to be used with a variety of different properties.
            </para>
            <para>
            The number of memory heaps is given by pname:memoryHeapCount and is less than or equal to ename:VK_MAX_MEMORY_HEAPS. Each heap is described by an element of the pname:memoryHeaps array, as a sname:VkMemoryHeap structure. The number of memory types available across all memory heaps is given by pname:memoryTypeCount and is less than or equal to ename:VK_MAX_MEMORY_TYPES. Each memory type is described by an element of the pname:memoryTypes array, as a sname:VkMemoryType structure.
            </para>
            <para>
            At least one heap must: include ename:VK_MEMORY_HEAP_DEVICE_LOCAL_BIT in slink:VkMemoryHeap::pname:flags. If there are multiple heaps that all have similar performance characteristics, they may: all include ename:VK_MEMORY_HEAP_DEVICE_LOCAL_BIT. In a unified memory architecture (UMA) system, there is often only a single memory heap which is considered to be equally ``local'' to the host and to the device, and such an implementation must: advertise the heap as device-local.
            </para>
            <para>
            Each memory type returned by flink:vkGetPhysicalDeviceMemoryProperties must: have its pname:propertyFlags set to one of the following values:
            </para>
            <para>
            * 0 * ename:VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | ename:VK_MEMORY_PROPERTY_HOST_COHERENT_BIT * ename:VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | ename:VK_MEMORY_PROPERTY_HOST_CACHED_BIT * ename:VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | ename:VK_MEMORY_PROPERTY_HOST_CACHED_BIT | ename:VK_MEMORY_PROPERTY_HOST_COHERENT_BIT * ename:VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT * ename:VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | ename:VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | ename:VK_MEMORY_PROPERTY_HOST_COHERENT_BIT * ename:VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | ename:VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | ename:VK_MEMORY_PROPERTY_HOST_CACHED_BIT * ename:VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | ename:VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | ename:VK_MEMORY_PROPERTY_HOST_CACHED_BIT | ename:VK_MEMORY_PROPERTY_HOST_COHERENT_BIT * ename:VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | ename:VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT
            </para>
            <para>
            There must: be at least one memory type with both the ename:VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT and ename:VK_MEMORY_PROPERTY_HOST_COHERENT_BIT bits set in its pname:propertyFlags. There must: be at least one memory type with the ename:VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT bit set in its pname:propertyFlags.
            </para>
            <para>
            The memory types are sorted according to a preorder which serves to aid in easily selecting an appropriate memory type. Given two memory types X and Y, the preorder defines latexmath:[$X \leq Y$] if:
            </para>
            <para>
            * the memory property bits set for X are a strict subset of the memory property bits set for Y. Or, * the memory property bits set for X are the same as the memory property bits set for Y, and X uses a memory heap with greater or equal performance (as determined in an implementation-specific manner).
            </para>
            <para>
            Memory types are ordered in the list such that X is assigned a lesser pname:memoryTypeIndex than Y if latexmath:[$X \leq Y \land \neg(Y \leq X)$] according to the preorder. Note that the list of all allowed memory property flag combinations above satisfies this preorder, but other orders would as well. The goal of this ordering is to enable applications to use a simple search loop in selecting the proper memory type, along the lines of:
            </para>
            <para>
            [source,{basebackend@docbook:c++:cpp}] --------------------------------------------------- // Find a memory type in "memoryTypeBits" that includes all of "properties" int32_t FindProperties(uint32_t memoryTypeBits, VkMemoryPropertyFlags properties) { for (int32_t i = 0; i &lt; memoryTypeCount; ++i) { if ((memoryTypeBits &amp; (1 &lt;&lt; i)) &amp;&amp; ((memoryTypes[i].propertyFlags &amp; properties) == properties)) return i; } return -1; }
            </para>
            <para>
            // Try to find an optimal memory type, or if it does not exist // find any compatible memory type VkMemoryRequirements memoryRequirements; vkGetImageMemoryRequirements(device, image, &amp;memoryRequirements); int32_t memoryType = FindProperties(memoryRequirements.memoryTypeBits, optimalProperties); if (memoryType == -1) memoryType = FindProperties(memoryRequirements.memoryTypeBits, requiredProperties); ---------------------------------------------------
            </para>
            <para>
            The loop will find the first supported memory type that has all bits requested in code:properties set. If there is no exact match, it will find a closest match (i.e. a memory type with the fewest additional bits set), which has some additional bits set but which are not detrimental to the behaviors requested by code:properties. The application can: first search for the optimal properties, e.g. a memory type that is device-local or supports coherent cached accesses, as appropriate for the intended usage, and if such a memory type is not present can: fallback to searching for a less optimal but guaranteed set of properties such as "0" or "host-visible and coherent".
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceMemoryProperties.MemoryTypes">
            <summary>
            <para>
            pname:memoryTypes is an array of slink:VkMemoryType structures describing the _memory types_ that can: be used to access memory allocated from the heaps specified by pname:memoryHeaps.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceMemoryProperties.MemoryHeaps">
            <summary>
            <para>
            pname:memoryHeaps is an array of slink:VkMemoryHeap structures describing the _memory heaps_ from which memory can: be allocated.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PhysicalDeviceProperties">
            <summary>
            <para>
            Structure specifying physical device properties.
            </para>
            <para>
            The pname:vendorID and pname:deviceID fields are provided to allow applications to adapt to device characteristics that are not adequately exposed by other Vulkan queries. These may: include performance profiles, hardware errata, or other characteristics. In PCI-based implementations, the low sixteen bits of pname:vendorID and pname:deviceID must: contain (respectively) the PCI vendor and device IDs associated with the hardware device, and the remaining bits must: be set to zero. In non-PCI implementations, the choice of what values to return may: be dictated by operating system or platform policies. It is otherwise at the discretion of the implementer, subject to the following constraints and guidelines:
            </para>
            <para>
            * For purposes of physical device identification, the _vendor_ of a physical device is the entity responsible for the most salient characteristics of the hardware represented by the physical device handle. In the case of a discrete GPU, this should: be the GPU chipset vendor. In the case of a GPU or other accelerator integrated into a system-on-chip (SoC), this should: be the supplier of the silicon IP used to create the GPU or other accelerator. * If the vendor of the physical device has a valid PCI vendor ID issued by https://pcisig.com/[PCI-SIG], that ID should: be used to construct pname:vendorID as described above for PCI-based implementations. Implementations that do not return a PCI vendor ID in pname:vendorID must: return a valid Khronos vendor ID, obtained as described in the &lt;&lt;vulkan-styleguide,Vulkan Documentation and Extensions&gt;&gt; document in the section ``Registering a Vendor ID with Khronos''. Khronos vendor IDs are allocated starting at 0x10000, to distinguish them from the PCI vendor ID namespace. * The vendor of the physical device is responsible for selecting pname:deviceID. The value selected should: uniquely identify both the device version and any major configuration options (for example, core count in the case of multicore devices). The same device ID should: be used for all physical implementations of that device version and configuration. For example, all uses of a specific silicon IP GPU version and configuration should: use the same device ID, even if those uses occur in different SoCs.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceProperties.ApiVersion">
            <summary>
            <para>
            pname:apiVersion is the version of Vulkan supported by the device, encoded as described in the &lt;&lt;fundamentals-versionnum,API Version Numbers and Semantics&gt;&gt; section.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceProperties.DriverVersion">
            <summary>
            <para>
            pname:driverVersion is the vendor-specified version of the driver.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceProperties.VendorID">
            <summary>
            <para>
            pname:vendorID is a unique identifier for the _vendor_ (see below) of the physical device.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceProperties.DeviceID">
            <summary>
            <para>
            pname:deviceID is a unique identifier for the physical device among devices available from the vendor.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceProperties.DeviceType">
            <summary>
            <para>
            pname:deviceType is a elink:VkPhysicalDeviceType specifying the type of device.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceProperties.DeviceName">
            <summary>
            <para>
            pname:deviceName is a null-terminated UTF-8 string containing the name of the device.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceProperties.PipelineCacheUUID">
            <summary>
            <para>
            pname:pipelineCacheUUID is an array of size ename:VK_UUID_SIZE, containing 8-bit values that represent a universally unique identifier for the device.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceProperties.Limits">
            <summary>
            <para>
            pname:limits is the slink:VkPhysicalDeviceLimits structure which specifies device-specific limits of the physical device. See &lt;&lt;features-limits,Limits&gt;&gt; for details.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceProperties.SparseProperties">
            <summary>
            <para>
            pname:sparseProperties is the slink:VkPhysicalDeviceSparseProperties structure which specifies various sparse related properties of the physical device. See &lt;&lt;sparsememory-physicalprops,Sparse Properties&gt;&gt; for details.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PipelineCacheCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created pipeline cache.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineCacheCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineCacheCreateInfo.InitialData">
            <summary>
            <para>
            pname:pInitialData is a pointer to previously retrieved pipeline cache data. If the pipeline cache data is incompatible (as defined below) with the device, the pipeline cache will be initially empty. If pname:initialDataSize is zero, pname:pInitialData is ignored.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PipelineColorBlendStateCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created pipeline color blend state.
            </para>
            <para>
            Each element of the pname:pAttachments array is a slink:VkPipelineColorBlendAttachmentState structure specifying per-target blending state for each individual color attachment. If the &lt;&lt;features-features-independentBlend,independent blending&gt;&gt; feature is not enabled on the device, all slink:VkPipelineColorBlendAttachmentState elements in the pname:pAttachments array must: be identical.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineColorBlendStateCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineColorBlendStateCreateInfo.LogicOpEnable">
            <summary>
            <para>
            pname:logicOpEnable controls whether to apply &lt;&lt;framebuffer-logicop, Logical Operations&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineColorBlendStateCreateInfo.LogicOp">
            <summary>
            <para>
            pname:logicOp selects which logical operation to apply.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineColorBlendStateCreateInfo.Attachments">
            <summary>
            <para>
            pname:pAttachments: is a pointer to array of per target attachment states.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineColorBlendStateCreateInfo.BlendConstants">
            <summary>
            <para>
            pname:blendConstants is an array of four values used as the R, G, B, and A components of the blend constant that are used in blending, depending on the &lt;&lt;framebuffer-blendfactors,blend factor&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PipelineDepthStencilStateCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created pipeline depth stencil state.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineDepthStencilStateCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineDepthStencilStateCreateInfo.DepthTestEnable">
            <summary>
            <para>
            pname:depthTestEnable controls whether &lt;&lt;fragops-depth,depth testing&gt;&gt; is enabled.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineDepthStencilStateCreateInfo.DepthWriteEnable">
            <summary>
            <para>
            pname:depthWriteEnable controls whether &lt;&lt;fragops-depth-write,depth writes&gt;&gt; are enabled.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineDepthStencilStateCreateInfo.DepthCompareOp">
            <summary>
            <para>
            pname:depthCompareOp is the comparison operator used in the &lt;&lt;fragops-depth,depth test&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineDepthStencilStateCreateInfo.DepthBoundsTestEnable">
            <summary>
            <para>
            pname:depthBoundsTestEnable controls whether &lt;&lt;fragops-dbt,depth bounds testing&gt;&gt; is enabled.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineDepthStencilStateCreateInfo.StencilTestEnable">
            <summary>
            <para>
            pname:stencilTestEnable controls whether &lt;&lt;fragops-stencil,stencil testing&gt;&gt; is enabled.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineDepthStencilStateCreateInfo.Front">
            <summary>
            <para>
            pname:front and pname:back control the parameters of the &lt;&lt;fragops-stencil,stencil test&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineDepthStencilStateCreateInfo.Back">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineDepthStencilStateCreateInfo.MinDepthBounds">
            <summary>
            <para>
            pname:minDepthBounds and pname:maxDepthBounds define the range of values used in the &lt;&lt;fragops-dbt,depth bounds test&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineDepthStencilStateCreateInfo.MaxDepthBounds">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PipelineDynamicStateCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created pipeline dynamic state.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineDynamicStateCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineDynamicStateCreateInfo.DynamicStates">
            <summary>
            <para>
            pname:pDynamicStates is an array of elink:VkDynamicState enums which indicate which pieces of pipeline state will use the values from dynamic state commands rather than from the pipeline state creation info.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PipelineInputAssemblyStateCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created pipeline input assembly state.
            </para>
            <para>
            Restarting the assembly of primitives discards the most recent index values if those elements formed an incomplete primitive, and restarts the primitive assembly using the subsequent indices, but only assembling the immediately following element through the end of the originally specified elements. The primitive restart index value comparison is performed before adding the pname:vertexOffset value to the index value.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineInputAssemblyStateCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineInputAssemblyStateCreateInfo.Topology">
            <summary>
            <para>
            pname:topology is a elink:VkPrimitiveTopology defining the primitive topology, as described below.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineInputAssemblyStateCreateInfo.PrimitiveRestartEnable">
            <summary>
            <para>
            pname:primitiveRestartEnable controls whether a special vertex index value is treated as restarting the assembly of primitives. This enable only applies to indexed draws (flink:vkCmdDrawIndexed and flink:vkCmdDrawIndexedIndirect), and the special index value is either 0xFFFFFFFF when the pname:indexType parameter of fname:vkCmdBindIndexBuffer is equal to ename:VK_INDEX_TYPE_UINT32, or 0xFFFF when pname:indexType is equal to ename:VK_INDEX_TYPE_UINT16. Primitive restart is not allowed for ``list'' topologies.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PipelineLayoutCreateInfo">
            <summary>
            <para>
            Structure specifying the parameters of a newly created pipeline layout object.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineLayoutCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineLayoutCreateInfo.SetLayouts">
            <summary>
            <para>
            pname:pSetLayouts is a pointer to an array of sname:VkDescriptorSetLayout objects.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineLayoutCreateInfo.PushConstantRanges">
            <summary>
            <para>
            pname:pPushConstantRanges is a pointer to an array of sname:VkPushConstantRange structures defining a set of push constant ranges for use in a single pipeline layout. In addition to descriptor set layouts, a pipeline layout also describes how many push constants can: be accessed by each stage of the pipeline. + [NOTE] .Note ==== Push constants represent a high speed path to modify constant data in pipelines that is expected to outperform memory-backed resource updates. ====
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PipelineMultisampleStateCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created pipeline multisample state.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineMultisampleStateCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineMultisampleStateCreateInfo.RasterizationSamples">
            <summary>
            <para>
            pname:rasterizationSamples is a elink:VkSampleCountFlagBits specifying the number of samples per pixel used in rasterization.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineMultisampleStateCreateInfo.SampleShadingEnable">
            <summary>
            <para>
            pname:sampleShadingEnable specifies that fragment shading executes per-sample if ename:VK_TRUE, or per-fragment if ename:VK_FALSE, as described in &lt;&lt;primsrast-sampleshading,Sample Shading&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineMultisampleStateCreateInfo.MinSampleShading">
            <summary>
            <para>
            pname:minSampleShading is the minimum fraction of sample shading, as described in &lt;&lt;primsrast-sampleshading,Sample Shading&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineMultisampleStateCreateInfo.SampleMask">
            <summary>
            <para>
            pname:pSampleMask is a bitmask of static coverage information that is ANDed with the coverage information generated during rasterization, as described in &lt;&lt;fragops-samplemask,Sample Mask&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineMultisampleStateCreateInfo.AlphaToCoverageEnable">
            <summary>
            <para>
            pname:alphaToCoverageEnable controls whether a temporary coverage value is generated based on the alpha component of the fragment's first color output as specified in the &lt;&lt;fragops-covg,Multisample Coverage&gt;&gt; section.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineMultisampleStateCreateInfo.AlphaToOneEnable">
            <summary>
            <para>
            pname:alphaToOneEnable controls whether the alpha component of the fragment's first color output is replaced with one as described in &lt;&lt;fragops-covg,Multisample Coverage&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PipelineRasterizationStateCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created pipeline rasterization state.
            </para>
            <para>
            ifdef::VK_AMD_rasterization_order[] The application can: also chain a sname:VkPipelineRasterizationStateRasterizationOrderAMD structure to the sname:VkPipelineRasterizationStateCreateInfo structure through its pname:pNext member. This structure enables selecting the rasterization order to use when rendering with the corresponding graphics pipeline as described in &lt;&lt;primrast-order, Rasterization Order&gt;&gt;. endif::VK_AMD_rasterization_order[]
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineRasterizationStateCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineRasterizationStateCreateInfo.DepthClampEnable">
            <summary>
            <para>
            pname:depthClampEnable controls whether to clamp the fragment's depth values instead of clipping primitives to the z planes of the frustum, as described in &lt;&lt;vertexpostproc-clipping,Primitive Clipping&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineRasterizationStateCreateInfo.RasterizerDiscardEnable">
            <summary>
            <para>
            pname:rasterizerDiscardEnable controls whether primitives are discarded immediately before the rasterization stage.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineRasterizationStateCreateInfo.PolygonMode">
            <summary>
            <para>
            pname:polygonMode is the triangle rendering mode. See elink:VkPolygonMode.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineRasterizationStateCreateInfo.CullMode">
            <summary>
            <para>
            pname:cullMode is the triangle facing direction used for primitive culling. See elink:VkCullModeFlagBits.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineRasterizationStateCreateInfo.FrontFace">
            <summary>
            <para>
            pname:frontFace is the front-facing triangle orientation to be used for culling. See elink:VkFrontFace.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineRasterizationStateCreateInfo.DepthBiasEnable">
            <summary>
            <para>
            pname:depthBiasEnable controls whether to bias fragment depth values.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineRasterizationStateCreateInfo.DepthBiasConstantFactor">
            <summary>
            <para>
            pname:depthBiasConstantFactor is a scalar factor controlling the constant depth value added to each fragment.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineRasterizationStateCreateInfo.DepthBiasClamp">
            <summary>
            <para>
            pname:depthBiasClamp is the maximum (or minimum) depth bias of a fragment.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineRasterizationStateCreateInfo.DepthBiasSlopeFactor">
            <summary>
            <para>
            pname:depthBiasSlopeFactor is a scalar factor applied to a fragment's slope in depth bias calculations.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineRasterizationStateCreateInfo.LineWidth">
            <summary>
            <para>
            pname:lineWidth is the width of rasterized line segments.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PipelineRasterizationStateRasterizationOrder">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineRasterizationStateRasterizationOrder.RasterizationOrder">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PipelineShaderStageCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created pipeline shader stage.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineShaderStageCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineShaderStageCreateInfo.Stage">
            <summary>
            <para>
            pname:stage names a single pipeline stage. Bits which can: be set include: + --
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineShaderStageCreateInfo.Module">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineShaderStageCreateInfo.Name">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineShaderStageCreateInfo.SpecializationInfo">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PipelineTessellationStateCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created pipeline tessellation state.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineTessellationStateCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineTessellationStateCreateInfo.PatchControlPoints">
            <summary>
            <para>
            pname:patchControlPoints number of control points per patch.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PipelineVertexInputStateCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created pipeline vertex input state.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineVertexInputStateCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineVertexInputStateCreateInfo.VertexBindingDescriptions">
            <summary>
            <para>
            pname:pVertexBindingDescriptions is a pointer to an array of sname:VkVertexInputBindingDescription structures.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineVertexInputStateCreateInfo.VertexAttributeDescriptions">
            <summary>
            <para>
            pname:pVertexAttributeDescriptions is a pointer to an array of sname:VkVertexInputAttributeDescription structures.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PipelineViewportStateCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created pipeline viewport state.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineViewportStateCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineViewportStateCreateInfo.Viewports">
            <summary>
            <para>
            pname:pViewports is a pointer to an array of slink:VkViewport structures, defining the viewport transforms. If the viewport state is dynamic, this member is ignored.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineViewportStateCreateInfo.Scissors">
            <summary>
            <para>
            pname:pScissors is a pointer to an array of sname:VkRect2D structures which define the rectangular bounds of the scissor for the corresponding viewport. If the scissor state is dynamic, this member is ignored.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.PresentInfo">
            <summary>
            <para>
            Structure describing parameters of a queue presentation.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PresentInfo.WaitSemaphores">
            <summary>
            <para>
            pname:pWaitSemaphores, if not code:VK_NULL_HANDLE, is an array of sname:VkSemaphore objects with pname:waitSemaphoreCount entries, and specifies the semaphores to wait for before issuing the present request.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PresentInfo.Swapchains">
            <summary>
            <para>
            pname:pSwapchains is an array of sname:VkSwapchainKHR objects with pname:swapchainCount entries. A given swapchain must: not appear in this list more than once.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PresentInfo.ImageIndices">
            <summary>
            <para>
            pname:pImageIndices is an array of indices into the array of each swapchain's presentable images, with pname:swapchainCount entries. Each entry in this array identifies the image to present on the corresponding entry in the pname:pSwapchains array.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PresentInfo.Results">
            <summary>
            <para>
            pname:pResults is an array of ename:VkResult typed elements with pname:swapchainCount entries. Applications that do not need per-swapchain results can: use `NULL` for pname:pResults. If non-`NULL`, each entry in pname:pResults will be set to the ename:VkResult for presenting the swapchain corresponding to the same index in pname:pSwapchains.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.QueryPoolCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created query pool.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.QueryPoolCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.QueryPoolCreateInfo.QueryType">
            <summary>
            <para>
            pname:queryType is the type of queries managed by the pool, and must: be one of the values + --
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.QueryPoolCreateInfo.QueryCount">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.QueryPoolCreateInfo.PipelineStatistics">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.RenderPassBeginInfo">
            <summary>
            <para>
            Structure specifying render pass begin info.
            </para>
            <para>
            pname:renderArea is the render area that is affected by the render pass instance. The effects of attachment load, store and resolve operations are restricted to the pixels whose x and y coordinates fall within the render area on all attachments. The render area extends to all layers of pname:framebuffer. The application must: ensure (using scissor if necessary) that all rendering is contained within the render area, otherwise the pixels outside of the render area become undefined and shader side effects may: occur for fragments outside the render area. The render area must: be contained within the framebuffer dimensions.
            </para>
            <para>
            [NOTE] .Note ==== There may: be a performance cost for using a render area smaller than the framebuffer, unless it matches the render area granularity for the render pass. ====
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.RenderPassBeginInfo.RenderPass">
            <summary>
            <para>
            pname:renderPass is the render pass to begin an instance of.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.RenderPassBeginInfo.Framebuffer">
            <summary>
            <para>
            pname:framebuffer is the framebuffer containing the attachments that are used with the render pass.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.RenderPassBeginInfo.RenderArea">
            <summary>
            <para>
            pname:renderArea is the render area that is affected by the render pass instance, and is described in more detail below.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.RenderPassBeginInfo.ClearValues">
            <summary>
            <para>
            pname:pClearValues is an array of slink:VkClearValue structures that contains clear values for each attachment, if the attachment uses a pname:loadOp value of ename:VK_ATTACHMENT_LOAD_OP_CLEAR or if the attachment has a depth/stencil format and uses a pname:stencilLoadOp value of ename:VK_ATTACHMENT_LOAD_OP_CLEAR. The array is indexed by attachment number. Only elements corresponding to cleared attachments are used. Other elements of pname:pClearValues are ignored.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.RenderPassCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created render pass.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.RenderPassCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.RenderPassCreateInfo.Attachments">
            <summary>
            <para>
            pname:pAttachments points to an array of pname:attachmentCount number of slink:VkAttachmentDescription structures describing properties of the attachments, or `NULL` if pname:attachmentCount is zero.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.RenderPassCreateInfo.Subpasses">
            <summary>
            <para>
            pname:pSubpasses points to an array of pname:subpassCount number of slink:VkSubpassDescription structures describing properties of the subpasses.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.RenderPassCreateInfo.Dependencies">
            <summary>
            <para>
            pname:pDependencies points to an array of pname:dependencyCount number of slink:VkSubpassDependency structures describing dependencies between pairs of subpasses, or `NULL` if pname:dependencyCount is zero.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.SamplerCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created sampler.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.MagFilter">
            <summary>
            <para>
            pname:magFilter is the magnification filter to apply to lookups, and is of type: + --
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.MinFilter">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.MipmapMode">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.AddressModeU">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.AddressModeV">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.AddressModeW">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.MipLodBias">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.AnisotropyEnable">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.MaxAnisotropy">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.CompareEnable">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.CompareOp">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.MinLod">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.MaxLod">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.BorderColor">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.UnnormalizedCoordinates">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.SemaphoreCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created semaphore.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SemaphoreCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.ShaderModuleCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created shader module.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ShaderModuleCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ShaderModuleCreateInfo.CodeSize">
            <summary>
            <para>
            pname:codeSize is the size, in bytes, of the code pointed to by pname:pCode.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ShaderModuleCreateInfo.Code">
            <summary>
            <para>
            pname:pCode points to code that is used to create the shader module. The type and format of the code is determined from the content of the memory addressed by pname:pCode.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.SparseBufferMemoryBindInfo">
            <summary>
            <para>
            Structure specifying a sparse buffer memory bind operation.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SparseBufferMemoryBindInfo.Buffer">
            <summary>
            <para>
            pname:buffer is the sname:VkBuffer object to be bound.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SparseBufferMemoryBindInfo.Binds">
            <summary>
            <para>
            pname:pBinds is a pointer to array of sname:VkSparseMemoryBind structures.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.SparseImageMemoryBind">
            <summary>
            <para>
            Structure specifying sparse image memory bind.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SparseImageMemoryBind.Subresource">
            <summary>
            <para>
            pname:subresource is the aspectMask and region of interest in the image.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SparseImageMemoryBind.Offset">
            <summary>
            <para>
            pname:offset are the coordinates of the first texel within the image subresource to bind.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SparseImageMemoryBind.Extent">
            <summary>
            <para>
            pname:extent is the size in texels of the region within the image subresource to bind. The extent must: be a multiple of the sparse image block dimensions, except when binding sparse image blocks along the edge of an image subresource it can: instead be such that any coordinate of latexmath:[$\mathit{offset} + \mathit{extent}$] equals the corresponding dimensions of the image subresource.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SparseImageMemoryBind.Memory">
            <summary>
            <para>
            pname:memory is the sname:VkDeviceMemory object that the sparse image blocks of the image are bound to. If pname:memory is dlink:VK_NULL_HANDLE, the sparse image blocks are unbound.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SparseImageMemoryBind.MemoryOffset">
            <summary>
            <para>
            pname:memoryOffset is an offset into sname:VkDeviceMemory object. If pname:memory is dlink:VK_NULL_HANDLE, this value is ignored.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SparseImageMemoryBind.Flags">
            <summary>
            <para>
            pname:flags are sparse memory binding flags.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.SparseImageMemoryBindInfo">
            <summary>
            <para>
            Structure specifying sparse image memory bind info.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SparseImageMemoryBindInfo.Image">
            <summary>
            <para>
            pname:image is the sname:VkImage object to be bound
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SparseImageMemoryBindInfo.Binds">
            <summary>
            <para>
            pname:pBinds is a pointer to array of sname:VkSparseImageMemoryBind structures
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.SparseImageOpaqueMemoryBindInfo">
            <summary>
            <para>
            Structure specifying sparse image opaque memory bind info.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SparseImageOpaqueMemoryBindInfo.Image">
            <summary>
            <para>
            pname:image is the sname:VkImage object to be bound.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SparseImageOpaqueMemoryBindInfo.Binds">
            <summary>
            <para>
            pname:pBinds is a pointer to array of sname:VkSparseMemoryBind structures.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.SparseMemoryBind">
            <summary>
            <para>
            Structure specifying a sparse memory bind operation.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SparseMemoryBind.ResourceOffset">
            <summary>
            <para>
            pname:resourceOffset is the offset into the resource.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SparseMemoryBind.Size">
            <summary>
            <para>
            pname:size is the size of the memory region to be bound.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SparseMemoryBind.Memory">
            <summary>
            <para>
            pname:memory is the sname:VkDeviceMemory object that the range of the resource is bound to. If pname:memory is dlink:VK_NULL_HANDLE, the range is unbound.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SparseMemoryBind.MemoryOffset">
            <summary>
            <para>
            pname:memoryOffset is the offset into the sname:VkDeviceMemory object to bind the resource range to. If pname:memory is dlink:VK_NULL_HANDLE, this value is ignored.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SparseMemoryBind.Flags">
            <summary>
            <para>
            pname:flags is a bitmask specifying usage of the binding operation. Bits which can: be set include: + --
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.SpecializationInfo">
            <summary>
            <para>
            Structure specifying specialization info.
            </para>
            <para>
            pname:pMapEntries points to a structure of type slink:VkSpecializationMapEntry.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SpecializationInfo.MapEntries">
            <summary>
            <para>
            pname:pMapEntries is a pointer to an array of sname:VkSpecializationMapEntry which maps constant IDs to offsets in pname:pData.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SpecializationInfo.Data">
            <summary>
            <para>
            pname:pData contains the actual constant values to specialize with.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.SubmitInfo">
            <summary>
            <para>
            Structure specifying a queue submit operation.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SubmitInfo.WaitSemaphores">
            <summary>
            <para>
            pname:pWaitSemaphores is a pointer to an array of semaphores upon which to wait before the command buffers for this batch begin execution. If semaphores to wait on are provided, they define a &lt;&lt;synchronization-semaphores-waiting, semaphore wait operation&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SubmitInfo.WaitDestinationStageMask">
            <summary>
            <para>
            pname:pWaitDstStageMask is a pointer to an array of pipeline stages at which each corresponding semaphore wait will occur.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SubmitInfo.CommandBuffers">
            <summary>
            <para>
            pname:pCommandBuffers is a pointer to an array of command buffers to execute in the batch. The command buffers submitted in a batch begin execution in the order they appear in pname:pCommandBuffers, but may: complete out of order.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SubmitInfo.SignalSemaphores">
            <summary>
            <para>
            pname:pSignalSemaphores is a pointer to an array of semaphores which will be signaled when the command buffers for this batch have completed execution. If semaphores to be signaled are provided, they define a &lt;&lt;synchronization-semaphores-signaling, semaphore signal operation&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.SubpassDescription">
            <summary>
            <para>
            Structure specifying a subpass description.
            </para>
            <para>
            The contents of an attachment within the render area become undefined at the start of a subpass S if all of the following conditions are true:
            </para>
            <para>
            * The attachment is used as a color, depth/stencil, or resolve attachment in any subpass in the render pass. * There is a subpass S1 that uses or preserves the attachment, and a subpass dependency from S1 to S. * The attachment is not used or preserved in subpass S.
            </para>
            <para>
            Once the contents of an attachment become undefined in subpass S, they remain undefined for subpasses in subpass dependency chains starting with subpass S until they are written again. However, they remain valid for subpasses in other subpass dependency chains starting with subpass S1 if those subpasses use or preserve the attachment.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SubpassDescription.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SubpassDescription.PipelineBindPoint">
            <summary>
            <para>
            pname:pipelineBindPoint is a elink:VkPipelineBindPoint value specifying whether this is a compute or graphics subpass. Currently, only graphics subpasses are supported.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SubpassDescription.InputAttachments">
            <summary>
            <para>
            pname:pInputAttachments is an array of slink:VkAttachmentReference structures (defined below) that lists which of the render pass's attachments can: be read in the shader during the subpass, and what layout each attachment will be in during the subpass. Each element of the array corresponds to an input attachment unit number in the shader, i.e. if the shader declares an input variable `layout(input_attachment_index=X, set=Y, binding=Z)` then it uses the attachment provided in pname:pInputAttachments[X]. Input attachments must: also be bound to the pipeline with a descriptor set, with the input attachment descriptor written in the location (set=Y, binding=Z).
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SubpassDescription.ColorAttachments">
            <summary>
            <para>
            pname:pColorAttachments is an array of pname:colorAttachmentCount slink:VkAttachmentReference structures that lists which of the render pass's attachments will be used as color attachments in the subpass, and what layout each attachment will be in during the subpass. Each element of the array corresponds to a fragment shader output location, i.e. if the shader declared an output variable `layout(location=X)` then it uses the attachment provided in pname:pColorAttachments[X].
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SubpassDescription.ResolveAttachments">
            <summary>
            <para>
            pname:pResolveAttachments is `NULL` or an array of pname:colorAttachmentCount slink:VkAttachmentReference structures that lists which of the render pass's attachments are resolved to at the end of the subpass, and what layout each attachment will be in during the resolve. If pname:pResolveAttachments is not `NULL`, each of its elements corresponds to a color attachment (the element in pname:pColorAttachments at the same index). At the end of each subpass, the subpass's color attachments are resolved to corresponding resolve attachments, unless the resolve attachment index is ename:VK_ATTACHMENT_UNUSED or pname:pResolveAttachments is `NULL`. If the first use of an attachment in a render pass is as a resolve attachment, then the pname:loadOp is effectively ignored as the resolve is guaranteed to overwrite all pixels in the render area.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SubpassDescription.DepthStencilAttachment">
            <summary>
            <para>
            pname:pDepthStencilAttachment is a pointer to a slink:VkAttachmentReference specifying which attachment will be used for depth/stencil data and the layout it will be in during the subpass. Setting the attachment index to ename:VK_ATTACHMENT_UNUSED or leaving this pointer as `NULL` indicates that no depth/stencil attachment will be used in the subpass.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SubpassDescription.PreserveAttachments">
            <summary>
            <para>
            pname:pPreserveAttachments is an array of pname:preserveAttachmentCount render pass attachment indices describing the attachments that are not used by a subpass, but whose contents must: be preserved throughout the subpass.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.SwapchainCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created swapchain object.
            </para>
            <para>
            [NOTE] .Note ==== Applications should: set this value to ename:VK_TRUE if they do not expect to read back the content of presentable images before presenting them or after reacquiring them and if their pixel shaders do not have any side effects that require them to run for all pixels in the presentable image. ====
            </para>
            <para>
            * pname:oldSwapchain, if not code:VK_NULL_HANDLE, specifies the swapchain that will be replaced by the new swapchain being created. The new swapchain will be a descendant of pname:oldSwapchain. Further, any descendants of the new swapchain will also be descendants of pname:oldSwapchain. Upon calling fname:vkCreateSwapchainKHR with a pname:oldSwapchain that is not code:VK_NULL_HANDLE, any images not acquired by the application may: be freed by the implementation, which may: occur even if creation of the new swapchain fails. The application must: destroy the old swapchain to free all memory associated with the old swapchain. The application must: wait for the completion of any outstanding rendering to images it currently has acquired at the time the swapchain is destroyed. The application can: continue to present any images it acquired and has not yet presented using the old swapchain, as long as it has not entered a state that causes it to return ename:VK_ERROR_OUT_OF_DATE_KHR. However, the application cannot: acquire any more images from the old swapchain regardless of whether or not creation of the new swapchain succeeds.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use, and must: be zero.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.Surface">
            <summary>
            <para>
            pname:surface is the surface that the swapchain will present images to.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.MinImageCount">
            <summary>
            <para>
            pname:minImageCount is the minimum number of presentable images that the application needs. The platform will either create the swapchain with at least that many images, or will fail to create the swapchain.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.ImageFormat">
            <summary>
            <para>
            pname:imageFormat is a slink:VkFormat that is valid for swapchains on the specified surface.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.ImageColorSpace">
            <summary>
            <para>
            pname:imageColorSpace is a slink:VkColorSpaceKHR that is valid for swapchains on the specified surface.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.ImageExtent">
            <summary>
            <para>
            pname:imageExtent is the size (in pixels) of the swapchain. Behavior is platform-dependent when the image extent does not match the surface's pname:currentExtent as returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.ImageArrayLayers">
            <summary>
            <para>
            pname:imageArrayLayers is the number of views in a multiview/stereo surface. For non-stereoscopic-3D applications, this value is 1.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.ImageUsage">
            <summary>
            <para>
            pname:imageUsage is a bitmask of elink:VkImageUsageFlagBits, indicating how the application will use the swapchain's presentable images.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.ImageSharingMode">
            <summary>
            <para>
            pname:imageSharingMode is the sharing mode used for the images of the swapchain.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.QueueFamilyIndices">
            <summary>
            <para>
            pname:pQueueFamilyIndices is an array of queue family indices having access to the images of the swapchain in case pname:imageSharingMode is ename:VK_SHARING_MODE_CONCURRENT.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.PreTransform">
            <summary>
            <para>
            pname:preTransform is a bitmask of elink:VkSurfaceTransformFlagBitsKHR, describing the transform, relative to the presentation engine's natural orientation, applied to the image content prior to presentation. If it does not match the pname:currentTransform value returned by fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR, the presentation engine will transform the image content as part of the presentation operation.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.CompositeAlpha">
            <summary>
            <para>
            pname:compositeAlpha is a bitmask of elink:VkCompositeAlphaFlagBitsKHR, indicating the alpha compositing mode to use when this surface is composited together with other surfaces on certain window systems.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.PresentMode">
            <summary>
            <para>
            pname:presentMode is the presentation mode the swapchain will use. A swapchain's present mode determines how incoming present requests will be processed and queued internally.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.Clipped">
            <summary>
            <para>
            pname:clipped indicates whether the Vulkan implementation is allowed to discard rendering operations that affect regions of the surface which are not visible.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.OldSwapchain">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.ValidationFlags">
            <summary>
            <para>
            Specify validation checks to disable for a Vulkan instance.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ValidationFlags.DisabledValidationChecks">
            <summary>
            <para>
            pname:pDisabledValidationChecks is a pointer to an array of values specifying the validation checks to be disabled. Checks which may: be specified include: + --
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.WaylandSurfaceCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created Wayland surface object.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.WaylandSurfaceCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.WaylandSurfaceCreateInfo.Display">
            <summary>
            <para>
            pname:display and pname:surface are pointers to the Wayland code:wl_display and code:wl_surface to associate the surface with.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.WaylandSurfaceCreateInfo.Surface">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Win32KeyedMutexAcquireReleaseInfo">
            <summary>
            <para>
            Use Windows keyex mutex mechanism to synchronize work.
            </para>
            <para>
            When submitting work that operates on memory imported from a Direct3D 11 resource to a queue, the keyed mutex mechanism may: be used in addition to Vulkan semaphores to synchronize the work. Keyed mutexes are a property of a properly created shareable Direct3D 11 resource. They can: only be used if the imported resource was created with the etext:D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX flag.
            </para>
            <para>
            To acquire keyed mutexes before submitted work and/or release them after, add a slink:VkWin32KeyedMutexAcquireReleaseInfoNV structure to the pname:pNext chain of the slink:VkSubmitInfo structure.
            </para>
            <para>
            * pname:acquireCount is the number of entries in the pname:pAcquireSyncs, pname:pAcquireKeys, and pname:pAcquireTimeoutMilliseconds arrays. * pname:pAcquireSyncs is a pointer to an array of slink:VkDeviceMemory objects which were imported from Direct3D 11 resources. * pname:pAcquireKeys is a pointer to an array of mutex key values to wait for prior to beginning the submitted work. Entries refer to the keyed mutex associated with the corresponding entries in pname:pAcquireSyncs. * pname:pAcquireTimeoutMilliseconds is an array of timeout values, in millisecond units, for each acquire specified in pname:pAcquireKeys. * pname:releaseCount is the number of entries in the pname:pReleaseSyncs and pname:pReleaseKeys arrays. * pname:pReleaseSyncs is a pointer to an array of slink:VkDeviceMemory objects which were imported from Direct3D 11 resources. * pname:pReleaseKeys is a pointer to an array of mutex key values to set when the submitted work has completed. Entries refer to the keyed mutex associated with the corresponding entries in pname:pReleaseSyncs.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.Win32KeyedMutexAcquireReleaseInfo.AcquireSyncs">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.Win32KeyedMutexAcquireReleaseInfo.AcquireKeys">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.Win32KeyedMutexAcquireReleaseInfo.AcquireTimeoutMilliseconds">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.Win32KeyedMutexAcquireReleaseInfo.ReleaseSyncs">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.Win32KeyedMutexAcquireReleaseInfo.ReleaseKeys">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Win32SurfaceCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created Win32 surface object.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.Win32SurfaceCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.Win32SurfaceCreateInfo.Hinstance">
            <summary>
            <para>
            pname:hinstance and pname:hwnd are the Win32 code:HINSTANCE and code:HWND for the window to associate the surface with.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.Win32SurfaceCreateInfo.Hwnd">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.WriteDescriptorSet">
            <summary>
            <para>
            Structure specifying the parameters of a descriptor set write operation.
            </para>
            <para>
            Only one of pname:pImageInfo, pname:pBufferInfo, or pname:pTexelBufferView members is used according to the descriptor type specified in the pname:descriptorType member of the containing sname:VkWriteDescriptorSet structure, as specified below.
            </para>
            <para>
            [[descriptorsets-updates-consecutive, consecutive binding updates]] If the pname:dstBinding has fewer than pname:descriptorCount array elements remaining starting from pname:dstArrayElement, then the remainder will be used to update the subsequent binding - pname:dstBinding+1 starting at array element zero. This behavior applies recursively, with the update affecting consecutive bindings as needed to update all pname:descriptorCount descriptors. All consecutive bindings updated via a single sname:VkWriteDescriptorSet structure must: have identical pname:descriptorType and pname:stageFlags, and must: all either use immutable samplers or must: all not use immutable samplers.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.WriteDescriptorSet.DestinationSet">
            <summary>
            <para>
            pname:dstSet is the destination descriptor set to update.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.WriteDescriptorSet.DestinationBinding">
            <summary>
            <para>
            pname:dstBinding is the descriptor binding within that set.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.WriteDescriptorSet.DestinationArrayElement">
            <summary>
            <para>
            pname:dstArrayElement is the starting element in that array.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.WriteDescriptorSet.DescriptorType">
            <summary>
            <para>
            pname:descriptorType is a elink:VkDescriptorType specifying the type of each descriptor in pname:pImageInfo, pname:pBufferInfo, or pname:pTexelBufferView, as described below. It must: be the same type as that specified in sname:VkDescriptorSetLayoutBinding for pname:dstSet at pname:dstBinding. The type of the descriptor also controls which array the descriptors are taken from.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.WriteDescriptorSet.ImageInfo">
            <summary>
            <para>
            pname:pImageInfo points to an array of slink:VkDescriptorImageInfo structures or is ignored, as described below.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.WriteDescriptorSet.BufferInfo">
            <summary>
            <para>
            pname:pBufferInfo points to an array of slink:VkDescriptorBufferInfo structures or is ignored, as described below.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.WriteDescriptorSet.TexelBufferView">
            <summary>
            <para>
            pname:pTexelBufferView points to an array of slink:VkBufferView handles as described in the &lt;&lt;resources-buffer-views,Buffer Views&gt;&gt; section or is ignored, as described below.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.XcbSurfaceCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created Xcb surface object.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.XcbSurfaceCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.XcbSurfaceCreateInfo.Connection">
            <summary>
            <para>
            pname:connection is a pointer to an code:xcb_connection_t to the X server.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.XcbSurfaceCreateInfo.Window">
            <summary>
            <para>
            pname:window is the code:xcb_window_t for the X11 window to associate the surface with.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.XlibSurfaceCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created Xlib surface object.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.XlibSurfaceCreateInfo.Flags">
            <summary>
            <para>
            pname:flags is reserved for future use.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.XlibSurfaceCreateInfo.Dpy">
            <summary>
            <para>
            pname:dpy is a pointer to an Xlib code:Display connection to the X server.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.XlibSurfaceCreateInfo.Window">
            <summary>
            <para>
            pname:window is an Xlib code:Window to associate the surface with.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Buffer">
            <summary>
            <para>
            Opaque handle to a buffer object.
            </para>
            <para>
            Buffers represent linear arrays of data which are used for various purposes by binding them to a graphics or compute pipeline via descriptor sets or via certain commands, or by directly specifying them as parameters to certain commands.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Buffer.BindMemory(SharpVk.DeviceMemory,SharpVk.DeviceSize)">
            <summary>
            <para>
            Bind device memory to a buffer object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Buffer.GetMemoryRequirements">
            <summary>
            <para>
            Returns the memory requirements for specified Vulkan object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Buffer.Destroy">
            <summary>
            <para>
            Destroy a buffer object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Buffer.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.BufferView">
            <summary>
            <para>
            Opaque handle to a buffer view object.
            </para>
            <para>
            A _buffer view_ represents a contiguous range of a buffer and a specific format to be used to interpret the data. Buffer views are used to enable shaders to access buffer contents interpreted as formatted data. In order to create a valid buffer view, the buffer must: have been created with at least one of the following usage flags:
            </para>
            <para>
            * ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT * ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.BufferView.Destroy">
            <summary>
            <para>
            Destroy a buffer view object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.BufferView.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.CommandBuffer">
            <summary>
            <para>
            Opaque handle to a command buffer object.
            </para>
            <para>
            Command buffers are objects used to record commands which can: be subsequently submitted to a device queue for execution. There are two levels of command buffers - _primary command buffers_, which can: execute secondary command buffers, and which are submitted to queues, and _secondary command buffers_, which can: be executed by primary command buffers, and which are not directly submitted to queues.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.Begin(SharpVk.CommandBufferBeginInfo)">
            <summary>
            <para>
            Start recording a command buffer.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.End">
            <summary>
            <para>
            Finish recording a command buffer.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.Reset(SharpVk.CommandBufferResetFlags)">
            <summary>
            <para>
            Reset a command buffer.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.BindPipeline(SharpVk.PipelineBindPoint,SharpVk.Pipeline)">
            <summary>
            <para>
            Bind a pipeline object to a command buffer.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.SetViewport(System.UInt32,SharpVk.Viewport[])">
            <summary>
            <para>
            Set the viewport on a command buffer.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.SetScissor(System.UInt32,SharpVk.Rect2D[])">
            <summary>
            <para>
            Set the dynamic scissor rectangles on a command buffer.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.SetLineWidth(System.Single)">
            <summary>
            <para>
            Set the dynamic line width state.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.SetDepthBias(System.Single,System.Single,System.Single)">
            <summary>
            <para>
            Set the depth bias dynamic state.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.SetBlendConstants(System.Single)">
            <summary>
            <para>
            Set the values of blend constants.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.SetDepthBounds(System.Single,System.Single)">
            <summary>
            <para>
            Set the depth bounds test values for a command buffer.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.SetStencilCompareMask(SharpVk.StencilFaceFlags,System.UInt32)">
            <summary>
            <para>
            Set the stencil compare mask dynamic state.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.SetStencilWriteMask(SharpVk.StencilFaceFlags,System.UInt32)">
            <summary>
            <para>
            Set the stencil write mask dynamic state.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.SetStencilReference(SharpVk.StencilFaceFlags,System.UInt32)">
            <summary>
            <para>
            Set the stencil reference dynamic state.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.BindDescriptorSets(SharpVk.PipelineBindPoint,SharpVk.PipelineLayout,System.UInt32,SharpVk.DescriptorSet[],System.UInt32[])">
            <summary>
            <para>
            Binds descriptor sets to a command buffer.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.BindIndexBuffer(SharpVk.Buffer,SharpVk.DeviceSize,SharpVk.IndexType)">
            <summary>
            <para>
            Bind an index buffer to a command buffer.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.BindVertexBuffers(System.UInt32,SharpVk.Buffer[],SharpVk.DeviceSize[])">
            <summary>
            <para>
            Bind vertex buffers to a command buffer.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.Draw(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            <para>
            Draw primitives.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.DrawIndexed(System.UInt32,System.UInt32,System.UInt32,System.Int32,System.UInt32)">
            <summary>
            <para>
            Issue an indexed draw into a command buffer.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.DrawIndirect(SharpVk.Buffer,SharpVk.DeviceSize,System.UInt32,System.UInt32)">
            <summary>
            <para>
            Issue an indirect draw into a command buffer.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.DrawIndexedIndirect(SharpVk.Buffer,SharpVk.DeviceSize,System.UInt32,System.UInt32)">
            <summary>
            <para>
            Perform an indexed indirect draw.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.Dispatch(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            <para>
            Dispatch compute work items.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.DispatchIndirect(SharpVk.Buffer,SharpVk.DeviceSize)">
            <summary>
            <para>
            Dispatch compute work items using indirect parameters.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.CopyBuffer(SharpVk.Buffer,SharpVk.Buffer,SharpVk.BufferCopy[])">
            <summary>
            <para>
            Copy data between buffer regions.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.CopyImage(SharpVk.Image,SharpVk.ImageLayout,SharpVk.Image,SharpVk.ImageLayout,SharpVk.ImageCopy[])">
            <summary>
            <para>
            Copy data between images.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.BlitImage(SharpVk.Image,SharpVk.ImageLayout,SharpVk.Image,SharpVk.ImageLayout,SharpVk.ImageBlit[],SharpVk.Filter)">
            <summary>
            <para>
            Copy regions of an image, potentially performing format conversion,.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.CopyBufferToImage(SharpVk.Buffer,SharpVk.Image,SharpVk.ImageLayout,SharpVk.BufferImageCopy[])">
            <summary>
            <para>
            Copy data from a buffer into an image.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.CopyImageToBuffer(SharpVk.Image,SharpVk.ImageLayout,SharpVk.Buffer,SharpVk.BufferImageCopy[])">
            <summary>
            <para>
            Copy image data into a buffer.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.UpdateBuffer(SharpVk.Buffer,SharpVk.DeviceSize,System.Byte[])">
            <summary>
            <para>
            Update a buffer's contents from host memory.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.FillBuffer(SharpVk.Buffer,SharpVk.DeviceSize,SharpVk.DeviceSize,System.UInt32)">
            <summary>
            <para>
            Fill a region of a buffer with a fixed value.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.ClearColorImage(SharpVk.Image,SharpVk.ImageLayout,SharpVk.ClearColorValue,SharpVk.ImageSubresourceRange[])">
            <summary>
            <para>
            Clear regions of a color image.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.ClearDepthStencilImage(SharpVk.Image,SharpVk.ImageLayout,SharpVk.ClearDepthStencilValue,SharpVk.ImageSubresourceRange[])">
            <summary>
            <para>
            Fill regions of a combined depth-stencil image.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.ClearAttachments(SharpVk.ClearAttachment[],SharpVk.ClearRect[])">
            <summary>
            <para>
            Clear regions within currently bound framebuffer attachments.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.ResolveImage(SharpVk.Image,SharpVk.ImageLayout,SharpVk.Image,SharpVk.ImageLayout,SharpVk.ImageResolve[])">
            <summary>
            <para>
            Resolve regions of an image.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.SetEvent(SharpVk.Event,SharpVk.PipelineStageFlags)">
            <summary>
            <para>
            Set an event object to signaled state.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.ResetEvent(SharpVk.Event,SharpVk.PipelineStageFlags)">
            <summary>
            <para>
            Reset an event object to non-signaled state.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.WaitEvents(SharpVk.Event[],SharpVk.PipelineStageFlags,SharpVk.PipelineStageFlags,SharpVk.MemoryBarrier[],SharpVk.BufferMemoryBarrier[],SharpVk.ImageMemoryBarrier[])">
            <summary>
            <para>
            Wait for one or more events and insert a set of memory.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.PipelineBarrier(SharpVk.PipelineStageFlags,SharpVk.PipelineStageFlags,SharpVk.DependencyFlags,SharpVk.MemoryBarrier[],SharpVk.BufferMemoryBarrier[],SharpVk.ImageMemoryBarrier[])">
            <summary>
            <para>
            Insert a set of execution and memory barriers.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.BeginQuery(SharpVk.QueryPool,System.UInt32,SharpVk.QueryControlFlags)">
            <summary>
            <para>
            Begin a query.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.EndQuery(SharpVk.QueryPool,System.UInt32)">
            <summary>
            <para>
            Ends a query.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.ResetQueryPool(SharpVk.QueryPool,System.UInt32,System.UInt32)">
            <summary>
            <para>
            Reset queries in a query pool.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.WriteTimestamp(SharpVk.PipelineStageFlags,SharpVk.QueryPool,System.UInt32)">
            <summary>
            <para>
            Write a device timestamp into a query object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.CopyQueryPoolResults(SharpVk.QueryPool,System.UInt32,System.UInt32,SharpVk.Buffer,SharpVk.DeviceSize,SharpVk.DeviceSize,SharpVk.QueryResultFlags)">
            <summary>
            <para>
            Copy the results of queries in a query pool to a buffer object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.PushConstants(SharpVk.PipelineLayout,SharpVk.ShaderStageFlags,System.UInt32,System.Byte[])">
            <summary>
            <para>
            Update the values of push constants.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.BeginRenderPass(SharpVk.RenderPassBeginInfo,SharpVk.SubpassContents)">
            <summary>
            <para>
            Begin a new render pass.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.NextSubpass(SharpVk.SubpassContents)">
            <summary>
            <para>
            Transition to the next subpass of a render pass.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.EndRenderPass">
            <summary>
            <para>
            End the current render pass.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.ExecuteCommands(SharpVk.CommandBuffer[])">
            <summary>
            <para>
            Execute a secondary command buffer from a primary command buffer.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.DebugMarkerBegin(SharpVk.DebugMarkerMarkerInfo)">
            <summary>
            <para>
            Open a command buffer marker region.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.DebugMarkerEnd">
            <summary>
            <para>
            Close a command buffer marker region.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.DebugMarkerInsert(SharpVk.DebugMarkerMarkerInfo)">
            <summary>
            <para>
            Insert a marker label into a command buffer.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.DrawIndirectCount(SharpVk.Buffer,SharpVk.DeviceSize,SharpVk.Buffer,SharpVk.DeviceSize,System.UInt32,System.UInt32)">
            <summary>
            <para>
            Perform an indirect draw with the draw count sourced from a buffer.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.DrawIndexedIndirectCount(SharpVk.Buffer,SharpVk.DeviceSize,SharpVk.Buffer,SharpVk.DeviceSize,System.UInt32,System.UInt32)">
            <summary>
            <para>
            Perform an indexed indirect draw with the draw count sourced from a buffer.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.CommandPool">
            <summary>
            <para>
            Opaque handle to a command pool object.
            </para>
            <para>
            Command pools are opaque objects that command buffer memory is allocated from, and which allow the implementation to amortize the cost of resource creation across multiple command buffers. Command pools are application-synchronized, meaning that a command pool must: not be used concurrently in multiple threads. That includes use via recording commands on any command buffers allocated from the pool, as well as operations that allocate, free, and reset command buffers or the pool itself.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandPool.Destroy">
            <summary>
            <para>
            Destroy a command pool object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandPool.Reset(SharpVk.CommandPoolResetFlags)">
            <summary>
            <para>
            Reset a command pool.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandPool.FreeCommandBuffers(SharpVk.CommandBuffer[])">
            <summary>
            <para>
            Free command buffers.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandPool.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.DebugReportCallback">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.DebugReportCallback.Destroy">
            <summary>
            <para>
            Destroy a debug report callback object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.DebugReportCallback.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.DescriptorPool">
            <summary>
            <para>
            Opaque handle to a descriptor pool object.
            </para>
            <para>
            A _descriptor pool_ maintains a pool of descriptors, from which descriptor sets are allocated. Descriptor pools are externally synchronized, meaning that the application must: not allocate and/or free descriptor sets from the same pool in multiple threads simultaneously.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.DescriptorPool.Destroy">
            <summary>
            <para>
            Destroy a descriptor pool object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.DescriptorPool.Reset(SharpVk.DescriptorPoolResetFlags)">
            <summary>
            <para>
            Resets a descriptor pool object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.DescriptorPool.FreeDescriptorSets(SharpVk.DescriptorSet[])">
            <summary>
            <para>
            Free one or more descriptor sets.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.DescriptorPool.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.DescriptorSet">
            <summary>
            <para>
            Opaque handle to a descriptor set object.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DescriptorSetLayout">
            <summary>
            <para>
            Opaque handle to a descriptor set layout object.
            </para>
            <para>
            A descriptor set layout object is defined by an array of zero or more descriptor bindings. Each individual descriptor binding is specified by a descriptor type, a count (array size) of the number of descriptors in the binding, a set of shader stages that can: access the binding, and (if using immutable samplers) an array of sampler descriptors.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.DescriptorSetLayout.Destroy">
            <summary>
            <para>
            Destroy a descriptor set layout object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.DescriptorSetLayout.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.Device">
            <summary>
            <para>
            Opaque handle to a device object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.GetProcedureAddress(System.String)">
            <summary>
            <para>
            Return a function pointer for a command.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.Destroy">
            <summary>
            <para>
            Destroy a logical device.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.GetQueue(System.UInt32,System.UInt32)">
            <summary>
            <para>
            Get a queue handle from a device.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.WaitIdle">
            <summary>
            <para>
            Wait for a device to become idle.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.AllocateMemory(SharpVk.MemoryAllocateInfo)">
            <summary>
            <para>
            Allocate GPU memory.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.FreeMemory(SharpVk.DeviceMemory)">
            <summary>
            <para>
            Free GPU memory.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.FlushMappedMemoryRanges(SharpVk.MappedMemoryRange[])">
            <summary>
            <para>
            Flush mapped memory ranges.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.InvalidateMappedMemoryRanges(SharpVk.MappedMemoryRange[])">
            <summary>
            <para>
            Invalidate ranges of mapped memory objects.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateFence(SharpVk.FenceCreateInfo)">
            <summary>
            <para>
            Create a new fence object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.ResetFences(SharpVk.Fence[])">
            <summary>
            <para>
            Resets one or more fence objects.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.WaitForFences(SharpVk.Fence[],SharpVk.Bool32,System.UInt64)">
            <summary>
            <para>
            Wait for one or more fences to become signaled.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateSemaphore(SharpVk.SemaphoreCreateInfo)">
            <summary>
            <para>
            Create a new queue semaphore object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateEvent(SharpVk.EventCreateInfo)">
            <summary>
            <para>
            Create a new event object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateQueryPool(SharpVk.QueryPoolCreateInfo)">
            <summary>
            <para>
            Create a new query pool object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateBuffer(SharpVk.BufferCreateInfo)">
            <summary>
            <para>
            Create a new buffer object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateBufferView(SharpVk.BufferViewCreateInfo)">
            <summary>
            <para>
            Create a new buffer view object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateImage(SharpVk.ImageCreateInfo)">
            <summary>
            <para>
            Create a new image object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateImageView(SharpVk.ImageViewCreateInfo)">
            <summary>
            <para>
            Create an image view from an existing image.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateShaderModule(SharpVk.ShaderModuleCreateInfo)">
            <summary>
            <para>
            Creates a new shader module object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreatePipelineCache(SharpVk.PipelineCacheCreateInfo)">
            <summary>
            <para>
            Creates a new pipeline cache.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateGraphicsPipelines(SharpVk.PipelineCache,SharpVk.GraphicsPipelineCreateInfo[])">
            <summary>
            <para>
            Create graphics pipelines.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateComputePipelines(SharpVk.PipelineCache,SharpVk.ComputePipelineCreateInfo[])">
            <summary>
            <para>
            Creates a new compute pipeline object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreatePipelineLayout(SharpVk.PipelineLayoutCreateInfo)">
            <summary>
            <para>
            Creates a new pipeline layout object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateSampler(SharpVk.SamplerCreateInfo)">
            <summary>
            <para>
            Create a new sampler object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateDescriptorSetLayout(SharpVk.DescriptorSetLayoutCreateInfo)">
            <summary>
            <para>
            Create a new descriptor set layout.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateDescriptorPool(SharpVk.DescriptorPoolCreateInfo)">
            <summary>
            <para>
            Creates a descriptor pool object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.AllocateDescriptorSets(SharpVk.DescriptorSetAllocateInfo)">
            <summary>
            <para>
            Allocate one or more descriptor sets.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.UpdateDescriptorSets(SharpVk.WriteDescriptorSet[],SharpVk.CopyDescriptorSet[])">
            <summary>
            <para>
            Update the contents of a descriptor set object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateFramebuffer(SharpVk.FramebufferCreateInfo)">
            <summary>
            <para>
            Create a new framebuffer object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateRenderPass(SharpVk.RenderPassCreateInfo)">
            <summary>
            <para>
            Create a new render pass object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateCommandPool(SharpVk.CommandPoolCreateInfo)">
            <summary>
            <para>
            Create a new command pool object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.AllocateCommandBuffers(SharpVk.CommandBufferAllocateInfo)">
            <summary>
            <para>
            Allocate command buffers from an existing command pool.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateSwapchain(SharpVk.SwapchainCreateInfo)">
            <summary>
            <para>
            Create a swapchain.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateSharedSwapchains(SharpVk.SwapchainCreateInfo[])">
            <summary>
            <para>
            Create multiple swapchains that share presentable images.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.DebugMarkerSetObjectTag(SharpVk.DebugMarkerObjectTagInfo)">
            <summary>
            <para>
            Attach arbitrary data to an object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.DebugMarkerSetObjectName(SharpVk.DebugMarkerObjectNameInfo)">
            <summary>
            <para>
            Give a user-friendly name to an object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Device.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.DeviceMemory">
            <summary>
            <para>
            Opaque handle to a device memory object.
            </para>
            <para>
            A Vulkan device operates on data in device memory via memory objects that are represented in the API by a sname:VkDeviceMemory handle.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.DeviceMemory.MapMemory(SharpVk.DeviceSize,SharpVk.DeviceSize,SharpVk.MemoryMapFlags,System.IntPtr@)">
            <summary>
            <para>
            Map a memory object into application address space.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.DeviceMemory.UnmapMemory">
            <summary>
            <para>
            Unmap a previously mapped memory object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.DeviceMemory.GetCommitment">
            <summary>
            <para>
            Query the current commitment for a VkDeviceMemory.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.DeviceMemory.GetMemoryWin32Handle(SharpVk.ExternalMemoryHandleTypeFlags)">
            <summary>
            <para>
            Retrieve Win32 handle to a device memory object.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Display">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.DisplayMode">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.DisplayMode.GetDisplayPlaneCapabilities(System.UInt32)">
            <summary>
            <para>
            Query capabilities of a mode and plane combination.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Event">
            <summary>
            <para>
            Opaque handle to a event object.
            </para>
            <para>
            Events represent a fine-grained synchronization primitive that can: be used to gauge progress through a sequence of commands executed on a queue by Vulkan. An event is initially in the unsignaled state. It can: be signaled by a device, using commands inserted into the command buffer, or by the host. It can: also be reset to the unsignaled state by a device or the host. The host can: query the state of an event. A device can: wait for one or more events to become signaled.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Event.Destroy">
            <summary>
            <para>
            Destroy an event object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Event.GetStatus">
            <summary>
            <para>
            Retrieve the status of an event object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Event.Set">
            <summary>
            <para>
            Set an event to signaled state.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Event.Reset">
            <summary>
            <para>
            Reset an event to non-signaled state.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Event.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.Fence">
            <summary>
            <para>
            Opaque handle to a fence object.
            </para>
            <para>
            Fences can: be used by the host to determine completion of execution of _queue operations_.
            </para>
            <para>
            A fence's status is always either _signaled_ or _unsignaled_. The host can: poll the status of a single fence, or wait for any or all of a group of fences to become signaled.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Fence.Destroy">
            <summary>
            <para>
            Destroy a fence object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Fence.GetStatus">
            <summary>
            <para>
            Return the status of a fence.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Fence.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.Framebuffer">
            <summary>
            <para>
            Opaque handle to a framebuffer object.
            </para>
            <para>
            Render passes operate in conjunction with _framebuffers_. Framebuffers represent a collection of specific memory attachments that a render pass instance uses.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Framebuffer.Destroy">
            <summary>
            <para>
            Destroy a framebuffer object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Framebuffer.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.Image">
            <summary>
            <para>
            Opaque handle to a image object.
            </para>
            <para>
            Images represent multidimensional - up to 3 - arrays of data which can: be used for various purposes (e.g. attachments, textures), by binding them to a graphics or compute pipeline via descriptor sets, or by directly specifying them as parameters to certain commands.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Image.BindMemory(SharpVk.DeviceMemory,SharpVk.DeviceSize)">
            <summary>
            <para>
            Bind device memory to an image object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Image.GetMemoryRequirements">
            <summary>
            <para>
            Returns the memory requirements for specified Vulkan object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Image.GetSparseMemoryRequirements">
            <summary>
            <para>
            Query the memory requirements for a sparse image.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Image.Destroy">
            <summary>
            <para>
            Destroy an image object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Image.GetSubresourceLayout(SharpVk.ImageSubresource)">
            <summary>
            <para>
            Retrieve information about an image subresource.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Image.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.ImageView">
            <summary>
            <para>
            Opaque handle to a image view object.
            </para>
            <para>
            Image objects are not directly accessed by pipeline shaders for reading or writing image data. Instead, _image views_ representing contiguous ranges of the image subresources and containing additional metadata are used for that purpose. Views must: be created on images of compatible types, and must: represent a valid subset of image subresources.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.ImageView.Destroy">
            <summary>
            <para>
            Destroy an image view object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.ImageView.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.Instance">
            <summary>
            <para>
            Opaque handle to a instance object.
            </para>
            <para>
            There is no global state in Vulkan and all per-application state is stored in a sname:VkInstance object. Creating a sname:VkInstance object initializes the Vulkan library and allows the application to pass information about itself to the implementation.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Instance.Create(SharpVk.InstanceCreateInfo,System.Nullable{SharpVk.AllocationCallbacks})">
            <summary>
            <para>
            Create a new Vulkan instance.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Instance.Destroy">
            <summary>
            <para>
            Destroy an instance of Vulkan.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Instance.EnumeratePhysicalDevices">
            <summary>
            <para>
            Enumerates the physical devices accessible to a Vulkan instance.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Instance.GetProcedureAddress(System.String)">
            <summary>
            <para>
            Return a function pointer for a command.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Instance.EnumerateExtensionProperties(System.String)">
            <summary>
            <para>
            Returns up to requested number of global extension properties.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Instance.EnumerateLayerProperties">
            <summary>
            <para>
            Returns up to requested number of global layer properties.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Instance.CreateDisplayPlaneSurface(SharpVk.DisplaySurfaceCreateInfo)">
            <summary>
            <para>
            Create a slink:VkSurfaceKHR structure representing a display plane and mode.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Instance.CreateXlibSurface(SharpVk.XlibSurfaceCreateInfo)">
            <summary>
            <para>
            Create a slink:VkSurfaceKHR object for an X11 window, using the Xlib client-side library.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Instance.CreateXcbSurface(SharpVk.XcbSurfaceCreateInfo)">
            <summary>
            <para>
            Create a slink:VkSurfaceKHR object for a X11 window, using the XCB client-side library.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Instance.CreateWaylandSurface(SharpVk.WaylandSurfaceCreateInfo)">
            <summary>
            <para>
            Create a slink:VkSurfaceKHR object for a Wayland window.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Instance.CreateMirSurface(SharpVk.MirSurfaceCreateInfo)">
            <summary>
            <para>
            Create a slink:VkSurfaceKHR object for a Mir window.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Instance.CreateAndroidSurface(SharpVk.AndroidSurfaceCreateInfo)">
            <summary>
            <para>
            Create a slink:VkSurfaceKHR object for an Android native window.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Instance.CreateWin32Surface(SharpVk.Win32SurfaceCreateInfo)">
            <summary>
            <para>
            Create a slink:VkSurfaceKHR object for an Win32 native window.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Instance.CreateDebugReportCallback(SharpVk.DebugReportCallbackCreateInfo)">
            <summary>
            <para>
            Create a debug report callback object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Instance.DebugReportMessage(SharpVk.DebugReportFlags,SharpVk.DebugReportObjectType,System.UInt64,SharpVk.Size,System.Int32,System.Char,System.Char)">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Instance.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.PhysicalDevice">
            <summary>
            <para>
            Opaque handle to a physical device object.
            </para>
            <para>
            Vulkan separates the concept of _physical_ and _logical_ devices. A physical device usually represents a single device in a system (perhaps made up of several individual hardware devices working together), of which there are a finite number. A logical device represents an application's view of the device.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetFeatures">
            <summary>
            <para>
            Reports capabilities of a physical device.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetFormatProperties(SharpVk.Format)">
            <summary>
            <para>
            Lists physical device's format capabilities.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetImageFormatProperties(SharpVk.Format,SharpVk.ImageType,SharpVk.ImageTiling,SharpVk.ImageUsageFlags,SharpVk.ImageCreateFlags)">
            <summary>
            <para>
            Lists physical device's image format capabilities.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetProperties">
            <summary>
            <para>
            Returns properties of a physical device.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetQueueFamilyProperties">
            <summary>
            <para>
            Reports properties of the queues of the specified physical device.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetMemoryProperties">
            <summary>
            <para>
            Reports memory information for the specified physical device.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.CreateDevice(SharpVk.DeviceCreateInfo)">
            <summary>
            <para>
            Create a new device instance.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.EnumerateDeviceExtensionProperties(System.String)">
            <summary>
            <para>
            Returns properties of available physical device extensions.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.EnumerateDeviceLayerProperties">
            <summary>
            <para>
            Returns properties of available physical device layers.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetSparseImageFormatProperties(SharpVk.Format,SharpVk.ImageType,SharpVk.SampleCountFlags,SharpVk.ImageUsageFlags,SharpVk.ImageTiling)">
            <summary>
            <para>
            Retrieve properties of an image format applied to sparse images.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetSurfaceSupport(System.UInt32,SharpVk.Surface)">
            <summary>
            <para>
            Query if presentation is supported.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetSurfaceCapabilities(SharpVk.Surface)">
            <summary>
            <para>
            Query surface capabilities.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetSurfaceFormats(SharpVk.Surface)">
            <summary>
            <para>
            Query color formats supported by surface.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetSurfacePresentModes(SharpVk.Surface)">
            <summary>
            <para>
            Query supported presentation modes.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetDisplayProperties">
            <summary>
            <para>
            Query information about the available displays.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetDisplayPlaneProperties">
            <summary>
            <para>
            Query the plane properties.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetDisplayPlaneSupportedDisplays(System.UInt32)">
            <summary>
            <para>
            Query the list of displays a plane supports.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetDisplayModeProperties(SharpVk.Display)">
            <summary>
            <para>
            Query the set of mode properties supported by the display.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.CreateDisplayMode(SharpVk.Display,SharpVk.DisplayModeCreateInfo)">
            <summary>
            <para>
            Create a display mode.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetXlibPresentationSupport(System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            <para>
            Query physical device for presentation to X11 server using Xlib.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetXcbPresentationSupport(System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            <para>
            Query physical device for presentation to X11 server using XCB.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetWaylandPresentationSupport(System.UInt32,System.IntPtr)">
            <summary>
            <para>
            Query physical device for presentation to Wayland.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetMirPresentationSupport(System.UInt32,System.IntPtr)">
            <summary>
            <para>
            Query physical device for presentation to Mir.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetWin32PresentationSupport(System.UInt32)">
            <summary>
            <para>
            Query queue family support for presentation on a Win32 display.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetExternalImageFormatProperties(SharpVk.Format,SharpVk.ImageType,SharpVk.ImageTiling,SharpVk.ImageUsageFlags,SharpVk.ImageCreateFlags,SharpVk.ExternalMemoryHandleTypeFlags)">
            <summary>
            <para>
            Determine image capabilities compatible with external memory handle types.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Pipeline">
            <summary>
            <para>
            Opaque handle to a pipeline object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Pipeline.Destroy">
            <summary>
            <para>
            Destroy a pipeline object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Pipeline.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.PipelineCache">
            <summary>
            <para>
            Opaque handle to a pipeline cache object.
            </para>
            <para>
            Pipeline cache objects allow the result of pipeline construction to be reused between pipelines and between runs of an application. Reuse between pipelines is achieved by passing the same pipeline cache object when creating multiple related pipelines. Reuse across runs of an application is achieved by retrieving pipeline cache contents in one run of an application, saving the contents, and using them to preinitialize a pipeline cache on a subsequent run. The contents of the pipeline cache objects are managed by the implementation. Applications can: manage the host memory consumed by a pipeline cache object and control the amount of data retrieved from a pipeline cache object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PipelineCache.Destroy">
            <summary>
            <para>
            Destroy a pipeline cache object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PipelineCache.GetData">
            <summary>
            <para>
            Get the data store from a pipeline cache.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PipelineCache.MergePipelineCaches(SharpVk.PipelineCache[])">
            <summary>
            <para>
            Combine the data stores of pipeline caches.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PipelineCache.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.PipelineLayout">
            <summary>
            <para>
            Opaque handle to a pipeline layout object.
            </para>
            <para>
            Access to descriptor sets from a pipeline is accomplished through a _pipeline layout_. Zero or more descriptor set layouts and zero or more push constant ranges are combined to form a pipeline layout object which describes the complete set of resources that can: be accessed by a pipeline. The pipeline layout represents a sequence of descriptor sets with each having a specific layout. This sequence of layouts is used to determine the interface between shader stages and shader resources. Each pipeline is created using a pipeline layout.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PipelineLayout.Destroy">
            <summary>
            <para>
            Destroy a pipeline layout object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PipelineLayout.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.QueryPool">
            <summary>
            <para>
            Opaque handle to a query pool object.
            </para>
            <para>
            Queries are managed using _query pool_ objects. Each query pool is a collection of a specific number of queries of a particular type.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.QueryPool.Destroy">
            <summary>
            <para>
            Destroy a query pool object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.QueryPool.GetResults(System.UInt32,System.UInt32,System.Byte[],SharpVk.DeviceSize,SharpVk.QueryResultFlags)">
            <summary>
            <para>
            Copy results of queries in a query pool to a host memory region.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.QueryPool.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.Queue">
            <summary>
            <para>
            Opaque handle to a queue object.
            </para>
            <para>
            Creating a logical device also creates the queues associated with that device. The queues to create are described by a set of slink:VkDeviceQueueCreateInfo structures that are passed to flink:vkCreateDevice in pname:pQueueCreateInfos.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Queue.Submit(SharpVk.SubmitInfo[],SharpVk.Fence)">
            <summary>
            <para>
            Submits a sequence of semaphores or command buffers to a queue.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Queue.WaitIdle">
            <summary>
            <para>
            Wait for a queue to become idle.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Queue.BindSparse(SharpVk.BindSparseInfo[],SharpVk.Fence)">
            <summary>
            <para>
            Bind device memory to a sparse resource object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Queue.Present(SharpVk.PresentInfo)">
            <summary>
            <para>
            Queue an image for presentation.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.RenderPass">
            <summary>
            <para>
            Opaque handle to a render pass object.
            </para>
            <para>
            A _render pass_ represents a collection of attachments, subpasses, and dependencies between the subpasses, and describes how the attachments are used over the course of the subpasses. The use of a render pass in a command buffer is a _render pass instance_.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.RenderPass.Destroy">
            <summary>
            <para>
            Destroy a render pass object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.RenderPass.GetRenderAreaGranularity">
            <summary>
            <para>
            Returns the granularity for optimal render area.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.RenderPass.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.Sampler">
            <summary>
            <para>
            Opaque handle to a sampler object.
            </para>
            <para>
            sname:VkSampler objects represent the state of an image sampler which is used by the implementation to read image data and apply filtering and other transformations for the shader.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Sampler.Destroy">
            <summary>
            <para>
            Destroy a sampler object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Sampler.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.Semaphore">
            <summary>
            <para>
            Opaque handle to a semaphore object.
            </para>
            <para>
            Semaphores are used to coordinate queue operations both within a queue and between different queues. A semaphore's status is always either _signaled_ or _unsignaled_.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Semaphore.Destroy">
            <summary>
            <para>
            Destroy a semaphore object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Semaphore.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.ShaderModule">
            <summary>
            <para>
            Opaque handle to a shader module object.
            </para>
            <para>
            _Shader modules_ contain _shader code_ and one or more entry points. Shaders are selected from a shader module by specifying an entry point as part of &lt;&lt;pipelines,pipeline&gt;&gt; creation. The stages of a pipeline can: use shaders that come from different modules. The shader code defining a shader module must: be in the SPIR-V format, as described by the &lt;&lt;spirvenv,Vulkan Environment for SPIR-V&gt;&gt; appendix.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.ShaderModule.Destroy">
            <summary>
            <para>
            Destroy a shader module module.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.ShaderModule.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.Surface">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Surface.Destroy">
            <summary>
            <para>
            Destroy a VkSurfaceKHR object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Surface.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.Swapchain">
            <summary>
            <para>
            -
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Swapchain.Destroy">
            <summary>
            <para>
            Destroy a swapchain object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Swapchain.GetImages">
            <summary>
            <para>
            Obtain the array of presentable images associated with a swapchain.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Swapchain.AcquireNextImage(System.UInt64,SharpVk.Semaphore,SharpVk.Fence)">
            <summary>
            <para>
            Retrieve the index of the next available presentable image.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Swapchain.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.Version">
            <summary>
            Represents a Semantic Version number encoded as a UInt32
            </summary>
        </member>
        <member name="M:SharpVk.Version.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a new version number with the specified values.
            </summary>
            <param name="major">
            The Major version number.
            </param>
            <param name="minor">
            The Minor version number.
            </param>
            <param name="patch">
            The Patch version number.
            </param>
        </member>
        <member name="P:SharpVk.Version.Major">
            <summary>
            The Major version number.
            </summary>
        </member>
        <member name="P:SharpVk.Version.Minor">
            <summary>
            The Minor version number.
            </summary>
        </member>
        <member name="P:SharpVk.Version.Patch">
            <summary>
            The Patch version number.
            </summary>
        </member>
        <member name="M:SharpVk.Version.op_Implicit(System.UInt32)~SharpVk.Version">
            <summary>
            Implicit conversion of a UInt32 value to a decoded Version number.
            </summary>
            <param name="value">
            A semantic version number encoded as a UInt32.
            </param>
        </member>
        <member name="M:SharpVk.Version.op_Explicit(SharpVk.Version)~System.UInt32">
            <summary>
            Explicit conversion of a Version number to an encoded UInt32.
            </summary>
            <param name="size">
            The version number value to encode.
            </param>
        </member>
        <member name="M:SharpVk.Version.ToString">
            <summary>
            Returns a string that represents the current object
            </summary>
            <returns>
            A version string of the format "{Major}.{Minor}.{Patch}".
            </returns>
        </member>
    </members>
</doc>
